---
title: Java线程相关
date: 2018-12-25 19:59:44
categories: Java
tags:Java, 基础
---
http://www.importnew.com/14958.html
### Java线程调度的一点背景
在各种各样的线程中，Java虚拟机必须实现一个有优先权的、基于优先级的调度程序。这意味着Java程序中的每一个线程被分配到一定的优先权，使用定义好的范围内的一个正整数表示。优先级可以被开发者改变。即使线程已经运行了一定时间，Java虚拟机也不会改变其优先级
优先级的值很重要，因为Java虚拟机和下层的操作系统之间的约定是操作系统必须选择有最高优先权的Java线程运行。所以我们说Java实现了一个基于优先权的调度程序。该调度程序使用一种有优先权的方式实现，这意味着当一个有更高优先权的线程到来时，无论低优先级的线程是否在运行，都会中断(抢占)它。这个约定对于操作系统来说并不总是这样，这意味着操作系统有时可能会选择运行一个更低优先级的线程。

### 理解线程的优先权
接下来，理解线程优先级是多线程学习很重要的一步，尤其是了解yield()函数的工作过程。
记住当线程的优先级没有指定时，所有线程都携带普通优先级。
优先级可以用从1到10的范围指定。10表示最高优先级，1表示最低优先级，5是普通优先级。
记住优先级最高的线程在执行时被给予优先。但是不能保证线程在启动时就进入运行状态。
与在线程池中等待运行机会的线程相比，当前正在运行的线程可能总是拥有更高的优先级。
由调度程序决定哪一个线程被执行。
t.setPriority()用来设定线程的优先级。
记住在线程开始方法被调用之前，线程的优先级应该被设定。
你可以使用常量，如MIN_PRIORITY,MAX_PRIORITY，NORM_PRIORITY来设定优先级

总结下来就是，线程的优先级设置并不能保证运行的先后顺序。

### wait、notify、notify、yield
https://blog.csdn.net/wthfeng/article/details/78762343
![线程六种状态.png](https://upload-images.jianshu.io/upload_images/1868685-f60b32316c91ab9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
这三个方法是定义在Object类中的，用于在并发中控制线程的运行与阻塞，前提是要先获取该对象的锁不然会抛出异常。
只有两种情况可以使线程进入阻塞，一是等待进入synchronized块或方法，二是在调用wait方法后重新进入synchronized块或方法。
首先我们要明白java中对象锁的模型，JVM会为一个使用内部锁（synchronized）的对象维护两个集合，Entry Set和Wait Set，也有人翻译为锁池和等待池，意思基本一致。
对于Entry Set：如果线程A已经持有了对象锁，此时如果有其他线程也想获得该对象锁的话，它只能进入Entry Set，并且处于线程的BLOCKED状态。
对于Wait Set：如果线程A调用了wait()方法，那么线程A会释放该对象的锁，进入到Wait Set，并且处于线程的WAITING状态。
wait方法会让线程进入WAITING状态，notify用于唤醒出于Wait 
Set中的线程，大部分的地方使用notifyAll是为了避免死锁的情况。
对于Entry Set中的线程，当对象锁被释放的时候，JVM会唤醒处于Entry Set中的某一个线程，这个线程的状态就从BLOCKED转变为RUNNABLE。
对于Wait Set中的线程，当对象的notify()方法被调用时，JVM会唤醒处于Wait Set中的某一个线程，这个线程的状态就从WAITING转变为RUNNABLE；或者当notifyAll()方法被调用时，Wait Set中的全部线程会转变为RUNNABLE状态。所有Wait Set中被唤醒的线程会被转移到Entry Set中。
eg：假设有一个消费者线程c1，一个生产者p1、p2，此时如果c1、p2出于waiting状态，p1进行生产完成之后buffer已满，调用notify如果p2获取到了锁，p2中判断buffer已满也会进行wait，这个时候c1也没有能力去获取锁，会导致线程一直阻塞下去。
Thread.yield( )方法：
使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了。
yield()做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。
