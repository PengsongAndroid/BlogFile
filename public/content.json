{"meta":{"title":"Song","subtitle":"自命不凡，却无足轻重","description":"Maybe i never told you.","author":"Song","url":"https://github.com/PengsongAndroid/pengsongandroid.github.com"},"pages":[{"title":"category","date":"2017-03-02T03:07:05.437Z","updated":"2017-03-02T01:54:53.378Z","comments":false,"path":"category/index.html","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/category/index.html","excerpt":"","text":""},{"title":"","date":"2017-03-16T07:34:33.947Z","updated":"2017-03-16T07:34:33.947Z","comments":true,"path":"about/index.html","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/about/index.html","excerpt":"","text":"个人介绍2015.5~至今, 负责公司Android客户端，主导项目重构2014.7~至今, 从事Android应用开发爱思考，爱音乐，常犯困Android开发，会点python，会点吉他上海、武汉"},{"title":"project","date":"2017-03-02T03:07:05.442Z","updated":"2017-03-01T09:50:23.070Z","comments":false,"path":"project/index.html","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/project/index.html","excerpt":"","text":""},{"title":"link","date":"2017-03-02T03:07:05.439Z","updated":"2017-03-01T09:50:32.987Z","comments":false,"path":"link/index.html","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/link/index.html","excerpt":"","text":""},{"title":"tag","date":"2017-03-02T03:07:05.445Z","updated":"2017-03-02T01:54:31.953Z","comments":false,"path":"tag/index.html","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"Android在应用退出后发送请求解决方案","slug":"Android在应用退出后发送请求解决方案","date":"2017-03-15T09:07:44.000Z","updated":"2017-03-16T06:20:37.248Z","comments":true,"path":"2017/03/15/Android在应用退出后发送请求解决方案/","link":"","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/2017/03/15/Android在应用退出后发送请求解决方案/","excerpt":"最近有这么一个需求，在app退出登录之后发送请求到后台，这个请求不是特别重要，只是为了应用过审。所以在常规情况下能够发送请求即可，下面方案不保证能够在所有情况下应用退出都能发送请求。 常规退出场景常规情况下应用退出有这么几种情况：1.app内退出按钮或者双击返回；2.最近应用列表，划掉应用卡片（常见）；3.应用崩溃；我们一个个来分析解决。","text":"最近有这么一个需求，在app退出登录之后发送请求到后台，这个请求不是特别重要，只是为了应用过审。所以在常规情况下能够发送请求即可，下面方案不保证能够在所有情况下应用退出都能发送请求。 常规退出场景常规情况下应用退出有这么几种情况：1.app内退出按钮或者双击返回；2.最近应用列表，划掉应用卡片（常见）；3.应用崩溃；我们一个个来分析解决。 解决方案对于app内部退出这个是我们可控的。但是用户在退出时发请求需要考虑到网络情况，肯定不可能等到请求成功才退出应用。而我们app退出是有下面的操作： 1234//系统退出 清空所有缓存 取消所有请求UenUtils.cleanAppConfigWhenExit();MyApplication.cancelAllPostRequests();ActivityStack.popAll(); 最后一步内其实是杀掉了当前进程 1android.os.Process.killProcess(android.os.Process.myPid()); 因为这一步应用是被杀掉的，肯定是不能在这里做发请求操作，只能开启service来帮我们完成操作。具体的实现方案就是，在应用启动时startService，这是一个远端的service 123456789&lt;service android:name=\".service.MyService\" android:process=\":remote\" android:enabled=\"true\"&gt; &lt;intent-filter&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;action android:name=\"MyService\" /&gt; &lt;/intent-filter&gt;&lt;/service&gt; 然后我们在应用退出的时候，发送一个广播（因为这个进程间的通信很简单，所以就用这种比较方便的方式），service中处理广播，处理完成后销毁自己，思路就是这样。关键部分代码如下：activity:12345678@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; Intent intent = new Intent(); intent.setAction(\"test\"); sendBroadcast(intent); android.os.Process.killProcess(android.os.Process.myPid()); return super.onKeyDown(keyCode, event);&#125; service：12345678910111213141516171819202122@Overridepublic void onCreate() &#123; Log.i(TAG, \"onCreate \"); super.onCreate(); IntentFilter filter = new IntentFilter(); filter.addAction(\"test\"); registerReceiver(receiver, filter);&#125; BroadcastReceiver receiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (\"test\".equals(intent.getAction()))&#123; Log.e(TAG, \"onReceive\"); /**发请求*/ .... /**请求成功后解绑 */ unregisterReceiver(receiver); android.os.Process.killProcess(android.os.Process.myPid()); &#125; &#125;&#125;; 对于在任务列表划掉应用查了一些资料之后发现Service中有一个回调方法1234@Overridepublic void onTaskRemoved(Intent rootIntent) &#123;&#125; 官方文档解释如下，大意就是如果这个service在运行并且用户移除了这个任务，会回调这个方法，但是如果你设置了FLAG_STOP_WITH_TASK这个属性，你将不会接收到这个回调，并且service会直接停止。 提到了FLAG_STOP_WITH_TASK这个属性，我们来看看这是什么：如果设置了该属性，用户删除了基于某个应用程序的任务，系统将自动停止该服务，然后这个是通过stopWithTask属性来控制的。所以我们在service中配置，添加一行 1android:stopWithTask=\"true\" 然后我们测试一下，启动服务后从任务列表移除应用，方法确实被回调。我们可以在这个方法内发送请求，不过需要注意的是，我测试的机器上，移除应用后方法回调然后service就挂掉了，1s左右service又重启了，走了onCreate、onStartCommand回调。我是直接在回调方法里写请求，这样会出现接收不到请求的返回的情况。所以我建议的方式是，在回调方法里写一个SharedPreferences，然后再重新创建的时候再去通过读取这个值来发送请求。具体实现代码如下：1234567891011121314151617181920212223242526 // 配置文件 private static SharedPreferences g_settings = null; private static SharedPreferences.Editor g_editor = null; @Override public void onCreate() &#123; super.onCreate(); g_settings = getSharedPreferences(\"ps\", Context.MODE_APPEND); test = g_settings.getBoolean(\"test\", false); Log.i(TAG, \"onCreate \" + test); if (test)&#123; g_editor.putBoolean(\"test\", false); g_editor.commit();/**发请求 然后销毁service*/... &#125; g_editor = g_settings.edit(); &#125; @Override public void onTaskRemoved(Intent rootIntent) &#123; Log.e(TAG, \"onTaskRemoved\"); g_editor.putBoolean(\"test\", true); g_editor.commit(); super.onTaskRemoved(rootIntent); &#125; 对于异常崩溃的情况可以在application中实现UncaughtExceptionHandler，然后在回调方法中发送广播，思路跟上面的差不多。具体的实现就是这些，只写了重要部分的代码，其他的也都很简单就不贴出来了。","categories":[{"name":"Android文章","slug":"Android文章","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/categories/Android文章/"}],"tags":[{"name":"Android, 应用退出","slug":"Android-应用退出","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/tags/Android-应用退出/"}]},{"title":"Android Studio 添加library添加.so文件问题解决","slug":"Android Studio 添加library添加.so文件问题解决","date":"2016-05-26T23:33:44.000Z","updated":"2017-03-16T06:13:14.353Z","comments":true,"path":"2016/05/27/Android Studio 添加library添加.so文件问题解决/","link":"","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/2016/05/27/Android Studio 添加library添加.so文件问题解决/","excerpt":"今天在Android studio中导入library和.so时发生各种异常，记录一下解决过程。","text":"今天在Android studio中导入library和.so时发生各种异常，记录一下解决过程。 导入library首先在项目中import project，如图 需要注意的是，如果library是eclipse项目，需要先在eclipse中导出为AS项目。 然后在Project Structure选项中查看项目的Dependencies，点击右上角的加号，选择Module dependency,选择刚刚导入的library，点击ok让项目自动构建即可。 导入module 等待构建完毕之后，我Run的时候却发现很多报错信息，反复修改各种配置，错误信息也是一会一个，发现错误信息全部集中在 android/support/v4 这个依赖上，错误信息如下： 12345678Error:Execution failed for task ':transformClassesWithJarMergingForDebug'.com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/content/Loader$OnLoadCompleteListener.classError:Execution failed for task ':transformClassesWithJarMergingForDebug'.Error:Execution failed for task ':transformClassesWithJarMergingForDebug'.com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/graphics/drawable/DrawableCompat$BaseDrawableImpl.classError:Execution failed for tasktransformClassesWithJarMergingForDebug'.com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/accessibilityservice/AccessibilityServiceInfoCompat.class 发现了问题出在哪里之后，就从这里入手，一顿搜索，发现应该是存在重复的jar包。想起来导入的library是用的本地的support-v4 jar包，原本的项目也用的是本地的support-v4 jar包，觉得问题可能就是在这。然后删除了两个项目本地的jar包，通过gradle来导入。两个项目的gradle都添加。 1compile 'com.android.support:support-v4:22.1.1' 然后等待项目构建完成，再次Run，没有问题。不知道为什么通过gradle添加依赖就能解决，不过已经用了AS，最好还是按照AS的配置来构建项目，避免不必要的问题。 导入.so文件上面导入的library项目，还需要在原项目中添加.so文件，两个文件夹下各有一个.so文件，添加到项目中。 运行时报错如下： java.lang.UnsatisfiedLinkError: Native method not found: com.baidu.platform.comjni.map.commonmemcache.JNICommonMemCache.Create:()J at com.baidu.platform.comjni.map.commonmemcache.JNICommonMemCache.Create(Native Method) at com.baidu.platform.comjni.map.commonmemcache.a.a(Unknown Source) at com.baidu.platform.comapi.e.c.b(Unknown Source) at com.baidu.mapapi.a.c(Unknown Source) at com.baidu.mapapi.SDKInitializer.initialize(Unknown Source) 提示跟百度地图的Native方法找不到了，我仅仅添加了.so文件结果导致百度地图报错。排查了几次之后，又去百度官网看文档，发现demo中lib目录下各种cpu类型目录底下都会有同名的.so文件，怀疑是因为我只在armeabi文件夹下添加了百度地图的.so库，新建了armeabi-v7a文件夹后没有添加百度地图的文件，导致去这个文件夹下加载不到.so库，然后复制了一份百度地图的.so库至armeabi-v7a文件夹，成功解决。","categories":[{"name":"Android日常问题","slug":"Android日常问题","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/categories/Android日常问题/"}],"tags":[{"name":"Android, .so, Android studio","slug":"Android-so-Android-studio","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/tags/Android-so-Android-studio/"}]},{"title":"Android Studio 2.0异常","slug":"Android Studio 2.0异常","date":"2016-05-24T23:33:44.000Z","updated":"2017-03-16T06:15:59.224Z","comments":true,"path":"2016/05/25/Android Studio 2.0异常/","link":"","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/2016/05/25/Android Studio 2.0异常/","excerpt":"","text":"今天在导入同事的项目完成后没报错，运行的时候却报了一段错误，自己弄了会儿都没解决。 123:app:transformClassesWithInstantRunForDebug FAILEDError:Execution failed for task ':app:transformClassesWithInstantRunForDebug'.Invalid signature file digest for Manifest main attributes 后来经过搜索发现解决方案，禁用2.0的快速启动新功能，按照下图取消勾选即可。","categories":[{"name":"Android日常问题","slug":"Android日常问题","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/categories/Android日常问题/"}],"tags":[{"name":"Android studio, 环境问题","slug":"Android-studio-环境问题","permalink":"https://github.com/PengsongAndroid/pengsongandroid.github.com/tags/Android-studio-环境问题/"}]}]}