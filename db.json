{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/uploads/head.jpg","path":"uploads/head.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/baidu_verify_S28Oid6auY.html","hash":"61f002e4b2bec681cc21162167602d31d3b1a4aa","modified":1495616642000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1514806389000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1514806389000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1514806389000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1514806389000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1514806389000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1514806389000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1514806389000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1514806389000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1514806389000},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1514806389000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1514806389000},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1514806389000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1514806389000},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1514806389000},{"_id":"source/_posts/Android Studio 2.0异常.md","hash":"08707aa1fea489674f043e8f407b2bad0c3607eb","modified":1495616642000},{"_id":"source/_posts/Android Studio 添加library添加.so文件问题解决.md","hash":"39686ce55eef6dc13d3ea05254144d9bb656cf09","modified":1495616642000},{"_id":"source/_posts/Volley源码浅析.md","hash":"22b71c326a570fe189eb0670ee2526e503361c8a","modified":1545286397616},{"_id":"themes/next/README.md","hash":"898213e66d34a46c3cf8446bf693bd50db0d3269","modified":1514806389000},{"_id":"source/_posts/Android注解实践——运行时注解框架.md","hash":"c737b19eeb64965b78d3dc49939f4324882c504a","modified":1495616642000},{"_id":"source/_posts/okhttp3请求头中含中文报错原因及解决方案.md","hash":"c503af3ced50daf1aa98c2d084243fa0951a3988","modified":1545189574414},{"_id":"source/_posts/Android在应用退出后发送请求解决方案.md","hash":"c74259a0c0536618343182b1af5245a0fd0c8327","modified":1495616642000},{"_id":"source/_posts/Android注解实践——打造编译时注解框架.md","hash":"92833da95567d6d3444de170925a3110f7cf4010","modified":1495616642000},{"_id":"source/about/index.md","hash":"1c5413cb687cbb41407a865447189ff470663057","modified":1495616642000},{"_id":"source/link/index.md","hash":"70bd0de52901bac812f76d5510925361a7921d99","modified":1495616642000},{"_id":"source/category/index.md","hash":"838a0ba6b58f4def2b6b3c0d5841288f801bdb85","modified":1495616642000},{"_id":"source/project/index.md","hash":"4d60344688c45be4bbb37b3c0a0980489a77300e","modified":1495616642000},{"_id":"source/tag/index.md","hash":"bee4c19d66746750628e1e0ba397e6623a31d70a","modified":1495616642000},{"_id":"source/_posts/Dagger2 从生成的代码看原理.md","hash":"af28b36761e88f8a83805c5c90cef7c0facc579f","modified":1495616642000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1514806389000},{"_id":"source/_posts/坑爹的Android 6.0 startDiscovery蓝牙搜索不到设备问题.md","hash":"352bf004a16509fac6c1226dc8d6f60ab947a6b5","modified":1495616642000},{"_id":"source/uploads/head.jpg","hash":"b12453dce1c258b1f49e491377a900f67f8c88c9","modified":1493019073000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1514806389000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1514806389000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1514806389000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1514806389000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1514806389000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1514806389000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1514806389000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1514806389000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1514806389000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1514806389000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1514806389000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1514806389000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1514806389000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1514806389000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1514806389000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1514806389000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1514806389000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1514806389000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1514806389000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1514806389000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1514806389000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1514806389000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1514806389000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1514806389000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1514806389000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1514806389000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1514806389000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1514806389000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1514806389000},{"_id":"themes/next/_config.yml","hash":"020e76506d218ab7f909c9aac3560df1adbccaf3","modified":1545030942890},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514806389000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514806389000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1514806389000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1514806389000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1514806389000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1514806389000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1514806389000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1514806389000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1514806389000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1514806389000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1514806389000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1514806389000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1514806389000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1514806389000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1514806389000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1514806389000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1514806389000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1514806389000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1514806389000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1514806389000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1514806389000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1514806389000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1514806389000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1514806389000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1514806389000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1514806389000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1514806389000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1514806389000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1514806389000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1514806389000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1514806389000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1514806389000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1514806389000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1514806389000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1514806389000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1514806389000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1514806389000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1514806389000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1514806389000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1514806389000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1514806389000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1514806389000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1514806389000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1514806389000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514806389000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1514806389000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1514806389000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1514806389000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1514806389000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1514806389000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1514806389000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1514806389000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1514806389000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1514806389000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1514806389000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1514806389000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1514806389000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1514806389000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1514806389000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1514806389000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514806389000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514806389000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1514806389000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1514806389000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1514806389000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1514806389000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1514806389000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1514806389000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1514806389000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1514806389000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1514806389000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1514806389000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1514806389000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1514806389000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1514806389000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1514806389000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1514806389000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1514806389000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1514806389000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1514806389000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1514806389000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1514806389000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1514806389000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1514806389000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1514806389000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1514806389000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1514806389000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1514806389000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1514806389000},{"_id":"themes/next/source/js/src/motion.js","hash":"b0e4014838c83b56a45dd08f9c6e71a60a92694d","modified":1545030884311},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1514806389000},{"_id":"themes/next/source/images/favicon.png","hash":"6eaec736a9025bab80ead602cbe7ae916bcbd6e1","modified":1493019073000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1514806389000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1514806389000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1514806389000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1514806389000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1514806389000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1514806389000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1514806389000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1514806389000},{"_id":"public/search.xml","hash":"a66470aa2d3709f047ee8ae148b4526220253897","modified":1545286415721},{"_id":"public/about/index.html","hash":"5d0ca0683c8763f2b15372b2d9ebce465c87a92e","modified":1545286081694},{"_id":"public/baidu_verify_S28Oid6auY.html","hash":"da77062fb9c8adaf88a1fac2ebd2ea429c9c8f10","modified":1545286081694},{"_id":"public/link/index.html","hash":"037aeb09272790b7bc51524c2ffb97421cea9bf9","modified":1545286081696},{"_id":"public/category/index.html","hash":"2ab3efa4971aff44f184fbf9204b56bfd721c437","modified":1545286081697},{"_id":"public/project/index.html","hash":"d8142e023189d4a7d4ccf6dd9f8d59033c83219f","modified":1545286081697},{"_id":"public/tag/index.html","hash":"5b1412f709ba6dab0a59d01387af17ee92887acb","modified":1545286081697},{"_id":"public/2018/12/05/okhttp3请求头中含中文报错原因及解决方案/index.html","hash":"ebebec34c12b613b86c92415baacb75516140338","modified":1545286245909},{"_id":"public/2017/04/24/Dagger2 从生成的代码看原理/index.html","hash":"ae888f5a09f943a49a10d95daaf911bfd3e00fbd","modified":1545286245910},{"_id":"public/2017/04/09/Android注解实践——运行时注解框架/index.html","hash":"0ff35897cf5c00605cfd94bd3dfe1e1e98bfaa0b","modified":1545286081697},{"_id":"public/2017/03/27/坑爹的Android 6.0 startDiscovery蓝牙搜索不到设备问题/index.html","hash":"8167f34a4d22efdcb48f0cfe6196be14838a8f4c","modified":1545286081697},{"_id":"public/2017/04/08/Android注解实践——打造编译时注解框架/index.html","hash":"dfff488e239bde8092092265fea29570dff45408","modified":1545286081697},{"_id":"public/2017/03/15/Android在应用退出后发送请求解决方案/index.html","hash":"97de49ed3c632e7b5792ee0110d79a155f9a3d86","modified":1545286081697},{"_id":"public/index.html","hash":"b120ab24481606dcd7cae367eb4c3f60da629ba2","modified":1545286245911},{"_id":"public/2016/05/25/Android Studio 2.0异常/index.html","hash":"a2693f87fb83dacf7fd5e5ef91dad6f366a87d8f","modified":1545286081697},{"_id":"public/categories/Android日常问题/index.html","hash":"ac008d3dee8ffb2be2b92b67fad713317707377b","modified":1545286081698},{"_id":"public/categories/Android文章/index.html","hash":"3edcd25656b019420a6b05ef083ad43fc7ac627a","modified":1545286081698},{"_id":"public/2016/05/27/Android Studio 添加library添加.so文件问题解决/index.html","hash":"1db00e98f7f5d65f8c82c597db6e254960ca1ce6","modified":1545286081698},{"_id":"public/categories/Android常见问题/index.html","hash":"7a206d7ee5ad95dec170e183aefc26e0ef9ee2f2","modified":1545286081698},{"_id":"public/archives/index.html","hash":"74545f410bdcbac441c5bd42106c5a353f5e0cd6","modified":1545286245911},{"_id":"public/archives/2016/index.html","hash":"3490e313503de1e8a6880037c86a9ee08cb9c0f8","modified":1545286081698},{"_id":"public/archives/2016/05/index.html","hash":"4567704f7d44fdc6e9204e58f645296ac5fa1ad5","modified":1545286081698},{"_id":"public/archives/2017/index.html","hash":"b3f3f538b98289d8f743367a37a60a2245793da9","modified":1545286081698},{"_id":"public/archives/2017/03/index.html","hash":"a509f17c983c9c325277a07f588df2a6594731cf","modified":1545286081698},{"_id":"public/archives/2018/index.html","hash":"2cabdd7d54dfbea6b45bb9fd4d0889e58bbf6e31","modified":1545286245911},{"_id":"public/archives/2017/04/index.html","hash":"5af877e696d481c5ee561824fbac1ae9aaa2949e","modified":1545286081698},{"_id":"public/archives/2018/12/index.html","hash":"8162e26a7b1cf752f6848af693fdad54c0d8c09f","modified":1545286245911},{"_id":"public/tags/Android-studio-环境问题/index.html","hash":"eded30a44316d6532bbda1003aad25ffa8c0e0e5","modified":1545286081698},{"_id":"public/tags/Android-so-Android-studio/index.html","hash":"1a82783261bac50fca45944568e28c507dfee2a3","modified":1545286081698},{"_id":"public/tags/Android-Annotation-注解-运行时注解-EventBus/index.html","hash":"d860d6821ec654627afe85d8832d4c3069a7a4b0","modified":1545286081699},{"_id":"public/tags/Android-应用退出/index.html","hash":"114e1017ba91176b8851d70fedaba3cee5183cd0","modified":1545286081699},{"_id":"public/tags/Android-开源库-Dagger/index.html","hash":"cbfddaa6adc67bc61bb3c7b5ff769ec35e2cb3db","modified":1545286081699},{"_id":"public/tags/Android-Android权限机制/index.html","hash":"777f650c51ee40e7ef27a6d797f0ed07651679da","modified":1545286081699},{"_id":"public/tags/Android-常见问题/index.html","hash":"d5aef7a661a67cfc35ec8a6cb92a422fb28eb54f","modified":1545286081699},{"_id":"public/tags/Android-Annotation-注解/index.html","hash":"d7729b46cc73c554f05ab2611c327318ce35d1d4","modified":1545286081699},{"_id":"public/2018/11/19/Volley源码浅析/index.html","hash":"2c592270cb068c1f806ec4e00402767b336ea380","modified":1545286081705},{"_id":"public/categories/Android实战/index.html","hash":"b15b31aff0ca65b7e97e1a6b7049c414a152c304","modified":1545286245911},{"_id":"public/archives/2018/11/index.html","hash":"f923e81d604591e7f1aaa2ee38345d96c7411668","modified":1545286081705},{"_id":"public/tags/Android-第三方框架/index.html","hash":"8d49e5b49d4d3af5157172deec6bcd31bcafb0c2","modified":1545286245911},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1545286081705},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1545286081705},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1545286081705},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1545286081706},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1545286081706},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1545286081706},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1545286081706},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545286081706},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1545286081706},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545286081706},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1545286081706},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1545286081706},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1545286081706},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1545286081706},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1545286081706},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1545286081706},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1545286081706},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1545286081706},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1545286081706},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1545286081706},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1545286081706},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1545286081706},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1545286081707},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1545286081707},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1545286081707},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1545286081707},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1545286081707},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1545286081707},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1545286081707},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1545286081707},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1545286081707},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1545286081707},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1545286081707},{"_id":"public/uploads/head.jpg","hash":"b12453dce1c258b1f49e491377a900f67f8c88c9","modified":1545286083065},{"_id":"public/images/favicon.png","hash":"6eaec736a9025bab80ead602cbe7ae916bcbd6e1","modified":1545286083068},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1545286083071},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1545286083071},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1545286083075},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1545286083075},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1545286083075},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1545286083075},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1545286083075},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1545286083076},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1545286083076},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1545286083076},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1545286083076},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1545286083076},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1545286083076},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1545286083076},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1545286083076},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1545286083076},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1545286083076},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1545286083076},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1545286083076},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1545286083076},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1545286083076},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1545286083076},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1545286083076},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1545286083076},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1545286083077},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1545286083077},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1545286083077},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1545286083077},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1545286083077},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1545286083077},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1545286083077},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1545286083077},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1545286083077},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1545286083077},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1545286083077},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1545286083077},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1545286083077},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1545286083077},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1545286083077},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1545286083077},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1545286083077},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1545286083078},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1545286083078},{"_id":"public/css/main.css","hash":"51b618ea51aab58f6ff967a09af0e8afd44a4e62","modified":1545286083078},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1545286083081},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1545286083082},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1545286083084},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1545286083084},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1545286083084},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1545286083084},{"_id":"public/js/src/motion.js","hash":"b0e4014838c83b56a45dd08f9c6e71a60a92694d","modified":1545286083084},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1545286083084},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1545286083084},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1545286083084},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1545286083134},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1545286083134},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1545286083150},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1545286083151},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1545286083151},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1545286083161},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1545286083161},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1545286083161},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1545286083161},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1545286083161},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1545286083161},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1545286083162},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1545286083169},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1545286083170},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1545286083171},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1545286083176},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1545286083190},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1545286083191},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1545286083192},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1545286083195},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1545286083201},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1545286083204},{"_id":"public/2018/12/20/Volley源码浅析/index.html","hash":"f0df7fbaba1d101137f800b0cdf0281de7b3aa62","modified":1545286415746}],"Category":[{"name":"Android日常问题","_id":"cjpw7fkrp0003gcl93ldtwqqz"},{"name":"Android文章","_id":"cjpw7fkxa000fgcl9bcl32x2s"},{"name":"Android常见问题","_id":"cjpw7fkyu000zgcl9expq06gv"},{"name":"Android实战","_id":"cjpw7fl0z0014gcl9syticzj5"}],"Data":[],"Page":[{"_content":"S28Oid6auY","source":"baidu_verify_S28Oid6auY.html","raw":"S28Oid6auY","date":"2018-11-05T09:02:39.568Z","updated":"2017-05-24T09:04:02.000Z","path":"baidu_verify_S28Oid6auY.html","title":"","comments":1,"layout":"page","_id":"cjpw7fkls0000gcl9bbt1xer6","content":"S28Oid6auY","site":{"data":{}},"excerpt":"","more":"S28Oid6auY"},{"title":"","layout":"about","comments":1,"_content":"\n### 个人介绍\n2015.5~至今, 负责公司Android客户端，主导项目重构\n2014.7~至今, 从事Android应用开发\n爱思考，爱音乐，常犯困\nAndroid开发，会点python，会点吉他\n上海、武汉","source":"about/index.md","raw":"---\ntitle: \nlayout: about\ncomments: true\n---\n\n### 个人介绍\n2015.5~至今, 负责公司Android客户端，主导项目重构\n2014.7~至今, 从事Android应用开发\n爱思考，爱音乐，常犯困\nAndroid开发，会点python，会点吉他\n上海、武汉","date":"2018-11-05T09:02:39.577Z","updated":"2017-05-24T09:04:02.000Z","path":"about/index.html","_id":"cjpw7fkx4000cgcl9owpqk6hd","content":"<h3 id=\"个人介绍\"><a href=\"#个人介绍\" class=\"headerlink\" title=\"个人介绍\"></a>个人介绍</h3><p>2015.5~至今, 负责公司Android客户端，主导项目重构<br>2014.7~至今, 从事Android应用开发<br>爱思考，爱音乐，常犯困<br>Android开发，会点python，会点吉他<br>上海、武汉</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"个人介绍\"><a href=\"#个人介绍\" class=\"headerlink\" title=\"个人介绍\"></a>个人介绍</h3><p>2015.5~至今, 负责公司Android客户端，主导项目重构<br>2014.7~至今, 从事Android应用开发<br>爱思考，爱音乐，常犯困<br>Android开发，会点python，会点吉他<br>上海、武汉</p>\n"},{"title":"link","layout":"link","comments":0,"_content":"","source":"link/index.md","raw":"---\ntitle: link\nlayout: link\ncomments: false\n---","date":"2018-11-05T09:02:39.602Z","updated":"2017-05-24T09:04:02.000Z","path":"link/index.html","_id":"cjpw7fkx7000egcl9qemw4fbm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"category","layout":"category","comments":0,"_content":"","source":"category/index.md","raw":"---\ntitle: category\nlayout: category\ncomments: false\n---","date":"2018-11-05T09:02:39.590Z","updated":"2017-05-24T09:04:02.000Z","path":"category/index.html","_id":"cjpw7fkxc000igcl9cv5l3l1u","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"project","layout":"project","comments":0,"_content":"","source":"project/index.md","raw":"---\ntitle: project\nlayout: project\ncomments: false\n---","date":"2018-11-05T09:02:39.612Z","updated":"2017-05-24T09:04:02.000Z","path":"project/index.html","_id":"cjpw7fkxg000kgcl9td7aml6f","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tag","layout":"tag","comments":0,"_content":"","source":"tag/index.md","raw":"---\ntitle: tag\nlayout: tag\ncomments: false\n---","date":"2018-11-05T09:02:39.625Z","updated":"2017-05-24T09:04:02.000Z","path":"tag/index.html","_id":"cjpw7fkxj000ngcl9jsvm0qql","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Android Studio 2.0异常","date":"2016-05-24T23:33:44.000Z","_content":"今天在导入同事的项目完成后没报错，运行的时候却报了一段错误，自己弄了会儿都没解决。\n\n```java\n\t:app:transformClassesWithInstantRunForDebug FAILED\n\tError:Execution failed for task ':app:transformClassesWithInstantRunForDebug'.\n\tInvalid signature file digest for Manifest main attributes\n```\n\n\n后来经过搜索发现解决方案，禁用2.0的快速启动新功能，按照下图取消勾选即可。\n![alt text](http://7xrxl6.com1.z0.glb.clouddn.com/as%E5%BC%82%E5%B8%B8.png \"\")\n","source":"_posts/Android Studio 2.0异常.md","raw":"---\ntitle: Android Studio 2.0异常\ndate: 2016-05-25 07:33:44\ncategories: Android日常问题\ntags: Android studio, 环境问题\n---\n今天在导入同事的项目完成后没报错，运行的时候却报了一段错误，自己弄了会儿都没解决。\n\n```java\n\t:app:transformClassesWithInstantRunForDebug FAILED\n\tError:Execution failed for task ':app:transformClassesWithInstantRunForDebug'.\n\tInvalid signature file digest for Manifest main attributes\n```\n\n\n后来经过搜索发现解决方案，禁用2.0的快速启动新功能，按照下图取消勾选即可。\n![alt text](http://7xrxl6.com1.z0.glb.clouddn.com/as%E5%BC%82%E5%B8%B8.png \"\")\n","slug":"Android Studio 2.0异常","published":1,"updated":"2017-05-24T09:04:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw7fkrh0001gcl9yrenf4uf","content":"<p>今天在导入同事的项目完成后没报错，运行的时候却报了一段错误，自己弄了会儿都没解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:app:transformClassesWithInstantRunForDebug FAILED</span><br><span class=\"line\">Error:Execution failed <span class=\"keyword\">for</span> task <span class=\"string\">':app:transformClassesWithInstantRunForDebug'</span>.</span><br><span class=\"line\">Invalid signature file digest <span class=\"keyword\">for</span> Manifest main attributes</span><br></pre></td></tr></table></figure>\n<p>后来经过搜索发现解决方案，禁用2.0的快速启动新功能，按照下图取消勾选即可。<br><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/as%E5%BC%82%E5%B8%B8.png\" alt=\"alt text\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天在导入同事的项目完成后没报错，运行的时候却报了一段错误，自己弄了会儿都没解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:app:transformClassesWithInstantRunForDebug FAILED</span><br><span class=\"line\">Error:Execution failed <span class=\"keyword\">for</span> task <span class=\"string\">':app:transformClassesWithInstantRunForDebug'</span>.</span><br><span class=\"line\">Invalid signature file digest <span class=\"keyword\">for</span> Manifest main attributes</span><br></pre></td></tr></table></figure>\n<p>后来经过搜索发现解决方案，禁用2.0的快速启动新功能，按照下图取消勾选即可。<br><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/as%E5%BC%82%E5%B8%B8.png\" alt=\"alt text\"></p>\n"},{"title":"Android Studio 添加library添加.so文件问题解决","date":"2016-05-26T23:33:44.000Z","_content":"今天在Android studio中导入library和.so时发生各种异常，记录一下解决过程。\n<!-- more -->\n## 导入library\n首先在项目中import project，如图\n\n![alt text](http://7xrxl6.com1.z0.glb.clouddn.com/import_project.png \"project\")\n\n需要注意的是，如果library是eclipse项目，需要先在eclipse中导出为AS项目。\n\n然后在Project Structure选项中查看项目的Dependencies，点击右上角的加号，选择Module dependency,选择刚刚导入的library，点击ok让项目自动构建即可。\n\n导入module\n\n![alt text](http://7xrxl6.com1.z0.glb.clouddn.com/import_moudle.png \"module\")\n\n等待构建完毕之后，我Run的时候却发现很多报错信息，反复修改各种配置，错误信息也是一会一个，发现错误信息全部集中在 android/support/v4 这个依赖上，错误信息如下：\n\n```java\n\tError:Execution failed for task ':transformClassesWithJarMergingForDebug'.\n\tcom.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/content/Loader$OnLoadCompleteListener.classError:Execution failed for task ':transformClassesWithJarMergingForDebug'.\n\n\tError:Execution failed for task ':transformClassesWithJarMergingForDebug'.\n\tcom.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/graphics/drawable/DrawableCompat$BaseDrawableImpl.class\n\n\tError:Execution failed for tasktransformClassesWithJarMergingForDebug'.\n\tcom.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/accessibilityservice/AccessibilityServiceInfoCompat.class\n```\n\n发现了问题出在哪里之后，就从这里入手，一顿搜索，发现应该是存在重复的jar包。想起来导入的library是用的本地的support-v4 jar包，原本的项目也用的是本地的support-v4 jar包，觉得问题可能就是在这。然后删除了两个项目本地的jar包，通过gradle来导入。两个项目的gradle都添加。\n\n```java\n\tcompile 'com.android.support:support-v4:22.1.1'\n```\n\n然后等待项目构建完成，再次Run，没有问题。不知道为什么通过gradle添加依赖就能解决，不过已经用了AS，最好还是按照AS的配置来构建项目，避免不必要的问题。\n\n## 导入.so文件\n上面导入的library项目，还需要在原项目中添加.so文件，两个文件夹下各有一个.so文件，添加到项目中。\n![enter image description here](http://7xrxl6.com1.z0.glb.clouddn.com/so.png)\n\n运行时报错如下：\n\n```java\n\tjava.lang.UnsatisfiedLinkError: Native method not found:\n\t\tcom.baidu.platform.comjni.map.commonmemcache.JNICommonMemCache.Create:()J\n\t\tat com.baidu.platform.comjni.map.commonmemcache.JNICommonMemCache.Create(Native Method)\n\t\tat com.baidu.platform.comjni.map.commonmemcache.a.a(Unknown Source)\n\t\tat com.baidu.platform.comapi.e.c.b(Unknown Source)\n\t\tat com.baidu.mapapi.a.c(Unknown Source)\n\t\tat com.baidu.mapapi.SDKInitializer.initialize(Unknown Source)\n```\t\n\n提示跟百度地图的Native方法找不到了，我仅仅添加了.so文件结果导致百度地图报错。排查了几次之后，又去百度官网看文档，发现demo中lib目录下各种cpu类型目录底下都会有同名的.so文件，怀疑是因为我只在armeabi文件夹下添加了百度地图的.so库，新建了armeabi-v7a文件夹后没有添加百度地图的文件，导致去这个文件夹下加载不到.so库，然后复制了一份百度地图的.so库至armeabi-v7a文件夹，成功解决。","source":"_posts/Android Studio 添加library添加.so文件问题解决.md","raw":"---\ntitle: Android Studio 添加library添加.so文件问题解决\ndate: 2016-05-27 07:33:44\ncategories: Android日常问题\ntags: Android, .so, Android studio\n---\n今天在Android studio中导入library和.so时发生各种异常，记录一下解决过程。\n<!-- more -->\n## 导入library\n首先在项目中import project，如图\n\n![alt text](http://7xrxl6.com1.z0.glb.clouddn.com/import_project.png \"project\")\n\n需要注意的是，如果library是eclipse项目，需要先在eclipse中导出为AS项目。\n\n然后在Project Structure选项中查看项目的Dependencies，点击右上角的加号，选择Module dependency,选择刚刚导入的library，点击ok让项目自动构建即可。\n\n导入module\n\n![alt text](http://7xrxl6.com1.z0.glb.clouddn.com/import_moudle.png \"module\")\n\n等待构建完毕之后，我Run的时候却发现很多报错信息，反复修改各种配置，错误信息也是一会一个，发现错误信息全部集中在 android/support/v4 这个依赖上，错误信息如下：\n\n```java\n\tError:Execution failed for task ':transformClassesWithJarMergingForDebug'.\n\tcom.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/content/Loader$OnLoadCompleteListener.classError:Execution failed for task ':transformClassesWithJarMergingForDebug'.\n\n\tError:Execution failed for task ':transformClassesWithJarMergingForDebug'.\n\tcom.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/graphics/drawable/DrawableCompat$BaseDrawableImpl.class\n\n\tError:Execution failed for tasktransformClassesWithJarMergingForDebug'.\n\tcom.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/accessibilityservice/AccessibilityServiceInfoCompat.class\n```\n\n发现了问题出在哪里之后，就从这里入手，一顿搜索，发现应该是存在重复的jar包。想起来导入的library是用的本地的support-v4 jar包，原本的项目也用的是本地的support-v4 jar包，觉得问题可能就是在这。然后删除了两个项目本地的jar包，通过gradle来导入。两个项目的gradle都添加。\n\n```java\n\tcompile 'com.android.support:support-v4:22.1.1'\n```\n\n然后等待项目构建完成，再次Run，没有问题。不知道为什么通过gradle添加依赖就能解决，不过已经用了AS，最好还是按照AS的配置来构建项目，避免不必要的问题。\n\n## 导入.so文件\n上面导入的library项目，还需要在原项目中添加.so文件，两个文件夹下各有一个.so文件，添加到项目中。\n![enter image description here](http://7xrxl6.com1.z0.glb.clouddn.com/so.png)\n\n运行时报错如下：\n\n```java\n\tjava.lang.UnsatisfiedLinkError: Native method not found:\n\t\tcom.baidu.platform.comjni.map.commonmemcache.JNICommonMemCache.Create:()J\n\t\tat com.baidu.platform.comjni.map.commonmemcache.JNICommonMemCache.Create(Native Method)\n\t\tat com.baidu.platform.comjni.map.commonmemcache.a.a(Unknown Source)\n\t\tat com.baidu.platform.comapi.e.c.b(Unknown Source)\n\t\tat com.baidu.mapapi.a.c(Unknown Source)\n\t\tat com.baidu.mapapi.SDKInitializer.initialize(Unknown Source)\n```\t\n\n提示跟百度地图的Native方法找不到了，我仅仅添加了.so文件结果导致百度地图报错。排查了几次之后，又去百度官网看文档，发现demo中lib目录下各种cpu类型目录底下都会有同名的.so文件，怀疑是因为我只在armeabi文件夹下添加了百度地图的.so库，新建了armeabi-v7a文件夹后没有添加百度地图的文件，导致去这个文件夹下加载不到.so库，然后复制了一份百度地图的.so库至armeabi-v7a文件夹，成功解决。","slug":"Android Studio 添加library添加.so文件问题解决","published":1,"updated":"2017-05-24T09:04:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw7fkrm0002gcl9tkytj30b","content":"<p>今天在Android studio中导入library和.so时发生各种异常，记录一下解决过程。<br><a id=\"more\"></a></p>\n<h2 id=\"导入library\"><a href=\"#导入library\" class=\"headerlink\" title=\"导入library\"></a>导入library</h2><p>首先在项目中import project，如图</p>\n<p><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/import_project.png\" alt=\"alt text\" title=\"project\"></p>\n<p>需要注意的是，如果library是eclipse项目，需要先在eclipse中导出为AS项目。</p>\n<p>然后在Project Structure选项中查看项目的Dependencies，点击右上角的加号，选择Module dependency,选择刚刚导入的library，点击ok让项目自动构建即可。</p>\n<p>导入module</p>\n<p><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/import_moudle.png\" alt=\"alt text\" title=\"module\"></p>\n<p>等待构建完毕之后，我Run的时候却发现很多报错信息，反复修改各种配置，错误信息也是一会一个，发现错误信息全部集中在 android/support/v4 这个依赖上，错误信息如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error:Execution failed <span class=\"keyword\">for</span> task <span class=\"string\">':transformClassesWithJarMergingForDebug'</span>.</span><br><span class=\"line\">com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/content/Loader$OnLoadCompleteListener.classError:Execution failed <span class=\"keyword\">for</span> task <span class=\"string\">':transformClassesWithJarMergingForDebug'</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">Error:Execution failed <span class=\"keyword\">for</span> task <span class=\"string\">':transformClassesWithJarMergingForDebug'</span>.</span><br><span class=\"line\">com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/graphics/drawable/DrawableCompat$BaseDrawableImpl.class</span><br><span class=\"line\"></span><br><span class=\"line\">Error:Execution failed <span class=\"keyword\">for</span> tasktransformClassesWithJarMergingForDebug<span class=\"string\">'.</span></span><br><span class=\"line\"><span class=\"string\">com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/accessibilityservice/AccessibilityServiceInfoCompat.class</span></span><br></pre></td></tr></table></figure>\n<p>发现了问题出在哪里之后，就从这里入手，一顿搜索，发现应该是存在重复的jar包。想起来导入的library是用的本地的support-v4 jar包，原本的项目也用的是本地的support-v4 jar包，觉得问题可能就是在这。然后删除了两个项目本地的jar包，通过gradle来导入。两个项目的gradle都添加。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile <span class=\"string\">'com.android.support:support-v4:22.1.1'</span></span><br></pre></td></tr></table></figure>\n<p>然后等待项目构建完成，再次Run，没有问题。不知道为什么通过gradle添加依赖就能解决，不过已经用了AS，最好还是按照AS的配置来构建项目，避免不必要的问题。</p>\n<h2 id=\"导入-so文件\"><a href=\"#导入-so文件\" class=\"headerlink\" title=\"导入.so文件\"></a>导入.so文件</h2><p>上面导入的library项目，还需要在原项目中添加.so文件，两个文件夹下各有一个.so文件，添加到项目中。<br><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/so.png\" alt=\"enter image description here\"></p>\n<p>运行时报错如下：</p>\n<pre><code class=\"java\">java.lang.UnsatisfiedLinkError: Native method not found:\n    com.baidu.platform.comjni.map.commonmemcache.JNICommonMemCache.Create:()J\n    at com.baidu.platform.comjni.map.commonmemcache.JNICommonMemCache.Create(Native Method)\n    at com.baidu.platform.comjni.map.commonmemcache.a.a(Unknown Source)\n    at com.baidu.platform.comapi.e.c.b(Unknown Source)\n    at com.baidu.mapapi.a.c(Unknown Source)\n    at com.baidu.mapapi.SDKInitializer.initialize(Unknown Source)\n</code></pre>\n<p>提示跟百度地图的Native方法找不到了，我仅仅添加了.so文件结果导致百度地图报错。排查了几次之后，又去百度官网看文档，发现demo中lib目录下各种cpu类型目录底下都会有同名的.so文件，怀疑是因为我只在armeabi文件夹下添加了百度地图的.so库，新建了armeabi-v7a文件夹后没有添加百度地图的文件，导致去这个文件夹下加载不到.so库，然后复制了一份百度地图的.so库至armeabi-v7a文件夹，成功解决。</p>\n","site":{"data":{}},"excerpt":"<p>今天在Android studio中导入library和.so时发生各种异常，记录一下解决过程。<br>","more":"</p>\n<h2 id=\"导入library\"><a href=\"#导入library\" class=\"headerlink\" title=\"导入library\"></a>导入library</h2><p>首先在项目中import project，如图</p>\n<p><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/import_project.png\" alt=\"alt text\" title=\"project\"></p>\n<p>需要注意的是，如果library是eclipse项目，需要先在eclipse中导出为AS项目。</p>\n<p>然后在Project Structure选项中查看项目的Dependencies，点击右上角的加号，选择Module dependency,选择刚刚导入的library，点击ok让项目自动构建即可。</p>\n<p>导入module</p>\n<p><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/import_moudle.png\" alt=\"alt text\" title=\"module\"></p>\n<p>等待构建完毕之后，我Run的时候却发现很多报错信息，反复修改各种配置，错误信息也是一会一个，发现错误信息全部集中在 android/support/v4 这个依赖上，错误信息如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error:Execution failed <span class=\"keyword\">for</span> task <span class=\"string\">':transformClassesWithJarMergingForDebug'</span>.</span><br><span class=\"line\">com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/content/Loader$OnLoadCompleteListener.classError:Execution failed <span class=\"keyword\">for</span> task <span class=\"string\">':transformClassesWithJarMergingForDebug'</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">Error:Execution failed <span class=\"keyword\">for</span> task <span class=\"string\">':transformClassesWithJarMergingForDebug'</span>.</span><br><span class=\"line\">com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/graphics/drawable/DrawableCompat$BaseDrawableImpl.class</span><br><span class=\"line\"></span><br><span class=\"line\">Error:Execution failed <span class=\"keyword\">for</span> tasktransformClassesWithJarMergingForDebug<span class=\"string\">'.</span></span><br><span class=\"line\"><span class=\"string\">com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: android/support/v4/accessibilityservice/AccessibilityServiceInfoCompat.class</span></span><br></pre></td></tr></table></figure>\n<p>发现了问题出在哪里之后，就从这里入手，一顿搜索，发现应该是存在重复的jar包。想起来导入的library是用的本地的support-v4 jar包，原本的项目也用的是本地的support-v4 jar包，觉得问题可能就是在这。然后删除了两个项目本地的jar包，通过gradle来导入。两个项目的gradle都添加。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile <span class=\"string\">'com.android.support:support-v4:22.1.1'</span></span><br></pre></td></tr></table></figure>\n<p>然后等待项目构建完成，再次Run，没有问题。不知道为什么通过gradle添加依赖就能解决，不过已经用了AS，最好还是按照AS的配置来构建项目，避免不必要的问题。</p>\n<h2 id=\"导入-so文件\"><a href=\"#导入-so文件\" class=\"headerlink\" title=\"导入.so文件\"></a>导入.so文件</h2><p>上面导入的library项目，还需要在原项目中添加.so文件，两个文件夹下各有一个.so文件，添加到项目中。<br><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/so.png\" alt=\"enter image description here\"></p>\n<p>运行时报错如下：</p>\n<pre><code class=\"java\">java.lang.UnsatisfiedLinkError: Native method not found:\n    com.baidu.platform.comjni.map.commonmemcache.JNICommonMemCache.Create:()J\n    at com.baidu.platform.comjni.map.commonmemcache.JNICommonMemCache.Create(Native Method)\n    at com.baidu.platform.comjni.map.commonmemcache.a.a(Unknown Source)\n    at com.baidu.platform.comapi.e.c.b(Unknown Source)\n    at com.baidu.mapapi.a.c(Unknown Source)\n    at com.baidu.mapapi.SDKInitializer.initialize(Unknown Source)\n</code></pre>\n<p>提示跟百度地图的Native方法找不到了，我仅仅添加了.so文件结果导致百度地图报错。排查了几次之后，又去百度官网看文档，发现demo中lib目录下各种cpu类型目录底下都会有同名的.so文件，怀疑是因为我只在armeabi文件夹下添加了百度地图的.so库，新建了armeabi-v7a文件夹后没有添加百度地图的文件，导致去这个文件夹下加载不到.so库，然后复制了一份百度地图的.so库至armeabi-v7a文件夹，成功解决。</p>"},{"title":"Android注解实践——运行时注解框架","date":"2017-04-09T10:45:13.000Z","_content":"\n之前写了一篇编译期注解的文章，里面有提到注解作用的三种时期，SOURCE是会被编译器丢弃的注解，CLASS是在编译器保存，RUNTIME是在运行期保留。网上大多的资料讲的也都是编译期的注解，因为这是一种不影响效率的方式，也是很多热门开源库采用的方式。但是有些时候编译期注解并不能帮我们解决碰到的问题，这个时候如果了解运行时注解，也许就能解决问题。基础的概念前一篇已经讲过，这里就不再介绍了。\n\n<!-- more -->\n\n#### 实现原理\n运行时注解操作的原理就是运用反射，去获取到我们注解所操作的元素（Filed、Method...），然后再去获得Annotation进行操作，完成我们的目的。\n主要运用的有这些方法:\n* **<T extends Annotation> T getAnnotation(Class<T> annotationClass)**\n返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。\n* **Annotation[] getAnnotations()**\n返回该程序元素上存在的所有注解。\n* **boolean is AnnotationPresent(Class<?extends Annotation> annotationClass)**\n判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。\n* **Annotation[] getDeclaredAnnotations()**\n返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。\n\n理论虽然简单，但是抽象，下面具体讲讲如何简单的实现。\n\n#### 举个栗子\n##### [EventBus](https://github.com/greenrobot/EventBus)\nEventBus大家应该都不陌生，它是一个基于观察者模式的事件发布/订阅框架，开发者可以通过极少的代码去实现多个模块之间的通信，而不需要以层层传递接口的形式去单独构建通信桥梁。这个库的优秀以及流行更是因为它使用方便、性能高、支持多线程等各种优点。\n这个库里面也运用了不少注解的技术，这篇文章就略微的讲一下EventBus是如何通过注解，指定不同线程去处理消息的。(以下源码都在是EventBus 3.0.0版本下)\n```java\n    @Subscribe(threadMode = ThreadMode.BACKGROUND) //在ui线程执行\n    public void processEvent(TestEvent event){\n\n    }\n```\n上面代码是指定在UI线程中处理消息。然后看一下注解是在org.greenrobot.eventbus.SubscriberMethodFinder中的findUsingReflectionInSingleClass()方法处理的。\n```java\n\tprivate void findUsingReflectionInSingleClass(FindState findState) {\n        Method[] methods;\n        //获取所有方法\n        try {\n            // This is faster than getMethods, especially when subscribers are fat classes like Activities\n            methods = findState.clazz.getDeclaredMethods();\n        } catch (Throwable th) {\n            // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149\n            methods = findState.clazz.getMethods();\n            findState.skipSuperClasses = true;\n        }\n        for (Method method : methods) {\n            int modifiers = method.getModifiers();\n            //判断方法修饰的类型\n            if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {\n                Class<?>[] parameterTypes = method.getParameterTypes();\n                //限制参数数量\n                if (parameterTypes.length == 1) {\n                //取得注释\n                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);\n                    if (subscribeAnnotation != null) {\n                        Class<?> eventType = parameterTypes[0];\n                        if (findState.checkAdd(method, eventType)) {\n                        //获取线程类型\n                            ThreadMode threadMode = subscribeAnnotation.threadMode();\n                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,\n                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));\n                        }\n                    }\n                } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {\n                    String methodName = method.getDeclaringClass().getName() + \".\" + method.getName();\n                    throw new EventBusException(\"@Subscribe method \" + methodName +\n                            \"must have exactly 1 parameter but has \" + parameterTypes.length);\n                }\n            } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {\n                String methodName = method.getDeclaringClass().getName() + \".\" + method.getName();\n                throw new EventBusException(methodName +\n                        \" is a illegal @Subscribe method: must be public, non-static, and non-abstract\");\n            }\n        }\n\t}\n```\n上面就通过反射获取到了注册类中的注解方法，然后获取注解值，在构造SubscriberMethod的时候就传入了threadMode，然后在Post的时候，会根据不同的类型去进行不同的处理：\n```java\n\tprivate void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {\n        switch (subscription.subscriberMethod.threadMode) {\n            case POSTING:\n                invokeSubscriber(subscription, event);\n                break;\n            case MAIN:\n                if (isMainThread) {\n                    invokeSubscriber(subscription, event);\n                } else {\n                    mainThreadPoster.enqueue(subscription, event);\n                }\n                break;\n            case BACKGROUND:\n                if (isMainThread) {\n                    backgroundPoster.enqueue(subscription, event);\n                } else {\n                    invokeSubscriber(subscription, event);\n                }\n                break;\n            case ASYNC:\n                asyncPoster.enqueue(subscription, event);\n                break;\n            default:\n                throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode);\n        }\n    }\n```\n根据不同的类型会有不同的Poster去在对应线程操作\n```java\n    private final HandlerPoster mainThreadPoster;\n    private final BackgroundPoster backgroundPoster;\n    private final AsyncPoster asyncPoster;\n```\n\n以上就是运行期注解在EventBus中的一些应用以及简单的理解。\n\n我们自己操作的时候，也可以通过同样的方式，先声明一个运行期注解，然后在需要操作的地方反射的获取到被注解的元素，进行需要的操作。\n\n#### 总结\n至此注解的文章就写完了，可以看到原理其实比较简单。而我们学习这个的目的，一方面是更好的去理解各种流行框架的原理以及设计思路，在面对一些重复的代码工作中可以变得更加高效，也是给自己的思维一个拓展，在面对项目的设计问题时，有一个武器可以使用，也可以更好的去理解各种解耦的思想。","source":"_posts/Android注解实践——运行时注解框架.md","raw":"---\ntitle: Android注解实践——运行时注解框架\ndate: 2017-04-9 18:45:13\ncategories: Android文章\ntags: Android, Annotation, 注解, 运行时注解, EventBus\n---\n\n之前写了一篇编译期注解的文章，里面有提到注解作用的三种时期，SOURCE是会被编译器丢弃的注解，CLASS是在编译器保存，RUNTIME是在运行期保留。网上大多的资料讲的也都是编译期的注解，因为这是一种不影响效率的方式，也是很多热门开源库采用的方式。但是有些时候编译期注解并不能帮我们解决碰到的问题，这个时候如果了解运行时注解，也许就能解决问题。基础的概念前一篇已经讲过，这里就不再介绍了。\n\n<!-- more -->\n\n#### 实现原理\n运行时注解操作的原理就是运用反射，去获取到我们注解所操作的元素（Filed、Method...），然后再去获得Annotation进行操作，完成我们的目的。\n主要运用的有这些方法:\n* **<T extends Annotation> T getAnnotation(Class<T> annotationClass)**\n返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。\n* **Annotation[] getAnnotations()**\n返回该程序元素上存在的所有注解。\n* **boolean is AnnotationPresent(Class<?extends Annotation> annotationClass)**\n判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。\n* **Annotation[] getDeclaredAnnotations()**\n返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。\n\n理论虽然简单，但是抽象，下面具体讲讲如何简单的实现。\n\n#### 举个栗子\n##### [EventBus](https://github.com/greenrobot/EventBus)\nEventBus大家应该都不陌生，它是一个基于观察者模式的事件发布/订阅框架，开发者可以通过极少的代码去实现多个模块之间的通信，而不需要以层层传递接口的形式去单独构建通信桥梁。这个库的优秀以及流行更是因为它使用方便、性能高、支持多线程等各种优点。\n这个库里面也运用了不少注解的技术，这篇文章就略微的讲一下EventBus是如何通过注解，指定不同线程去处理消息的。(以下源码都在是EventBus 3.0.0版本下)\n```java\n    @Subscribe(threadMode = ThreadMode.BACKGROUND) //在ui线程执行\n    public void processEvent(TestEvent event){\n\n    }\n```\n上面代码是指定在UI线程中处理消息。然后看一下注解是在org.greenrobot.eventbus.SubscriberMethodFinder中的findUsingReflectionInSingleClass()方法处理的。\n```java\n\tprivate void findUsingReflectionInSingleClass(FindState findState) {\n        Method[] methods;\n        //获取所有方法\n        try {\n            // This is faster than getMethods, especially when subscribers are fat classes like Activities\n            methods = findState.clazz.getDeclaredMethods();\n        } catch (Throwable th) {\n            // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149\n            methods = findState.clazz.getMethods();\n            findState.skipSuperClasses = true;\n        }\n        for (Method method : methods) {\n            int modifiers = method.getModifiers();\n            //判断方法修饰的类型\n            if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {\n                Class<?>[] parameterTypes = method.getParameterTypes();\n                //限制参数数量\n                if (parameterTypes.length == 1) {\n                //取得注释\n                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);\n                    if (subscribeAnnotation != null) {\n                        Class<?> eventType = parameterTypes[0];\n                        if (findState.checkAdd(method, eventType)) {\n                        //获取线程类型\n                            ThreadMode threadMode = subscribeAnnotation.threadMode();\n                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,\n                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));\n                        }\n                    }\n                } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {\n                    String methodName = method.getDeclaringClass().getName() + \".\" + method.getName();\n                    throw new EventBusException(\"@Subscribe method \" + methodName +\n                            \"must have exactly 1 parameter but has \" + parameterTypes.length);\n                }\n            } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {\n                String methodName = method.getDeclaringClass().getName() + \".\" + method.getName();\n                throw new EventBusException(methodName +\n                        \" is a illegal @Subscribe method: must be public, non-static, and non-abstract\");\n            }\n        }\n\t}\n```\n上面就通过反射获取到了注册类中的注解方法，然后获取注解值，在构造SubscriberMethod的时候就传入了threadMode，然后在Post的时候，会根据不同的类型去进行不同的处理：\n```java\n\tprivate void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {\n        switch (subscription.subscriberMethod.threadMode) {\n            case POSTING:\n                invokeSubscriber(subscription, event);\n                break;\n            case MAIN:\n                if (isMainThread) {\n                    invokeSubscriber(subscription, event);\n                } else {\n                    mainThreadPoster.enqueue(subscription, event);\n                }\n                break;\n            case BACKGROUND:\n                if (isMainThread) {\n                    backgroundPoster.enqueue(subscription, event);\n                } else {\n                    invokeSubscriber(subscription, event);\n                }\n                break;\n            case ASYNC:\n                asyncPoster.enqueue(subscription, event);\n                break;\n            default:\n                throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode);\n        }\n    }\n```\n根据不同的类型会有不同的Poster去在对应线程操作\n```java\n    private final HandlerPoster mainThreadPoster;\n    private final BackgroundPoster backgroundPoster;\n    private final AsyncPoster asyncPoster;\n```\n\n以上就是运行期注解在EventBus中的一些应用以及简单的理解。\n\n我们自己操作的时候，也可以通过同样的方式，先声明一个运行期注解，然后在需要操作的地方反射的获取到被注解的元素，进行需要的操作。\n\n#### 总结\n至此注解的文章就写完了，可以看到原理其实比较简单。而我们学习这个的目的，一方面是更好的去理解各种流行框架的原理以及设计思路，在面对一些重复的代码工作中可以变得更加高效，也是给自己的思维一个拓展，在面对项目的设计问题时，有一个武器可以使用，也可以更好的去理解各种解耦的思想。","slug":"Android注解实践——运行时注解框架","published":1,"updated":"2017-05-24T09:04:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw7fkx2000bgcl93ht42qdo","content":"<p>之前写了一篇编译期注解的文章，里面有提到注解作用的三种时期，SOURCE是会被编译器丢弃的注解，CLASS是在编译器保存，RUNTIME是在运行期保留。网上大多的资料讲的也都是编译期的注解，因为这是一种不影响效率的方式，也是很多热门开源库采用的方式。但是有些时候编译期注解并不能帮我们解决碰到的问题，这个时候如果了解运行时注解，也许就能解决问题。基础的概念前一篇已经讲过，这里就不再介绍了。</p>\n<a id=\"more\"></a>\n<h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p>运行时注解操作的原理就是运用反射，去获取到我们注解所操作的元素（Filed、Method…），然后再去获得Annotation进行操作，完成我们的目的。<br>主要运用的有这些方法:</p>\n<ul>\n<li><strong><t extends=\"\" annotation=\"\"> T getAnnotation(Class<t> annotationClass)</t></t></strong><br>返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</li>\n<li><strong>Annotation[] getAnnotations()</strong><br>返回该程序元素上存在的所有注解。</li>\n<li><strong>boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</strong><br>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。</li>\n<li><strong>Annotation[] getDeclaredAnnotations()</strong><br>返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</li>\n</ul>\n<p>理论虽然简单，但是抽象，下面具体讲讲如何简单的实现。</p>\n<h4 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h4><h5 id=\"EventBus\"><a href=\"#EventBus\" class=\"headerlink\" title=\"EventBus\"></a><a href=\"https://github.com/greenrobot/EventBus\">EventBus</a></h5><p>EventBus大家应该都不陌生，它是一个基于观察者模式的事件发布/订阅框架，开发者可以通过极少的代码去实现多个模块之间的通信，而不需要以层层传递接口的形式去单独构建通信桥梁。这个库的优秀以及流行更是因为它使用方便、性能高、支持多线程等各种优点。<br>这个库里面也运用了不少注解的技术，这篇文章就略微的讲一下EventBus是如何通过注解，指定不同线程去处理消息的。(以下源码都在是EventBus 3.0.0版本下)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND) <span class=\"comment\">//在ui线程执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">processEvent</span><span class=\"params\">(TestEvent event)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码是指定在UI线程中处理消息。然后看一下注解是在org.greenrobot.eventbus.SubscriberMethodFinder中的findUsingReflectionInSingleClass()方法处理的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">findUsingReflectionInSingleClass</span><span class=\"params\">(FindState findState)</span> </span>&#123;</span><br><span class=\"line\">       Method[] methods;</span><br><span class=\"line\">       <span class=\"comment\">//获取所有方法</span></span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class=\"line\">           methods = findState.clazz.getDeclaredMethods();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (Throwable th) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class=\"line\">           methods = findState.clazz.getMethods();</span><br><span class=\"line\">           findState.skipSuperClasses = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (Method method : methods) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> modifiers = method.getModifiers();</span><br><span class=\"line\">           <span class=\"comment\">//判断方法修饰的类型</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class=\"number\">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class=\"line\">               <span class=\"comment\">//限制参数数量</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (parameterTypes.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">//取得注释</span></span><br><span class=\"line\">                   Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (subscribeAnnotation != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                       Class&lt;?&gt; eventType = parameterTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class=\"line\">                       <span class=\"comment\">//获取线程类型</span></span><br><span class=\"line\">                           ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class=\"line\">                           findState.subscriberMethods.add(<span class=\"keyword\">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class=\"line\">                                   subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class=\"line\">                   String methodName = method.getDeclaringClass().getName() + <span class=\"string\">\".\"</span> + method.getName();</span><br><span class=\"line\">                   <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"@Subscribe method \"</span> + methodName +</span><br><span class=\"line\">                           <span class=\"string\">\"must have exactly 1 parameter but has \"</span> + parameterTypes.length);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class=\"line\">               String methodName = method.getDeclaringClass().getName() + <span class=\"string\">\".\"</span> + method.getName();</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(methodName +</span><br><span class=\"line\">                       <span class=\"string\">\" is a illegal @Subscribe method: must be public, non-static, and non-abstract\"</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面就通过反射获取到了注册类中的注解方法，然后获取注解值，在构造SubscriberMethod的时候就传入了threadMode，然后在Post的时候，会根据不同的类型去进行不同的处理：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postToSubscription</span><span class=\"params\">(Subscription subscription, Object event, <span class=\"keyword\">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> POSTING:</span><br><span class=\"line\">               invokeSubscriber(subscription, event);</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> MAIN:</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">                   invokeSubscriber(subscription, event);</span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                   mainThreadPoster.enqueue(subscription, event);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> BACKGROUND:</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">                   backgroundPoster.enqueue(subscription, event);</span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                   invokeSubscriber(subscription, event);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> ASYNC:</span><br><span class=\"line\">               asyncPoster.enqueue(subscription, event);</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unknown thread mode: \"</span> + subscription.subscriberMethod.threadMode);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>根据不同的类型会有不同的Poster去在对应线程操作<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HandlerPoster mainThreadPoster;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BackgroundPoster backgroundPoster;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncPoster asyncPoster;</span><br></pre></td></tr></table></figure></p>\n<p>以上就是运行期注解在EventBus中的一些应用以及简单的理解。</p>\n<p>我们自己操作的时候，也可以通过同样的方式，先声明一个运行期注解，然后在需要操作的地方反射的获取到被注解的元素，进行需要的操作。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>至此注解的文章就写完了，可以看到原理其实比较简单。而我们学习这个的目的，一方面是更好的去理解各种流行框架的原理以及设计思路，在面对一些重复的代码工作中可以变得更加高效，也是给自己的思维一个拓展，在面对项目的设计问题时，有一个武器可以使用，也可以更好的去理解各种解耦的思想。</p>\n","site":{"data":{}},"excerpt":"<p>之前写了一篇编译期注解的文章，里面有提到注解作用的三种时期，SOURCE是会被编译器丢弃的注解，CLASS是在编译器保存，RUNTIME是在运行期保留。网上大多的资料讲的也都是编译期的注解，因为这是一种不影响效率的方式，也是很多热门开源库采用的方式。但是有些时候编译期注解并不能帮我们解决碰到的问题，这个时候如果了解运行时注解，也许就能解决问题。基础的概念前一篇已经讲过，这里就不再介绍了。</p>","more":"<h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p>运行时注解操作的原理就是运用反射，去获取到我们注解所操作的元素（Filed、Method…），然后再去获得Annotation进行操作，完成我们的目的。<br>主要运用的有这些方法:</p>\n<ul>\n<li><strong><t extends=\"\" annotation=\"\"> T getAnnotation(Class<t> annotationClass)</t></t></strong><br>返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</li>\n<li><strong>Annotation[] getAnnotations()</strong><br>返回该程序元素上存在的所有注解。</li>\n<li><strong>boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</strong><br>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。</li>\n<li><strong>Annotation[] getDeclaredAnnotations()</strong><br>返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</li>\n</ul>\n<p>理论虽然简单，但是抽象，下面具体讲讲如何简单的实现。</p>\n<h4 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h4><h5 id=\"EventBus\"><a href=\"#EventBus\" class=\"headerlink\" title=\"EventBus\"></a><a href=\"https://github.com/greenrobot/EventBus\">EventBus</a></h5><p>EventBus大家应该都不陌生，它是一个基于观察者模式的事件发布/订阅框架，开发者可以通过极少的代码去实现多个模块之间的通信，而不需要以层层传递接口的形式去单独构建通信桥梁。这个库的优秀以及流行更是因为它使用方便、性能高、支持多线程等各种优点。<br>这个库里面也运用了不少注解的技术，这篇文章就略微的讲一下EventBus是如何通过注解，指定不同线程去处理消息的。(以下源码都在是EventBus 3.0.0版本下)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND) <span class=\"comment\">//在ui线程执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">processEvent</span><span class=\"params\">(TestEvent event)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码是指定在UI线程中处理消息。然后看一下注解是在org.greenrobot.eventbus.SubscriberMethodFinder中的findUsingReflectionInSingleClass()方法处理的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">findUsingReflectionInSingleClass</span><span class=\"params\">(FindState findState)</span> </span>&#123;</span><br><span class=\"line\">       Method[] methods;</span><br><span class=\"line\">       <span class=\"comment\">//获取所有方法</span></span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class=\"line\">           methods = findState.clazz.getDeclaredMethods();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (Throwable th) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class=\"line\">           methods = findState.clazz.getMethods();</span><br><span class=\"line\">           findState.skipSuperClasses = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (Method method : methods) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> modifiers = method.getModifiers();</span><br><span class=\"line\">           <span class=\"comment\">//判断方法修饰的类型</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class=\"number\">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class=\"line\">               <span class=\"comment\">//限制参数数量</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (parameterTypes.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">//取得注释</span></span><br><span class=\"line\">                   Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (subscribeAnnotation != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                       Class&lt;?&gt; eventType = parameterTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class=\"line\">                       <span class=\"comment\">//获取线程类型</span></span><br><span class=\"line\">                           ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class=\"line\">                           findState.subscriberMethods.add(<span class=\"keyword\">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class=\"line\">                                   subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class=\"line\">                   String methodName = method.getDeclaringClass().getName() + <span class=\"string\">\".\"</span> + method.getName();</span><br><span class=\"line\">                   <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"@Subscribe method \"</span> + methodName +</span><br><span class=\"line\">                           <span class=\"string\">\"must have exactly 1 parameter but has \"</span> + parameterTypes.length);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class=\"line\">               String methodName = method.getDeclaringClass().getName() + <span class=\"string\">\".\"</span> + method.getName();</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(methodName +</span><br><span class=\"line\">                       <span class=\"string\">\" is a illegal @Subscribe method: must be public, non-static, and non-abstract\"</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面就通过反射获取到了注册类中的注解方法，然后获取注解值，在构造SubscriberMethod的时候就传入了threadMode，然后在Post的时候，会根据不同的类型去进行不同的处理：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postToSubscription</span><span class=\"params\">(Subscription subscription, Object event, <span class=\"keyword\">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> POSTING:</span><br><span class=\"line\">               invokeSubscriber(subscription, event);</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> MAIN:</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">                   invokeSubscriber(subscription, event);</span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                   mainThreadPoster.enqueue(subscription, event);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> BACKGROUND:</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (isMainThread) &#123;</span><br><span class=\"line\">                   backgroundPoster.enqueue(subscription, event);</span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                   invokeSubscriber(subscription, event);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">case</span> ASYNC:</span><br><span class=\"line\">               asyncPoster.enqueue(subscription, event);</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unknown thread mode: \"</span> + subscription.subscriberMethod.threadMode);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>根据不同的类型会有不同的Poster去在对应线程操作<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HandlerPoster mainThreadPoster;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BackgroundPoster backgroundPoster;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncPoster asyncPoster;</span><br></pre></td></tr></table></figure></p>\n<p>以上就是运行期注解在EventBus中的一些应用以及简单的理解。</p>\n<p>我们自己操作的时候，也可以通过同样的方式，先声明一个运行期注解，然后在需要操作的地方反射的获取到被注解的元素，进行需要的操作。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>至此注解的文章就写完了，可以看到原理其实比较简单。而我们学习这个的目的，一方面是更好的去理解各种流行框架的原理以及设计思路，在面对一些重复的代码工作中可以变得更加高效，也是给自己的思维一个拓展，在面对项目的设计问题时，有一个武器可以使用，也可以更好的去理解各种解耦的思想。</p>"},{"title":"Android在应用退出后发送请求解决方案","date":"2017-03-15T09:07:44.000Z","_content":"  最近有这么一个需求，在app退出登录之后发送请求到后台，这个请求不是特别重要，只是为了应用过审。所以在常规情况下能够发送请求即可，下面方案不保证能够在所有情况下应用退出都能发送请求。\n### 常规退出场景\n常规情况下应用退出有这么几种情况：\n1.app内退出按钮或者双击返回；\n2.最近应用列表，划掉应用卡片（常见）；\n3.应用崩溃；\n我们一个个来分析解决。\n<!-- more -->\n### 解决方案\n#### 对于app内部退出\n这个是我们可控的。但是用户在退出时发请求需要考虑到网络情况，肯定不可能等到请求成功才退出应用。而我们app退出是有下面的操作：\n\n```java\n\t//系统退出 清空所有缓存 取消所有请求\n\tUenUtils.cleanAppConfigWhenExit();\n\tMyApplication.cancelAllPostRequests();\n\tActivityStack.popAll();\n```\n\n最后一步内其实是杀掉了当前进程\n\n```java\n\tandroid.os.Process.killProcess(android.os.Process.myPid());\n```\n\n因为这一步应用是被杀掉的，肯定是不能在这里做发请求操作，只能开启service来帮我们完成操作。\n具体的实现方案就是，在应用启动时startService，这是一个远端的service\n\n```java\n    <service\n    \tandroid:name=\".service.MyService\"\n    \tandroid:process=\":remote\"\n    \tandroid:enabled=\"true\">\n    \t<intent-filter>\n    \t\t<category android:name=\"android.intent.category.DEFAULT\" />\n    \t\t<action android:name=\"MyService\" />\n    \t</intent-filter>\n    </service>\n```\n\n然后我们在应用退出的时候，发送一个广播（因为这个进程间的通信很简单，所以就用这种比较方便的方式），service中处理广播，处理完成后销毁自己，思路就是这样。关键部分代码如下：\nactivity:\n```java\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        Intent intent = new Intent();\n        intent.setAction(\"test\");\n        sendBroadcast(intent);\n        android.os.Process.killProcess(android.os.Process.myPid());\n        return super.onKeyDown(keyCode, event);\n    }\n```\n\nservice：\n```java\n    @Override\n    public void onCreate() {\n        Log.i(TAG, \"onCreate \");\n        super.onCreate();\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(\"test\");\n        registerReceiver(receiver, filter);\n    }\n\t\n    BroadcastReceiver receiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (\"test\".equals(intent.getAction())){\n                Log.e(TAG, \"onReceive\");\n                /**发请求*/\n                ....\n                /**请求成功后解绑 */\n                unregisterReceiver(receiver);\n                android.os.Process.killProcess(android.os.Process.myPid());\n            }\n        }\n    };\n```\n\n#### 对于在任务列表划掉应用\n查了一些资料之后发现Service中有一个回调方法\n```java\n    @Override\n    public void onTaskRemoved(Intent rootIntent) {\n\n    }\n```\n官方文档解释如下，大意就是如果这个service在运行并且用户移除了这个任务，会回调这个方法，但是如果你设置了FLAG_STOP_WITH_TASK这个属性，你将不会接收到这个回调，并且service会直接停止。\n\n![enter image description here](http://7xrxl6.com1.z0.glb.clouddn.com/develop_ontask1.png)\n提到了FLAG_STOP_WITH_TASK这个属性，我们来看看这是什么：\n![enter image description here](http://7xrxl6.com1.z0.glb.clouddn.com/develop_ontask2.png)\n如果设置了该属性，用户删除了基于某个应用程序的任务，系统将自动停止该服务，然后这个是通过stopWithTask属性来控制的。\n所以我们在service中配置，添加一行\n\n```java\n    android:stopWithTask=\"true\"\n```\n\n然后我们测试一下，启动服务后从任务列表移除应用，方法确实被回调。我们可以在这个方法内发送请求，不过需要注意的是，我测试的机器上，移除应用后方法回调然后service就挂掉了，1s左右service又重启了，走了onCreate、onStartCommand回调。我是直接在回调方法里写请求，这样会出现接收不到请求的返回的情况。所以我建议的方式是，在回调方法里写一个SharedPreferences，然后再重新创建的时候再去通过读取这个值来发送请求。具体实现代码如下：\n```java\n    // 配置文件\n    private static SharedPreferences g_settings = null;\n    private static SharedPreferences.Editor g_editor = null;\n    \n    @Override\n    public void onCreate() {\n        super.onCreate();\n        g_settings = getSharedPreferences(\"ps\", Context.MODE_APPEND);\n        test = g_settings.getBoolean(\"test\", false);\n        Log.i(TAG, \"onCreate \" + test);\n        if (test){\n            g_editor.putBoolean(\"test\", false);\n            g_editor.commit();\n\t\t\t/**发请求 然后销毁service*/\n\t\t\t...\n        }\n        g_editor = g_settings.edit();\n    }\n    \n    @Override\n    public void onTaskRemoved(Intent rootIntent) {\n        Log.e(TAG, \"onTaskRemoved\");\n        g_editor.putBoolean(\"test\", true);\n        g_editor.commit();\n        super.onTaskRemoved(rootIntent);\n    }\n```\n\n#### 对于异常崩溃的情况\n可以在application中实现UncaughtExceptionHandler，然后在回调方法中发送广播，思路跟上面的差不多。\n具体的实现就是这些，只写了重要部分的代码，其他的也都很简单就不贴出来了。\n\n","source":"_posts/Android在应用退出后发送请求解决方案.md","raw":"---\ntitle: Android在应用退出后发送请求解决方案\ndate: 2017-03-15 17:07:44\ncategories: Android文章\ntags: Android, 应用退出\n---\n  最近有这么一个需求，在app退出登录之后发送请求到后台，这个请求不是特别重要，只是为了应用过审。所以在常规情况下能够发送请求即可，下面方案不保证能够在所有情况下应用退出都能发送请求。\n### 常规退出场景\n常规情况下应用退出有这么几种情况：\n1.app内退出按钮或者双击返回；\n2.最近应用列表，划掉应用卡片（常见）；\n3.应用崩溃；\n我们一个个来分析解决。\n<!-- more -->\n### 解决方案\n#### 对于app内部退出\n这个是我们可控的。但是用户在退出时发请求需要考虑到网络情况，肯定不可能等到请求成功才退出应用。而我们app退出是有下面的操作：\n\n```java\n\t//系统退出 清空所有缓存 取消所有请求\n\tUenUtils.cleanAppConfigWhenExit();\n\tMyApplication.cancelAllPostRequests();\n\tActivityStack.popAll();\n```\n\n最后一步内其实是杀掉了当前进程\n\n```java\n\tandroid.os.Process.killProcess(android.os.Process.myPid());\n```\n\n因为这一步应用是被杀掉的，肯定是不能在这里做发请求操作，只能开启service来帮我们完成操作。\n具体的实现方案就是，在应用启动时startService，这是一个远端的service\n\n```java\n    <service\n    \tandroid:name=\".service.MyService\"\n    \tandroid:process=\":remote\"\n    \tandroid:enabled=\"true\">\n    \t<intent-filter>\n    \t\t<category android:name=\"android.intent.category.DEFAULT\" />\n    \t\t<action android:name=\"MyService\" />\n    \t</intent-filter>\n    </service>\n```\n\n然后我们在应用退出的时候，发送一个广播（因为这个进程间的通信很简单，所以就用这种比较方便的方式），service中处理广播，处理完成后销毁自己，思路就是这样。关键部分代码如下：\nactivity:\n```java\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        Intent intent = new Intent();\n        intent.setAction(\"test\");\n        sendBroadcast(intent);\n        android.os.Process.killProcess(android.os.Process.myPid());\n        return super.onKeyDown(keyCode, event);\n    }\n```\n\nservice：\n```java\n    @Override\n    public void onCreate() {\n        Log.i(TAG, \"onCreate \");\n        super.onCreate();\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(\"test\");\n        registerReceiver(receiver, filter);\n    }\n\t\n    BroadcastReceiver receiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (\"test\".equals(intent.getAction())){\n                Log.e(TAG, \"onReceive\");\n                /**发请求*/\n                ....\n                /**请求成功后解绑 */\n                unregisterReceiver(receiver);\n                android.os.Process.killProcess(android.os.Process.myPid());\n            }\n        }\n    };\n```\n\n#### 对于在任务列表划掉应用\n查了一些资料之后发现Service中有一个回调方法\n```java\n    @Override\n    public void onTaskRemoved(Intent rootIntent) {\n\n    }\n```\n官方文档解释如下，大意就是如果这个service在运行并且用户移除了这个任务，会回调这个方法，但是如果你设置了FLAG_STOP_WITH_TASK这个属性，你将不会接收到这个回调，并且service会直接停止。\n\n![enter image description here](http://7xrxl6.com1.z0.glb.clouddn.com/develop_ontask1.png)\n提到了FLAG_STOP_WITH_TASK这个属性，我们来看看这是什么：\n![enter image description here](http://7xrxl6.com1.z0.glb.clouddn.com/develop_ontask2.png)\n如果设置了该属性，用户删除了基于某个应用程序的任务，系统将自动停止该服务，然后这个是通过stopWithTask属性来控制的。\n所以我们在service中配置，添加一行\n\n```java\n    android:stopWithTask=\"true\"\n```\n\n然后我们测试一下，启动服务后从任务列表移除应用，方法确实被回调。我们可以在这个方法内发送请求，不过需要注意的是，我测试的机器上，移除应用后方法回调然后service就挂掉了，1s左右service又重启了，走了onCreate、onStartCommand回调。我是直接在回调方法里写请求，这样会出现接收不到请求的返回的情况。所以我建议的方式是，在回调方法里写一个SharedPreferences，然后再重新创建的时候再去通过读取这个值来发送请求。具体实现代码如下：\n```java\n    // 配置文件\n    private static SharedPreferences g_settings = null;\n    private static SharedPreferences.Editor g_editor = null;\n    \n    @Override\n    public void onCreate() {\n        super.onCreate();\n        g_settings = getSharedPreferences(\"ps\", Context.MODE_APPEND);\n        test = g_settings.getBoolean(\"test\", false);\n        Log.i(TAG, \"onCreate \" + test);\n        if (test){\n            g_editor.putBoolean(\"test\", false);\n            g_editor.commit();\n\t\t\t/**发请求 然后销毁service*/\n\t\t\t...\n        }\n        g_editor = g_settings.edit();\n    }\n    \n    @Override\n    public void onTaskRemoved(Intent rootIntent) {\n        Log.e(TAG, \"onTaskRemoved\");\n        g_editor.putBoolean(\"test\", true);\n        g_editor.commit();\n        super.onTaskRemoved(rootIntent);\n    }\n```\n\n#### 对于异常崩溃的情况\n可以在application中实现UncaughtExceptionHandler，然后在回调方法中发送广播，思路跟上面的差不多。\n具体的实现就是这些，只写了重要部分的代码，其他的也都很简单就不贴出来了。\n\n","slug":"Android在应用退出后发送请求解决方案","published":1,"updated":"2017-05-24T09:04:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw7fkx6000dgcl913pccavx","content":"<p>  最近有这么一个需求，在app退出登录之后发送请求到后台，这个请求不是特别重要，只是为了应用过审。所以在常规情况下能够发送请求即可，下面方案不保证能够在所有情况下应用退出都能发送请求。</p>\n<h3 id=\"常规退出场景\"><a href=\"#常规退出场景\" class=\"headerlink\" title=\"常规退出场景\"></a>常规退出场景</h3><p>常规情况下应用退出有这么几种情况：<br>1.app内退出按钮或者双击返回；<br>2.最近应用列表，划掉应用卡片（常见）；<br>3.应用崩溃；<br>我们一个个来分析解决。<br><a id=\"more\"></a></p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><h4 id=\"对于app内部退出\"><a href=\"#对于app内部退出\" class=\"headerlink\" title=\"对于app内部退出\"></a>对于app内部退出</h4><p>这个是我们可控的。但是用户在退出时发请求需要考虑到网络情况，肯定不可能等到请求成功才退出应用。而我们app退出是有下面的操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//系统退出 清空所有缓存 取消所有请求</span></span><br><span class=\"line\">UenUtils.cleanAppConfigWhenExit();</span><br><span class=\"line\">MyApplication.cancelAllPostRequests();</span><br><span class=\"line\">ActivityStack.popAll();</span><br></pre></td></tr></table></figure>\n<p>最后一步内其实是杀掉了当前进程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android.os.Process.killProcess(android.os.Process.myPid());</span><br></pre></td></tr></table></figure>\n<p>因为这一步应用是被杀掉的，肯定是不能在这里做发请求操作，只能开启service来帮我们完成操作。<br>具体的实现方案就是，在应用启动时startService，这是一个远端的service</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;service</span><br><span class=\"line\">\tandroid:name=<span class=\"string\">\".service.MyService\"</span></span><br><span class=\"line\">\tandroid:process=<span class=\"string\">\":remote\"</span></span><br><span class=\"line\">\tandroid:enabled=<span class=\"string\">\"true\"</span>&gt;</span><br><span class=\"line\">\t&lt;intent-filter&gt;</span><br><span class=\"line\">\t\t&lt;category android:name=<span class=\"string\">\"android.intent.category.DEFAULT\"</span> /&gt;</span><br><span class=\"line\">\t\t&lt;action android:name=<span class=\"string\">\"MyService\"</span> /&gt;</span><br><span class=\"line\">\t&lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/service&gt;</span><br></pre></td></tr></table></figure>\n<p>然后我们在应用退出的时候，发送一个广播（因为这个进程间的通信很简单，所以就用这种比较方便的方式），service中处理广播，处理完成后销毁自己，思路就是这样。关键部分代码如下：<br>activity:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onKeyDown</span><span class=\"params\">(<span class=\"keyword\">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class=\"line\">    Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">    intent.setAction(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">    sendBroadcast(intent);</span><br><span class=\"line\">    android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onKeyDown(keyCode, event);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>service：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Log.i(TAG, <span class=\"string\">\"onCreate \"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">    IntentFilter filter = <span class=\"keyword\">new</span> IntentFilter();</span><br><span class=\"line\">    filter.addAction(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">    registerReceiver(receiver, filter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">BroadcastReceiver receiver = <span class=\"keyword\">new</span> BroadcastReceiver() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"test\"</span>.equals(intent.getAction()))&#123;</span><br><span class=\"line\">            Log.e(TAG, <span class=\"string\">\"onReceive\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">/**发请求*/</span></span><br><span class=\"line\">            ....</span><br><span class=\"line\">            <span class=\"comment\">/**请求成功后解绑 */</span></span><br><span class=\"line\">            unregisterReceiver(receiver);</span><br><span class=\"line\">            android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"对于在任务列表划掉应用\"><a href=\"#对于在任务列表划掉应用\" class=\"headerlink\" title=\"对于在任务列表划掉应用\"></a>对于在任务列表划掉应用</h4><p>查了一些资料之后发现Service中有一个回调方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onTaskRemoved</span><span class=\"params\">(Intent rootIntent)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>官方文档解释如下，大意就是如果这个service在运行并且用户移除了这个任务，会回调这个方法，但是如果你设置了FLAG_STOP_WITH_TASK这个属性，你将不会接收到这个回调，并且service会直接停止。</p>\n<p><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/develop_ontask1.png\" alt=\"enter image description here\"><br>提到了FLAG_STOP_WITH_TASK这个属性，我们来看看这是什么：<br><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/develop_ontask2.png\" alt=\"enter image description here\"><br>如果设置了该属性，用户删除了基于某个应用程序的任务，系统将自动停止该服务，然后这个是通过stopWithTask属性来控制的。<br>所以我们在service中配置，添加一行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:stopWithTask=<span class=\"string\">\"true\"</span></span><br></pre></td></tr></table></figure>\n<p>然后我们测试一下，启动服务后从任务列表移除应用，方法确实被回调。我们可以在这个方法内发送请求，不过需要注意的是，我测试的机器上，移除应用后方法回调然后service就挂掉了，1s左右service又重启了，走了onCreate、onStartCommand回调。我是直接在回调方法里写请求，这样会出现接收不到请求的返回的情况。所以我建议的方式是，在回调方法里写一个SharedPreferences，然后再重新创建的时候再去通过读取这个值来发送请求。具体实现代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 配置文件</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SharedPreferences g_settings = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SharedPreferences.Editor g_editor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">     g_settings = getSharedPreferences(<span class=\"string\">\"ps\"</span>, Context.MODE_APPEND);</span><br><span class=\"line\">     test = g_settings.getBoolean(<span class=\"string\">\"test\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">     Log.i(TAG, <span class=\"string\">\"onCreate \"</span> + test);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (test)&#123;</span><br><span class=\"line\">         g_editor.putBoolean(<span class=\"string\">\"test\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">         g_editor.commit();</span><br><span class=\"line\"><span class=\"comment\">/**发请求 然后销毁service*/</span></span><br><span class=\"line\">...</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     g_editor = g_settings.edit();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onTaskRemoved</span><span class=\"params\">(Intent rootIntent)</span> </span>&#123;</span><br><span class=\"line\">     Log.e(TAG, <span class=\"string\">\"onTaskRemoved\"</span>);</span><br><span class=\"line\">     g_editor.putBoolean(<span class=\"string\">\"test\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">     g_editor.commit();</span><br><span class=\"line\">     <span class=\"keyword\">super</span>.onTaskRemoved(rootIntent);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"对于异常崩溃的情况\"><a href=\"#对于异常崩溃的情况\" class=\"headerlink\" title=\"对于异常崩溃的情况\"></a>对于异常崩溃的情况</h4><p>可以在application中实现UncaughtExceptionHandler，然后在回调方法中发送广播，思路跟上面的差不多。<br>具体的实现就是这些，只写了重要部分的代码，其他的也都很简单就不贴出来了。</p>\n","site":{"data":{}},"excerpt":"<p>  最近有这么一个需求，在app退出登录之后发送请求到后台，这个请求不是特别重要，只是为了应用过审。所以在常规情况下能够发送请求即可，下面方案不保证能够在所有情况下应用退出都能发送请求。</p>\n<h3 id=\"常规退出场景\"><a href=\"#常规退出场景\" class=\"headerlink\" title=\"常规退出场景\"></a>常规退出场景</h3><p>常规情况下应用退出有这么几种情况：<br>1.app内退出按钮或者双击返回；<br>2.最近应用列表，划掉应用卡片（常见）；<br>3.应用崩溃；<br>我们一个个来分析解决。<br>","more":"</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><h4 id=\"对于app内部退出\"><a href=\"#对于app内部退出\" class=\"headerlink\" title=\"对于app内部退出\"></a>对于app内部退出</h4><p>这个是我们可控的。但是用户在退出时发请求需要考虑到网络情况，肯定不可能等到请求成功才退出应用。而我们app退出是有下面的操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//系统退出 清空所有缓存 取消所有请求</span></span><br><span class=\"line\">UenUtils.cleanAppConfigWhenExit();</span><br><span class=\"line\">MyApplication.cancelAllPostRequests();</span><br><span class=\"line\">ActivityStack.popAll();</span><br></pre></td></tr></table></figure>\n<p>最后一步内其实是杀掉了当前进程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android.os.Process.killProcess(android.os.Process.myPid());</span><br></pre></td></tr></table></figure>\n<p>因为这一步应用是被杀掉的，肯定是不能在这里做发请求操作，只能开启service来帮我们完成操作。<br>具体的实现方案就是，在应用启动时startService，这是一个远端的service</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;service</span><br><span class=\"line\">\tandroid:name=<span class=\"string\">\".service.MyService\"</span></span><br><span class=\"line\">\tandroid:process=<span class=\"string\">\":remote\"</span></span><br><span class=\"line\">\tandroid:enabled=<span class=\"string\">\"true\"</span>&gt;</span><br><span class=\"line\">\t&lt;intent-filter&gt;</span><br><span class=\"line\">\t\t&lt;category android:name=<span class=\"string\">\"android.intent.category.DEFAULT\"</span> /&gt;</span><br><span class=\"line\">\t\t&lt;action android:name=<span class=\"string\">\"MyService\"</span> /&gt;</span><br><span class=\"line\">\t&lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/service&gt;</span><br></pre></td></tr></table></figure>\n<p>然后我们在应用退出的时候，发送一个广播（因为这个进程间的通信很简单，所以就用这种比较方便的方式），service中处理广播，处理完成后销毁自己，思路就是这样。关键部分代码如下：<br>activity:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onKeyDown</span><span class=\"params\">(<span class=\"keyword\">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class=\"line\">    Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">    intent.setAction(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">    sendBroadcast(intent);</span><br><span class=\"line\">    android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onKeyDown(keyCode, event);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>service：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Log.i(TAG, <span class=\"string\">\"onCreate \"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">    IntentFilter filter = <span class=\"keyword\">new</span> IntentFilter();</span><br><span class=\"line\">    filter.addAction(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">    registerReceiver(receiver, filter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">BroadcastReceiver receiver = <span class=\"keyword\">new</span> BroadcastReceiver() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"test\"</span>.equals(intent.getAction()))&#123;</span><br><span class=\"line\">            Log.e(TAG, <span class=\"string\">\"onReceive\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">/**发请求*/</span></span><br><span class=\"line\">            ....</span><br><span class=\"line\">            <span class=\"comment\">/**请求成功后解绑 */</span></span><br><span class=\"line\">            unregisterReceiver(receiver);</span><br><span class=\"line\">            android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"对于在任务列表划掉应用\"><a href=\"#对于在任务列表划掉应用\" class=\"headerlink\" title=\"对于在任务列表划掉应用\"></a>对于在任务列表划掉应用</h4><p>查了一些资料之后发现Service中有一个回调方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onTaskRemoved</span><span class=\"params\">(Intent rootIntent)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>官方文档解释如下，大意就是如果这个service在运行并且用户移除了这个任务，会回调这个方法，但是如果你设置了FLAG_STOP_WITH_TASK这个属性，你将不会接收到这个回调，并且service会直接停止。</p>\n<p><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/develop_ontask1.png\" alt=\"enter image description here\"><br>提到了FLAG_STOP_WITH_TASK这个属性，我们来看看这是什么：<br><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/develop_ontask2.png\" alt=\"enter image description here\"><br>如果设置了该属性，用户删除了基于某个应用程序的任务，系统将自动停止该服务，然后这个是通过stopWithTask属性来控制的。<br>所以我们在service中配置，添加一行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:stopWithTask=<span class=\"string\">\"true\"</span></span><br></pre></td></tr></table></figure>\n<p>然后我们测试一下，启动服务后从任务列表移除应用，方法确实被回调。我们可以在这个方法内发送请求，不过需要注意的是，我测试的机器上，移除应用后方法回调然后service就挂掉了，1s左右service又重启了，走了onCreate、onStartCommand回调。我是直接在回调方法里写请求，这样会出现接收不到请求的返回的情况。所以我建议的方式是，在回调方法里写一个SharedPreferences，然后再重新创建的时候再去通过读取这个值来发送请求。具体实现代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 配置文件</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SharedPreferences g_settings = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SharedPreferences.Editor g_editor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">     g_settings = getSharedPreferences(<span class=\"string\">\"ps\"</span>, Context.MODE_APPEND);</span><br><span class=\"line\">     test = g_settings.getBoolean(<span class=\"string\">\"test\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">     Log.i(TAG, <span class=\"string\">\"onCreate \"</span> + test);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (test)&#123;</span><br><span class=\"line\">         g_editor.putBoolean(<span class=\"string\">\"test\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">         g_editor.commit();</span><br><span class=\"line\"><span class=\"comment\">/**发请求 然后销毁service*/</span></span><br><span class=\"line\">...</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     g_editor = g_settings.edit();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onTaskRemoved</span><span class=\"params\">(Intent rootIntent)</span> </span>&#123;</span><br><span class=\"line\">     Log.e(TAG, <span class=\"string\">\"onTaskRemoved\"</span>);</span><br><span class=\"line\">     g_editor.putBoolean(<span class=\"string\">\"test\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">     g_editor.commit();</span><br><span class=\"line\">     <span class=\"keyword\">super</span>.onTaskRemoved(rootIntent);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"对于异常崩溃的情况\"><a href=\"#对于异常崩溃的情况\" class=\"headerlink\" title=\"对于异常崩溃的情况\"></a>对于异常崩溃的情况</h4><p>可以在application中实现UncaughtExceptionHandler，然后在回调方法中发送广播，思路跟上面的差不多。<br>具体的实现就是这些，只写了重要部分的代码，其他的也都很简单就不贴出来了。</p>"},{"title":"Dagger2 从生成的代码看原理","date":"2017-04-23T23:33:44.000Z","_content":"接着之前的注解，正好最近有时间，对去年大热的开源库[Dagger](https://github.com/google/dagger)做一个分析。\n首先举一个最基础的MVP模式的例子，通过使用注解\n\n<!-- more -->\n\n首先我们从调用的入口看\n```java\nDaggerMainComponent.builder().mainMoudle(new MainMoudle(this)).build().inject(this);\n```\n点进去我们可以看到DaggerMainComponent是实现的MainComponent接口，MainComponent就是我们添加了@Component注解的接口。所以我们可以推断一下，添加了@Component注解的接口，dagger会帮我们生成一个实现类。\n\n然后看看builder方法，这个方法是直接返回了一个new的Builder对象。\n```java\n  public static Builder builder() {\n    return new Builder();\n  }\n```\n然后看看Builder对象是干嘛的。\n\n```java\n  public static final class Builder {\n    private MainMoudle mainMoudle;\n\n    private Builder() {}\n\n    public MainComponent build() {\n      if (mainMoudle == null) {\n        throw new IllegalStateException(MainMoudle.class.getCanonicalName() + \" must be set\");\n      }\n      return new DaggerMainComponent(this);\n    }\n\n    public Builder mainMoudle(MainMoudle mainMoudle) {\n      this.mainMoudle = Preconditions.checkNotNull(mainMoudle);\n      return this;\n    }\n  }\n```\n可以看到，这个Builder类中有一个MainMoudle对象，还有一个mainMoudle提供给我们来注入对象，然后就是一个build方法返回一个DaggerMainComponent对象。\n接上面的说，添加了@Component注解的接口，dagger在生成Builder类时，会生成一个module对象，这个对象就是我们在注解中添加的参数，然后会生成一个方法供我们注入对象。\n从我们调用入口来看，先调用builder方法创建一个Builder对象，然后注入一个MainModule对象，再调用build方法，创建DaggerMainComponent对象。\n我们看看build方法，实际是调用了DaggerMainComponent的构造方法，调用的initialize方法：\n```java\n  private void initialize(final Builder builder) {\n\n    this.provideViewProvider = MainMoudle_ProvideViewFactory.create(builder.mainMoudle);\n\n    this.mainPresenterProvider = MainPresenter_Factory.create(provideViewProvider);\n\n    this.mainActivityMembersInjector = MainActivity_MembersInjector.create(mainPresenterProvider);\n  }\n```\n就三行代码，在分析这三行代码之前我们先想一想，实例化Activity中的presenter的步骤，首先我们需要：获取view→提供view给presenter→在Activity中注入presenter对象。\n有了这个思路，我们再来看看这三行代码。MainMoudle_ProvideViewFactory实现了Factory接口，Factory集成的Provider接口，Provider中有一个get方法（这点不展开说，暂时还不懂）。\nMainMoudle_ProvideViewFactory类主要就是提供了一个get方法，get方法是通过module的provideView方法来提供view对象。provideView就是我们之前在MainMoudle类中添加了@Provides注解的方法。\n然后我们返回的Factory对象会传递给MainPresenter_Factory，MainPresenter_Factory也只是保留这个对象的引用，然后在需要get方法的时候通过这个对象提供的view去实例化MainPresenter。\n然后MainPresenter_Factory会传递给MainActivity_MembersInjector的create方法，MainActivity_MembersInjector类实现了MembersInjector接口，MembersInjector接口有一个injectMembers方法。\n```java\n  @Override\n  public void injectMembers(MainActivity instance) {\n    if (instance == null) {\n      throw new NullPointerException(\"Cannot inject members into a null reference\");\n    }\n    instance.presenter = presenterProvider.get();\n  }\n```\n现在我们回头再看看我们在Activity中调用的inject方法，这个方法实际上调用的就是上面说的injectMembers方法，传入了MainActivity实例，然后直接对presenter进行赋值。而这个presenter就是我们在Activity中添加的注解。\n```java\n    @Inject\n    MainPresenter presenter;\n```\n至此一个完整的注入流程就完了，写的比较凌乱，现在梳理一下整个思路。\n首先，我们的目的是@Inject注解对MainActivity中的presenter进行注入，我们的入口是从@Component注解开始，通过这个入口去生成Component类，@Component注解中又提供了参数module，Module类中又有一个@Provides注解这个方法提供了一个View对象。在Presenter中有一个@Inject注解的方法，Moudle中provide的view对象就被注入到presenter中，presenter实例化后又被注入到Activity，这就完成了这个demo的整个注解流程。\n我们的分析是顺着生成的代码，一步步查看生成代码来分析流程的，这样能弄懂对象是如何注解的，但是没法了解dagger框架的原理。\n我们现在从刚刚分析的流程中进行倒推，我们做的事情只是在几个需要的地方进行注解。通过这几个注解如何生成这些代码？dagger中肯定有一个存放所有注解、分析所有注解的一个关系图。\n","source":"_posts/Dagger2 从生成的代码看原理.md","raw":"---\ntitle: Dagger2 从生成的代码看原理\ndate: 2017-04-24 07:33:44\ncategories: Android日常问题\ntags: Android, 开源库, Dagger\n---\n接着之前的注解，正好最近有时间，对去年大热的开源库[Dagger](https://github.com/google/dagger)做一个分析。\n首先举一个最基础的MVP模式的例子，通过使用注解\n\n<!-- more -->\n\n首先我们从调用的入口看\n```java\nDaggerMainComponent.builder().mainMoudle(new MainMoudle(this)).build().inject(this);\n```\n点进去我们可以看到DaggerMainComponent是实现的MainComponent接口，MainComponent就是我们添加了@Component注解的接口。所以我们可以推断一下，添加了@Component注解的接口，dagger会帮我们生成一个实现类。\n\n然后看看builder方法，这个方法是直接返回了一个new的Builder对象。\n```java\n  public static Builder builder() {\n    return new Builder();\n  }\n```\n然后看看Builder对象是干嘛的。\n\n```java\n  public static final class Builder {\n    private MainMoudle mainMoudle;\n\n    private Builder() {}\n\n    public MainComponent build() {\n      if (mainMoudle == null) {\n        throw new IllegalStateException(MainMoudle.class.getCanonicalName() + \" must be set\");\n      }\n      return new DaggerMainComponent(this);\n    }\n\n    public Builder mainMoudle(MainMoudle mainMoudle) {\n      this.mainMoudle = Preconditions.checkNotNull(mainMoudle);\n      return this;\n    }\n  }\n```\n可以看到，这个Builder类中有一个MainMoudle对象，还有一个mainMoudle提供给我们来注入对象，然后就是一个build方法返回一个DaggerMainComponent对象。\n接上面的说，添加了@Component注解的接口，dagger在生成Builder类时，会生成一个module对象，这个对象就是我们在注解中添加的参数，然后会生成一个方法供我们注入对象。\n从我们调用入口来看，先调用builder方法创建一个Builder对象，然后注入一个MainModule对象，再调用build方法，创建DaggerMainComponent对象。\n我们看看build方法，实际是调用了DaggerMainComponent的构造方法，调用的initialize方法：\n```java\n  private void initialize(final Builder builder) {\n\n    this.provideViewProvider = MainMoudle_ProvideViewFactory.create(builder.mainMoudle);\n\n    this.mainPresenterProvider = MainPresenter_Factory.create(provideViewProvider);\n\n    this.mainActivityMembersInjector = MainActivity_MembersInjector.create(mainPresenterProvider);\n  }\n```\n就三行代码，在分析这三行代码之前我们先想一想，实例化Activity中的presenter的步骤，首先我们需要：获取view→提供view给presenter→在Activity中注入presenter对象。\n有了这个思路，我们再来看看这三行代码。MainMoudle_ProvideViewFactory实现了Factory接口，Factory集成的Provider接口，Provider中有一个get方法（这点不展开说，暂时还不懂）。\nMainMoudle_ProvideViewFactory类主要就是提供了一个get方法，get方法是通过module的provideView方法来提供view对象。provideView就是我们之前在MainMoudle类中添加了@Provides注解的方法。\n然后我们返回的Factory对象会传递给MainPresenter_Factory，MainPresenter_Factory也只是保留这个对象的引用，然后在需要get方法的时候通过这个对象提供的view去实例化MainPresenter。\n然后MainPresenter_Factory会传递给MainActivity_MembersInjector的create方法，MainActivity_MembersInjector类实现了MembersInjector接口，MembersInjector接口有一个injectMembers方法。\n```java\n  @Override\n  public void injectMembers(MainActivity instance) {\n    if (instance == null) {\n      throw new NullPointerException(\"Cannot inject members into a null reference\");\n    }\n    instance.presenter = presenterProvider.get();\n  }\n```\n现在我们回头再看看我们在Activity中调用的inject方法，这个方法实际上调用的就是上面说的injectMembers方法，传入了MainActivity实例，然后直接对presenter进行赋值。而这个presenter就是我们在Activity中添加的注解。\n```java\n    @Inject\n    MainPresenter presenter;\n```\n至此一个完整的注入流程就完了，写的比较凌乱，现在梳理一下整个思路。\n首先，我们的目的是@Inject注解对MainActivity中的presenter进行注入，我们的入口是从@Component注解开始，通过这个入口去生成Component类，@Component注解中又提供了参数module，Module类中又有一个@Provides注解这个方法提供了一个View对象。在Presenter中有一个@Inject注解的方法，Moudle中provide的view对象就被注入到presenter中，presenter实例化后又被注入到Activity，这就完成了这个demo的整个注解流程。\n我们的分析是顺着生成的代码，一步步查看生成代码来分析流程的，这样能弄懂对象是如何注解的，但是没法了解dagger框架的原理。\n我们现在从刚刚分析的流程中进行倒推，我们做的事情只是在几个需要的地方进行注解。通过这几个注解如何生成这些代码？dagger中肯定有一个存放所有注解、分析所有注解的一个关系图。\n","slug":"Dagger2 从生成的代码看原理","published":1,"updated":"2017-05-24T09:04:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw7fkxb000hgcl98tepc2ra","content":"<p>接着之前的注解，正好最近有时间，对去年大热的开源库<a href=\"https://github.com/google/dagger\">Dagger</a>做一个分析。<br>首先举一个最基础的MVP模式的例子，通过使用注解</p>\n<a id=\"more\"></a>\n<p>首先我们从调用的入口看<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DaggerMainComponent.builder().mainMoudle(<span class=\"keyword\">new</span> MainMoudle(<span class=\"keyword\">this</span>)).build().inject(<span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure></p>\n<p>点进去我们可以看到DaggerMainComponent是实现的MainComponent接口，MainComponent就是我们添加了@Component注解的接口。所以我们可以推断一下，添加了@Component注解的接口，dagger会帮我们生成一个实现类。</p>\n<p>然后看看builder方法，这个方法是直接返回了一个new的Builder对象。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Builder <span class=\"title\">builder</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Builder();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后看看Builder对象是干嘛的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MainMoudle mainMoudle;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Builder</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> MainComponent <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mainMoudle == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(MainMoudle.class.getCanonicalName() + <span class=\"string\">\" must be set\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DaggerMainComponent(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">mainMoudle</span><span class=\"params\">(MainMoudle mainMoudle)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mainMoudle = Preconditions.checkNotNull(mainMoudle);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这个Builder类中有一个MainMoudle对象，还有一个mainMoudle提供给我们来注入对象，然后就是一个build方法返回一个DaggerMainComponent对象。<br>接上面的说，添加了@Component注解的接口，dagger在生成Builder类时，会生成一个module对象，这个对象就是我们在注解中添加的参数，然后会生成一个方法供我们注入对象。<br>从我们调用入口来看，先调用builder方法创建一个Builder对象，然后注入一个MainModule对象，再调用build方法，创建DaggerMainComponent对象。<br>我们看看build方法，实际是调用了DaggerMainComponent的构造方法，调用的initialize方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">(<span class=\"keyword\">final</span> Builder builder)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.provideViewProvider = MainMoudle_ProvideViewFactory.create(builder.mainMoudle);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.mainPresenterProvider = MainPresenter_Factory.create(provideViewProvider);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.mainActivityMembersInjector = MainActivity_MembersInjector.create(mainPresenterProvider);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就三行代码，在分析这三行代码之前我们先想一想，实例化Activity中的presenter的步骤，首先我们需要：获取view→提供view给presenter→在Activity中注入presenter对象。<br>有了这个思路，我们再来看看这三行代码。MainMoudle_ProvideViewFactory实现了Factory接口，Factory集成的Provider接口，Provider中有一个get方法（这点不展开说，暂时还不懂）。<br>MainMoudle_ProvideViewFactory类主要就是提供了一个get方法，get方法是通过module的provideView方法来提供view对象。provideView就是我们之前在MainMoudle类中添加了@Provides注解的方法。<br>然后我们返回的Factory对象会传递给MainPresenter_Factory，MainPresenter_Factory也只是保留这个对象的引用，然后在需要get方法的时候通过这个对象提供的view去实例化MainPresenter。<br>然后MainPresenter_Factory会传递给MainActivity_MembersInjector的create方法，MainActivity_MembersInjector类实现了MembersInjector接口，MembersInjector接口有一个injectMembers方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">injectMembers</span><span class=\"params\">(MainActivity instance)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"Cannot inject members into a null reference\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  instance.presenter = presenterProvider.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们回头再看看我们在Activity中调用的inject方法，这个方法实际上调用的就是上面说的injectMembers方法，传入了MainActivity实例，然后直接对presenter进行赋值。而这个presenter就是我们在Activity中添加的注解。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Inject</span></span><br><span class=\"line\">MainPresenter presenter;</span><br></pre></td></tr></table></figure></p>\n<p>至此一个完整的注入流程就完了，写的比较凌乱，现在梳理一下整个思路。<br>首先，我们的目的是@Inject注解对MainActivity中的presenter进行注入，我们的入口是从@Component注解开始，通过这个入口去生成Component类，@Component注解中又提供了参数module，Module类中又有一个@Provides注解这个方法提供了一个View对象。在Presenter中有一个@Inject注解的方法，Moudle中provide的view对象就被注入到presenter中，presenter实例化后又被注入到Activity，这就完成了这个demo的整个注解流程。<br>我们的分析是顺着生成的代码，一步步查看生成代码来分析流程的，这样能弄懂对象是如何注解的，但是没法了解dagger框架的原理。<br>我们现在从刚刚分析的流程中进行倒推，我们做的事情只是在几个需要的地方进行注解。通过这几个注解如何生成这些代码？dagger中肯定有一个存放所有注解、分析所有注解的一个关系图。</p>\n","site":{"data":{}},"excerpt":"<p>接着之前的注解，正好最近有时间，对去年大热的开源库<a href=\"https://github.com/google/dagger\">Dagger</a>做一个分析。<br>首先举一个最基础的MVP模式的例子，通过使用注解</p>","more":"<p>首先我们从调用的入口看<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DaggerMainComponent.builder().mainMoudle(<span class=\"keyword\">new</span> MainMoudle(<span class=\"keyword\">this</span>)).build().inject(<span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure></p>\n<p>点进去我们可以看到DaggerMainComponent是实现的MainComponent接口，MainComponent就是我们添加了@Component注解的接口。所以我们可以推断一下，添加了@Component注解的接口，dagger会帮我们生成一个实现类。</p>\n<p>然后看看builder方法，这个方法是直接返回了一个new的Builder对象。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Builder <span class=\"title\">builder</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Builder();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后看看Builder对象是干嘛的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MainMoudle mainMoudle;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Builder</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> MainComponent <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mainMoudle == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(MainMoudle.class.getCanonicalName() + <span class=\"string\">\" must be set\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DaggerMainComponent(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">mainMoudle</span><span class=\"params\">(MainMoudle mainMoudle)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mainMoudle = Preconditions.checkNotNull(mainMoudle);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这个Builder类中有一个MainMoudle对象，还有一个mainMoudle提供给我们来注入对象，然后就是一个build方法返回一个DaggerMainComponent对象。<br>接上面的说，添加了@Component注解的接口，dagger在生成Builder类时，会生成一个module对象，这个对象就是我们在注解中添加的参数，然后会生成一个方法供我们注入对象。<br>从我们调用入口来看，先调用builder方法创建一个Builder对象，然后注入一个MainModule对象，再调用build方法，创建DaggerMainComponent对象。<br>我们看看build方法，实际是调用了DaggerMainComponent的构造方法，调用的initialize方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">(<span class=\"keyword\">final</span> Builder builder)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.provideViewProvider = MainMoudle_ProvideViewFactory.create(builder.mainMoudle);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.mainPresenterProvider = MainPresenter_Factory.create(provideViewProvider);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.mainActivityMembersInjector = MainActivity_MembersInjector.create(mainPresenterProvider);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就三行代码，在分析这三行代码之前我们先想一想，实例化Activity中的presenter的步骤，首先我们需要：获取view→提供view给presenter→在Activity中注入presenter对象。<br>有了这个思路，我们再来看看这三行代码。MainMoudle_ProvideViewFactory实现了Factory接口，Factory集成的Provider接口，Provider中有一个get方法（这点不展开说，暂时还不懂）。<br>MainMoudle_ProvideViewFactory类主要就是提供了一个get方法，get方法是通过module的provideView方法来提供view对象。provideView就是我们之前在MainMoudle类中添加了@Provides注解的方法。<br>然后我们返回的Factory对象会传递给MainPresenter_Factory，MainPresenter_Factory也只是保留这个对象的引用，然后在需要get方法的时候通过这个对象提供的view去实例化MainPresenter。<br>然后MainPresenter_Factory会传递给MainActivity_MembersInjector的create方法，MainActivity_MembersInjector类实现了MembersInjector接口，MembersInjector接口有一个injectMembers方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">injectMembers</span><span class=\"params\">(MainActivity instance)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"Cannot inject members into a null reference\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  instance.presenter = presenterProvider.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们回头再看看我们在Activity中调用的inject方法，这个方法实际上调用的就是上面说的injectMembers方法，传入了MainActivity实例，然后直接对presenter进行赋值。而这个presenter就是我们在Activity中添加的注解。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Inject</span></span><br><span class=\"line\">MainPresenter presenter;</span><br></pre></td></tr></table></figure></p>\n<p>至此一个完整的注入流程就完了，写的比较凌乱，现在梳理一下整个思路。<br>首先，我们的目的是@Inject注解对MainActivity中的presenter进行注入，我们的入口是从@Component注解开始，通过这个入口去生成Component类，@Component注解中又提供了参数module，Module类中又有一个@Provides注解这个方法提供了一个View对象。在Presenter中有一个@Inject注解的方法，Moudle中provide的view对象就被注入到presenter中，presenter实例化后又被注入到Activity，这就完成了这个demo的整个注解流程。<br>我们的分析是顺着生成的代码，一步步查看生成代码来分析流程的，这样能弄懂对象是如何注解的，但是没法了解dagger框架的原理。<br>我们现在从刚刚分析的流程中进行倒推，我们做的事情只是在几个需要的地方进行注解。通过这几个注解如何生成这些代码？dagger中肯定有一个存放所有注解、分析所有注解的一个关系图。</p>"},{"title":"坑爹的Android 6.0 startDiscovery蓝牙搜索不到设备问题","date":"2017-03-27T12:50:44.000Z","_content":"\n最近在做重构项目的过程中，重构蓝牙扫描模块的时候。发现调用扫描方法的时候，根本没有返回搜索到的设备。开始以为是厂商sdk的bug，或者是自己新写的代码问题。然后没有用厂商sdk，自己写代码来扫描，琢磨了半天看日志，debug，依然没找到问题。后来突然想到是不是权限的问题，之前项目的targetSdkVersion 22，新的项目是23，然后Android 6.0有一套新的权限机制，敏感权限需要申请，感觉可能是权限问题导致的。\n<!-- more -->\n搜索了一下，下面是具体的权限列表\n\n#### Normal Permission\n```java\nACCESS_LOCATION_EXTRA_COMMANDS\nACCESS_NETWORK_STATE\nACCESS_NOTIFICATION_POLICY\nACCESS_WIFI_STATE\nBLUETOOTH\nBLUETOOTH_ADMIN\nBROADCAST_STICKY\nCHANGE_NETWORK_STATE\nCHANGE_WIFI_MULTICAST_STATE\nCHANGE_WIFI_STATE\nDISABLE_KEYGUARD\nEXPAND_STATUS_BAR\nGET_PACKAGE_SIZE\nINSTALL_SHORTCUT\nINTERNET\nKILL_BACKGROUND_PROCESSES\nMODIFY_AUDIO_SETTINGS\nNFC\nREAD_SYNC_SETTINGS\nREAD_SYNC_STATS\nRECEIVE_BOOT_COMPLETED\nREORDER_TASKS\nREQUEST_INSTALL_PACKAGES\nSET_ALARM\nSET_TIME_ZONE\nSET_WALLPAPER\nSET_WALLPAPER_HINTS\nTRANSMIT_IR\nUNINSTALL_SHORTCUT\nUSE_FINGERPRINT\nVIBRATE\nWAKE_LOCK\nWRITE_SYNC_SETTINGS\n```\n\n#### Dangerous Permission\n```java\ngroup:android.permission-group.CONTACTS\n  permission:android.permission.WRITE_CONTACTS\n  permission:android.permission.GET_ACCOUNTS\n  permission:android.permission.READ_CONTACTS\n\ngroup:android.permission-group.PHONE\n  permission:android.permission.READ_CALL_LOG\n  permission:android.permission.READ_PHONE_STATE\n  permission:android.permission.CALL_PHONE\n  permission:android.permission.WRITE_CALL_LOG\n  permission:android.permission.USE_SIP\n  permission:android.permission.PROCESS_OUTGOING_CALLS\n  permission:com.android.voicemail.permission.ADD_VOICEMAIL\n\ngroup:android.permission-group.CALENDAR\n  permission:android.permission.READ_CALENDAR\n  permission:android.permission.WRITE_CALENDAR\n\ngroup:android.permission-group.CAMERA\n  permission:android.permission.CAMERA\n\ngroup:android.permission-group.SENSORS\n  permission:android.permission.BODY_SENSORS\n\ngroup:android.permission-group.LOCATION\n  permission:android.permission.ACCESS_FINE_LOCATION\n  permission:android.permission.ACCESS_COARSE_LOCATION\n\ngroup:android.permission-group.STORAGE\n  permission:android.permission.READ_EXTERNAL_STORAGE\n  permission:android.permission.WRITE_EXTERNAL_STORAGE\n\ngroup:android.permission-group.MICROPHONE\n  permission:android.permission.RECORD_AUDIO\n\ngroup:android.permission-group.SMS\n  permission:android.permission.READ_SMS\n  permission:android.permission.RECEIVE_WAP_PUSH\n  permission:android.permission.RECEIVE_MMS\n  permission:android.permission.RECEIVE_SMS\n  permission:android.permission.SEND_SMS\n  permission:android.permission.READ_CELL_BROADCASTS\n```\n\n看了一下蓝牙权限不是敏感权限，应该不需要在运行时获取啊。然后查了下[官方文档](https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html#behavior-power)。\n有这么一段内容：\n![](http://7xrxl6.com1.z0.glb.clouddn.com/permission1.png)\n\n所以在通过蓝牙扫描附近外部设备时，需要获取这两个权限。\n```\nACCESS_FINE_LOCATION\nACCESS_COARSE_LOCATION\n```\n检查和申请权限可以调用这两个方法，具体如何使用可以自行搜索。\n```\ncheckSelfPermission()\nrequestPermissions()\n```\n\n处理权限的代码并不复杂，但是需要自己去封装。\n我自己是使用的一个开源库：https://github.com/lovedise/PermissionGen\n使用起来比较方便，感兴趣的可以看看。","source":"_posts/坑爹的Android 6.0 startDiscovery蓝牙搜索不到设备问题.md","raw":"---\ntitle: 坑爹的Android 6.0 startDiscovery蓝牙搜索不到设备问题\ndate: 2017-03-27 20:50:44\ncategories: Android日常问题\ntags: Android, Android权限机制\n---\n\n最近在做重构项目的过程中，重构蓝牙扫描模块的时候。发现调用扫描方法的时候，根本没有返回搜索到的设备。开始以为是厂商sdk的bug，或者是自己新写的代码问题。然后没有用厂商sdk，自己写代码来扫描，琢磨了半天看日志，debug，依然没找到问题。后来突然想到是不是权限的问题，之前项目的targetSdkVersion 22，新的项目是23，然后Android 6.0有一套新的权限机制，敏感权限需要申请，感觉可能是权限问题导致的。\n<!-- more -->\n搜索了一下，下面是具体的权限列表\n\n#### Normal Permission\n```java\nACCESS_LOCATION_EXTRA_COMMANDS\nACCESS_NETWORK_STATE\nACCESS_NOTIFICATION_POLICY\nACCESS_WIFI_STATE\nBLUETOOTH\nBLUETOOTH_ADMIN\nBROADCAST_STICKY\nCHANGE_NETWORK_STATE\nCHANGE_WIFI_MULTICAST_STATE\nCHANGE_WIFI_STATE\nDISABLE_KEYGUARD\nEXPAND_STATUS_BAR\nGET_PACKAGE_SIZE\nINSTALL_SHORTCUT\nINTERNET\nKILL_BACKGROUND_PROCESSES\nMODIFY_AUDIO_SETTINGS\nNFC\nREAD_SYNC_SETTINGS\nREAD_SYNC_STATS\nRECEIVE_BOOT_COMPLETED\nREORDER_TASKS\nREQUEST_INSTALL_PACKAGES\nSET_ALARM\nSET_TIME_ZONE\nSET_WALLPAPER\nSET_WALLPAPER_HINTS\nTRANSMIT_IR\nUNINSTALL_SHORTCUT\nUSE_FINGERPRINT\nVIBRATE\nWAKE_LOCK\nWRITE_SYNC_SETTINGS\n```\n\n#### Dangerous Permission\n```java\ngroup:android.permission-group.CONTACTS\n  permission:android.permission.WRITE_CONTACTS\n  permission:android.permission.GET_ACCOUNTS\n  permission:android.permission.READ_CONTACTS\n\ngroup:android.permission-group.PHONE\n  permission:android.permission.READ_CALL_LOG\n  permission:android.permission.READ_PHONE_STATE\n  permission:android.permission.CALL_PHONE\n  permission:android.permission.WRITE_CALL_LOG\n  permission:android.permission.USE_SIP\n  permission:android.permission.PROCESS_OUTGOING_CALLS\n  permission:com.android.voicemail.permission.ADD_VOICEMAIL\n\ngroup:android.permission-group.CALENDAR\n  permission:android.permission.READ_CALENDAR\n  permission:android.permission.WRITE_CALENDAR\n\ngroup:android.permission-group.CAMERA\n  permission:android.permission.CAMERA\n\ngroup:android.permission-group.SENSORS\n  permission:android.permission.BODY_SENSORS\n\ngroup:android.permission-group.LOCATION\n  permission:android.permission.ACCESS_FINE_LOCATION\n  permission:android.permission.ACCESS_COARSE_LOCATION\n\ngroup:android.permission-group.STORAGE\n  permission:android.permission.READ_EXTERNAL_STORAGE\n  permission:android.permission.WRITE_EXTERNAL_STORAGE\n\ngroup:android.permission-group.MICROPHONE\n  permission:android.permission.RECORD_AUDIO\n\ngroup:android.permission-group.SMS\n  permission:android.permission.READ_SMS\n  permission:android.permission.RECEIVE_WAP_PUSH\n  permission:android.permission.RECEIVE_MMS\n  permission:android.permission.RECEIVE_SMS\n  permission:android.permission.SEND_SMS\n  permission:android.permission.READ_CELL_BROADCASTS\n```\n\n看了一下蓝牙权限不是敏感权限，应该不需要在运行时获取啊。然后查了下[官方文档](https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html#behavior-power)。\n有这么一段内容：\n![](http://7xrxl6.com1.z0.glb.clouddn.com/permission1.png)\n\n所以在通过蓝牙扫描附近外部设备时，需要获取这两个权限。\n```\nACCESS_FINE_LOCATION\nACCESS_COARSE_LOCATION\n```\n检查和申请权限可以调用这两个方法，具体如何使用可以自行搜索。\n```\ncheckSelfPermission()\nrequestPermissions()\n```\n\n处理权限的代码并不复杂，但是需要自己去封装。\n我自己是使用的一个开源库：https://github.com/lovedise/PermissionGen\n使用起来比较方便，感兴趣的可以看看。","slug":"坑爹的Android 6.0 startDiscovery蓝牙搜索不到设备问题","published":1,"updated":"2017-05-24T09:04:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw7fkxf000jgcl9k33a5u5u","content":"<p>最近在做重构项目的过程中，重构蓝牙扫描模块的时候。发现调用扫描方法的时候，根本没有返回搜索到的设备。开始以为是厂商sdk的bug，或者是自己新写的代码问题。然后没有用厂商sdk，自己写代码来扫描，琢磨了半天看日志，debug，依然没找到问题。后来突然想到是不是权限的问题，之前项目的targetSdkVersion 22，新的项目是23，然后Android 6.0有一套新的权限机制，敏感权限需要申请，感觉可能是权限问题导致的。<br><a id=\"more\"></a><br>搜索了一下，下面是具体的权限列表</p>\n<h4 id=\"Normal-Permission\"><a href=\"#Normal-Permission\" class=\"headerlink\" title=\"Normal Permission\"></a>Normal Permission</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACCESS_LOCATION_EXTRA_COMMANDS</span><br><span class=\"line\">ACCESS_NETWORK_STATE</span><br><span class=\"line\">ACCESS_NOTIFICATION_POLICY</span><br><span class=\"line\">ACCESS_WIFI_STATE</span><br><span class=\"line\">BLUETOOTH</span><br><span class=\"line\">BLUETOOTH_ADMIN</span><br><span class=\"line\">BROADCAST_STICKY</span><br><span class=\"line\">CHANGE_NETWORK_STATE</span><br><span class=\"line\">CHANGE_WIFI_MULTICAST_STATE</span><br><span class=\"line\">CHANGE_WIFI_STATE</span><br><span class=\"line\">DISABLE_KEYGUARD</span><br><span class=\"line\">EXPAND_STATUS_BAR</span><br><span class=\"line\">GET_PACKAGE_SIZE</span><br><span class=\"line\">INSTALL_SHORTCUT</span><br><span class=\"line\">INTERNET</span><br><span class=\"line\">KILL_BACKGROUND_PROCESSES</span><br><span class=\"line\">MODIFY_AUDIO_SETTINGS</span><br><span class=\"line\">NFC</span><br><span class=\"line\">READ_SYNC_SETTINGS</span><br><span class=\"line\">READ_SYNC_STATS</span><br><span class=\"line\">RECEIVE_BOOT_COMPLETED</span><br><span class=\"line\">REORDER_TASKS</span><br><span class=\"line\">REQUEST_INSTALL_PACKAGES</span><br><span class=\"line\">SET_ALARM</span><br><span class=\"line\">SET_TIME_ZONE</span><br><span class=\"line\">SET_WALLPAPER</span><br><span class=\"line\">SET_WALLPAPER_HINTS</span><br><span class=\"line\">TRANSMIT_IR</span><br><span class=\"line\">UNINSTALL_SHORTCUT</span><br><span class=\"line\">USE_FINGERPRINT</span><br><span class=\"line\">VIBRATE</span><br><span class=\"line\">WAKE_LOCK</span><br><span class=\"line\">WRITE_SYNC_SETTINGS</span><br></pre></td></tr></table></figure>\n<h4 id=\"Dangerous-Permission\"><a href=\"#Dangerous-Permission\" class=\"headerlink\" title=\"Dangerous Permission\"></a>Dangerous Permission</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">group:android.permission-group.CONTACTS</span><br><span class=\"line\">  permission:android.permission.WRITE_CONTACTS</span><br><span class=\"line\">  permission:android.permission.GET_ACCOUNTS</span><br><span class=\"line\">  permission:android.permission.READ_CONTACTS</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.PHONE</span><br><span class=\"line\">  permission:android.permission.READ_CALL_LOG</span><br><span class=\"line\">  permission:android.permission.READ_PHONE_STATE</span><br><span class=\"line\">  permission:android.permission.CALL_PHONE</span><br><span class=\"line\">  permission:android.permission.WRITE_CALL_LOG</span><br><span class=\"line\">  permission:android.permission.USE_SIP</span><br><span class=\"line\">  permission:android.permission.PROCESS_OUTGOING_CALLS</span><br><span class=\"line\">  permission:com.android.voicemail.permission.ADD_VOICEMAIL</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.CALENDAR</span><br><span class=\"line\">  permission:android.permission.READ_CALENDAR</span><br><span class=\"line\">  permission:android.permission.WRITE_CALENDAR</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.CAMERA</span><br><span class=\"line\">  permission:android.permission.CAMERA</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.SENSORS</span><br><span class=\"line\">  permission:android.permission.BODY_SENSORS</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.LOCATION</span><br><span class=\"line\">  permission:android.permission.ACCESS_FINE_LOCATION</span><br><span class=\"line\">  permission:android.permission.ACCESS_COARSE_LOCATION</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.STORAGE</span><br><span class=\"line\">  permission:android.permission.READ_EXTERNAL_STORAGE</span><br><span class=\"line\">  permission:android.permission.WRITE_EXTERNAL_STORAGE</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.MICROPHONE</span><br><span class=\"line\">  permission:android.permission.RECORD_AUDIO</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.SMS</span><br><span class=\"line\">  permission:android.permission.READ_SMS</span><br><span class=\"line\">  permission:android.permission.RECEIVE_WAP_PUSH</span><br><span class=\"line\">  permission:android.permission.RECEIVE_MMS</span><br><span class=\"line\">  permission:android.permission.RECEIVE_SMS</span><br><span class=\"line\">  permission:android.permission.SEND_SMS</span><br><span class=\"line\">  permission:android.permission.READ_CELL_BROADCASTS</span><br></pre></td></tr></table></figure>\n<p>看了一下蓝牙权限不是敏感权限，应该不需要在运行时获取啊。然后查了下<a href=\"https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html#behavior-power\" target=\"_blank\" rel=\"noopener\">官方文档</a>。<br>有这么一段内容：<br><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/permission1.png\" alt=\"\"></p>\n<p>所以在通过蓝牙扫描附近外部设备时，需要获取这两个权限。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACCESS_FINE_LOCATION</span><br><span class=\"line\">ACCESS_COARSE_LOCATION</span><br></pre></td></tr></table></figure></p>\n<p>检查和申请权限可以调用这两个方法，具体如何使用可以自行搜索。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkSelfPermission()</span><br><span class=\"line\">requestPermissions()</span><br></pre></td></tr></table></figure></p>\n<p>处理权限的代码并不复杂，但是需要自己去封装。<br>我自己是使用的一个开源库：<a href=\"https://github.com/lovedise/PermissionGen\">https://github.com/lovedise/PermissionGen</a><br>使用起来比较方便，感兴趣的可以看看。</p>\n","site":{"data":{}},"excerpt":"<p>最近在做重构项目的过程中，重构蓝牙扫描模块的时候。发现调用扫描方法的时候，根本没有返回搜索到的设备。开始以为是厂商sdk的bug，或者是自己新写的代码问题。然后没有用厂商sdk，自己写代码来扫描，琢磨了半天看日志，debug，依然没找到问题。后来突然想到是不是权限的问题，之前项目的targetSdkVersion 22，新的项目是23，然后Android 6.0有一套新的权限机制，敏感权限需要申请，感觉可能是权限问题导致的。<br>","more":"<br>搜索了一下，下面是具体的权限列表</p>\n<h4 id=\"Normal-Permission\"><a href=\"#Normal-Permission\" class=\"headerlink\" title=\"Normal Permission\"></a>Normal Permission</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACCESS_LOCATION_EXTRA_COMMANDS</span><br><span class=\"line\">ACCESS_NETWORK_STATE</span><br><span class=\"line\">ACCESS_NOTIFICATION_POLICY</span><br><span class=\"line\">ACCESS_WIFI_STATE</span><br><span class=\"line\">BLUETOOTH</span><br><span class=\"line\">BLUETOOTH_ADMIN</span><br><span class=\"line\">BROADCAST_STICKY</span><br><span class=\"line\">CHANGE_NETWORK_STATE</span><br><span class=\"line\">CHANGE_WIFI_MULTICAST_STATE</span><br><span class=\"line\">CHANGE_WIFI_STATE</span><br><span class=\"line\">DISABLE_KEYGUARD</span><br><span class=\"line\">EXPAND_STATUS_BAR</span><br><span class=\"line\">GET_PACKAGE_SIZE</span><br><span class=\"line\">INSTALL_SHORTCUT</span><br><span class=\"line\">INTERNET</span><br><span class=\"line\">KILL_BACKGROUND_PROCESSES</span><br><span class=\"line\">MODIFY_AUDIO_SETTINGS</span><br><span class=\"line\">NFC</span><br><span class=\"line\">READ_SYNC_SETTINGS</span><br><span class=\"line\">READ_SYNC_STATS</span><br><span class=\"line\">RECEIVE_BOOT_COMPLETED</span><br><span class=\"line\">REORDER_TASKS</span><br><span class=\"line\">REQUEST_INSTALL_PACKAGES</span><br><span class=\"line\">SET_ALARM</span><br><span class=\"line\">SET_TIME_ZONE</span><br><span class=\"line\">SET_WALLPAPER</span><br><span class=\"line\">SET_WALLPAPER_HINTS</span><br><span class=\"line\">TRANSMIT_IR</span><br><span class=\"line\">UNINSTALL_SHORTCUT</span><br><span class=\"line\">USE_FINGERPRINT</span><br><span class=\"line\">VIBRATE</span><br><span class=\"line\">WAKE_LOCK</span><br><span class=\"line\">WRITE_SYNC_SETTINGS</span><br></pre></td></tr></table></figure>\n<h4 id=\"Dangerous-Permission\"><a href=\"#Dangerous-Permission\" class=\"headerlink\" title=\"Dangerous Permission\"></a>Dangerous Permission</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">group:android.permission-group.CONTACTS</span><br><span class=\"line\">  permission:android.permission.WRITE_CONTACTS</span><br><span class=\"line\">  permission:android.permission.GET_ACCOUNTS</span><br><span class=\"line\">  permission:android.permission.READ_CONTACTS</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.PHONE</span><br><span class=\"line\">  permission:android.permission.READ_CALL_LOG</span><br><span class=\"line\">  permission:android.permission.READ_PHONE_STATE</span><br><span class=\"line\">  permission:android.permission.CALL_PHONE</span><br><span class=\"line\">  permission:android.permission.WRITE_CALL_LOG</span><br><span class=\"line\">  permission:android.permission.USE_SIP</span><br><span class=\"line\">  permission:android.permission.PROCESS_OUTGOING_CALLS</span><br><span class=\"line\">  permission:com.android.voicemail.permission.ADD_VOICEMAIL</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.CALENDAR</span><br><span class=\"line\">  permission:android.permission.READ_CALENDAR</span><br><span class=\"line\">  permission:android.permission.WRITE_CALENDAR</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.CAMERA</span><br><span class=\"line\">  permission:android.permission.CAMERA</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.SENSORS</span><br><span class=\"line\">  permission:android.permission.BODY_SENSORS</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.LOCATION</span><br><span class=\"line\">  permission:android.permission.ACCESS_FINE_LOCATION</span><br><span class=\"line\">  permission:android.permission.ACCESS_COARSE_LOCATION</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.STORAGE</span><br><span class=\"line\">  permission:android.permission.READ_EXTERNAL_STORAGE</span><br><span class=\"line\">  permission:android.permission.WRITE_EXTERNAL_STORAGE</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.MICROPHONE</span><br><span class=\"line\">  permission:android.permission.RECORD_AUDIO</span><br><span class=\"line\"></span><br><span class=\"line\">group:android.permission-group.SMS</span><br><span class=\"line\">  permission:android.permission.READ_SMS</span><br><span class=\"line\">  permission:android.permission.RECEIVE_WAP_PUSH</span><br><span class=\"line\">  permission:android.permission.RECEIVE_MMS</span><br><span class=\"line\">  permission:android.permission.RECEIVE_SMS</span><br><span class=\"line\">  permission:android.permission.SEND_SMS</span><br><span class=\"line\">  permission:android.permission.READ_CELL_BROADCASTS</span><br></pre></td></tr></table></figure>\n<p>看了一下蓝牙权限不是敏感权限，应该不需要在运行时获取啊。然后查了下<a href=\"https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html#behavior-power\" target=\"_blank\" rel=\"noopener\">官方文档</a>。<br>有这么一段内容：<br><img src=\"http://7xrxl6.com1.z0.glb.clouddn.com/permission1.png\" alt=\"\"></p>\n<p>所以在通过蓝牙扫描附近外部设备时，需要获取这两个权限。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACCESS_FINE_LOCATION</span><br><span class=\"line\">ACCESS_COARSE_LOCATION</span><br></pre></td></tr></table></figure></p>\n<p>检查和申请权限可以调用这两个方法，具体如何使用可以自行搜索。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkSelfPermission()</span><br><span class=\"line\">requestPermissions()</span><br></pre></td></tr></table></figure></p>\n<p>处理权限的代码并不复杂，但是需要自己去封装。<br>我自己是使用的一个开源库：<a href=\"https://github.com/lovedise/PermissionGen\">https://github.com/lovedise/PermissionGen</a><br>使用起来比较方便，感兴趣的可以看看。</p>"},{"title":"okhttp3请求头中含中文报错原因及解决方案","date":"2018-12-05T07:26:14.000Z","_content":"\n最近在负责做一个图片加载模块，测试过程中反馈一个问题：有两个测试设备上加载不了图片。我就纳闷了，我就一个加载图片模块怎么还跟机型适配扯上关系了。然后查了下日志异常如下：\n<!-- more -->\n```\njava.lang.IllegalArgumentException: Unexpected char 0x8d2d at 13 in content-disposition value: filename=\"3.6购买页.jpg\"\n\tat com.bumptech.glide.request.RequestFutureTarget.doGet(RequestFutureTarget.java:189)\n\tat com.bumptech.glide.request.RequestFutureTarget.get(RequestFutureTarget.java:100)\n\tat com.pptv.tvsports.common.disk.ImageDiskCache.lambda$putCacheImage$0$ImageDiskCache(ImageDiskCache.java:100)\n\tat com.pptv.tvsports.common.disk.ImageDiskCache$$Lambda$0.run(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n\tat java.lang.Thread.run(Thread.java:818)\nCaused by: java.lang.IllegalArgumentException: Unexpected char 0x8d2d at 13 in content-disposition value: filename=\"3.6购买页.jpg\"\n\tat okhttp3.Headers$Builder.checkNameAndValue(Headers.java:283)\n\tat okhttp3.Headers$Builder.add(Headers.java:233)\n\tat okhttp3.internal.http.Http2xStream.readHttp2HeadersList(Http2xStream.java:263)\n\tat okhttp3.internal.http.Http2xStream.readResponseHeaders(Http2xStream.java:149)\n\tat okhttp3.internal.http.HttpEngine.readNetworkResponse(HttpEngine.java:723)\n\tat okhttp3.internal.http.HttpEngine.access$200(HttpEngine.java:81)\n\tat okhttp3.internal.http.HttpEngine$NetworkInterceptorChain.proceed(HttpEngine.java:708)\n\tat okhttp3.internal.http.HttpEngine.readResponse(HttpEngine.java:563)\n\tat okhttp3.RealCall.getResponse(RealCall.java:241)\n\tat okhttp3.RealCall$ApplicationInterceptorChain.proceed(RealCall.java:198)\n\tat okhttp3.SNInterceptor.intercept(SNInterceptor.java:62)\n\tat okhttp3.RealCall$ApplicationInterceptorChain.proceed(RealCall.java:187)\n\tat okhttp3.RealCall.getResponseWithInterceptorChain(RealCall.java:160)\n\tat okhttp3.RealCall.execute(RealCall.java:57)\n\tat com.pptv.tvsports.glide.MOkHttpStreamFetcher.loadData(MOkHttpStreamFetcher.java:51)\n\tat com.pptv.tvsports.glide.MOkHttpStreamFetcher.loadData(MOkHttpStreamFetcher.java:22)\n\tat com.bumptech.glide.load.engine.DecodeJob.decodeSource(DecodeJob.java:170)\n\tat com.bumptech.glide.load.engine.DecodeJob.decodeFromSource(DecodeJob.java:128)\n\tat com.bumptech.glide.load.engine.EngineRunnable.decodeFromSource(EngineRunnable.java:127)\n\tat com.bumptech.glide.load.engine.EngineRunnable.decode(EngineRunnable.java:106)\n\tat com.bumptech.glide.load.engine.EngineRunnable.run(EngineRunnable.java:58)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:423)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:237)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n\tat java.lang.Thread.run(Thread.java:818)\n\tat com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor$DefaultThreadFactory$1.run(FifoPriorityThreadPoolExecutor.java:118)\n```\n其实从日志上，问题原因已经很明显，但是查找问题的时候我犯了个错误。就是没有根据堆栈信息查找问题，这是由于平时发现问题的时候习惯于定位应用的代码入口，而不是查看源码报错处。\n当时看到这个异常的时候，第一反应是保存文件的时候使用中文出错，但是我写的代码中保存图片用的是自己定义的字符串，而这个filename在代码里根本查不到。所以这种情况下这个filename只能是通过图片url获取到的，然后我打开chrome调试，可以看到图片url的响应报头中有这个东西：\n```\n\tContent-Disposition：filename=\"3.6购买页.jpg\n```\nContent-disposition是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。当 Internet Explorer 接收到头时，它会激活文件下载对话框，它的文件名框自动填充了头中指定的文件名。\n知道了filename是哪里来的之后，再去找发生问题的原因。在我的代码里我只调用了：\n```\n\tFile imageFile = Glide.with(mContext).load(url).downloadOnly(Target.SIZE_ORIGINAL, \t\t\t\tTarget.SIZE_ORIGINAL).get();\n```\n所以当时我的理解是，glide在加载图片时内部缓存文件时因为filename报错。看了半天源码后，发现最终调用的是项目中自定义的DataFetcher的loadData方法，然后就是okhttp的正常请求调用了。其实整个调用链跟异常日志的堆栈信息是一样的。okhttp的详细调用略过，最终的问题出现在Http2xStream（这个类是负责处理Http2.0协议的，还有一个Http1xStream类处理Http1.x协议，这个会根据当前设备是否支持去初始化不同的类，这也是为什么会有请求头中文报错只有部分机型存在）的readHttp2HeadersList方法，这里会读取response的header，问题在这个调用\n```\n\theadersBuilder.add(name.utf8(), value);\n```\nokhttp3.Headers.java\n```\n\t/** Add a field with the specified value. */\n\tpublic Builder add(String name, String value) {\n      checkNameAndValue(name, value);\n      return addLenient(name, value);\n    }\n\t\n\tprivate void checkNameAndValue(String name, String value) {\n      if (name == null) throw new IllegalArgumentException(\"name == null\");\n      if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n      for (int i = 0, length = name.length(); i < length; i++) {\n        char c = name.charAt(i);\n        if (c <= '\\u001f' || c >= '\\u007f') {\n          throw new IllegalArgumentException(String.format(\n              \"Unexpected char %#04x at %d in header name: %s\", (int) c, i, name));\n        }\n      }\n      if (value == null) throw new IllegalArgumentException(\"value == null\");\n      for (int i = 0, length = value.length(); i < length; i++) {\n        char c = value.charAt(i);\n        if (c <= '\\u001f' || c >= '\\u007f') {\n          throw new IllegalArgumentException(String.format(\n              \"Unexpected char %#04x at %d in %s value: %s\", (int) c, i, name, value));\n        }\n      }\n    }\n```\n这里就是问题出现的原因，checkNameAndValue这个方法会对请求头的name、value进行校验。\n\n## 解决思路\n既然发现了出现问题的原因，现在就是找解决方案，其实在网上搜索okhttp请求头中文，这个关键字也会搜到一些文章。但是这些给出的解决方案一般都是对请求头进行转码，因为一般这种问题都出现在前端request的时候，而我碰到的服务端返回的请求头中带中文。\n出现这问题之后我首先是想让后端协助解决掉这个问题，但是跟后端沟通过后发现他也不知道这个filename是哪里来的，他没有对这块进行处理。出于各种原因他也不能去专门修改这个问题，同时他也指出你们使用的框架不支持请求头中文，本身就不合理。我听他这么一说也挺有道理，就放弃了这个想法。\n既然靠后端修改走不通，我又查了下资料。既然filename有一个名字，那肯定是哪里传过去的，后台配置图片都配置的是英文，这中文必然是上传图片时存储在本地的文件名。然后跟产品和运营沟通了一下，果然这个命名是他们本地的。然后让他们修改本地文件名重新上传了一下，这问题算是解决了。\n但是，问题肯定不能到这为止。如果其他人碰到这个问题，又没办法让在源头做修改，那这个问题如何解决？\n\n下面说一下我个人的解决方案：\n### 方案一：使用拦截器（适用于发起request时）\n这个方案比较常规，你也可以在出错的请求发起时对对应的request请求头进行转码。也可以在构造OkHttpClient时addInterceptor，然后在intercept中对request统一进行转码。具体代码就不赘述了，到处都能找到。但是需要注意的是，**在intercept中是无法规避response中请求头有中文的**，因为出错的位置在你通过chain.proceed(request)拿到response之前，这点可以在源码中看到后续我也会写文章讲okhttp整个流程。\n\n### 方案二：反射\n这个方案是我自己使用的方案，源于分析代码的时候，问题出在readHttp2HeadersList的\n```\n\tif (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {\n        headersBuilder.add(name.utf8(), value);\n      }\n```\n这里的add方法，而我碰到的问题是某一个请求头会返回中文，并且客户端不需要这个请求头的参数。那既然这样，如果我去修改HTTP_2_SKIPPED_RESPONSE_HEADERS这个List，不就可以实现我需要的功能并且改动最小吗。具体代码如下：\n```\n\tprivate boolean hookOkHttpReadHeader(){\n        try {\n            Class clz = Class.forName(\"okhttp3.internal.http.Http2xStream\");\n            Field field = clz.getField(\"HTTP_2_SKIPPED_RESPONSE_HEADERS\");\n            field.setAccessible(true);\n            field.set(new ArrayList<>(), HTTP_2_SKIPPED_RESPONSE_HEADERS);\n\t\t\treturn true;\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (NoSuchFieldException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n```\n**此方法适用于客户端不需要请求头中的参数的情况**。\n\n### 方案三：方法替换\n虽然我自己的问题解决了，但是我还是在想能不能去完美的解决这个问题而不是取巧，有没有一个方法能够实现替换Headers中的add方法实现，让add方法不去调用checkNameAndValue，或者是修改checkNameAndValue的内部实现。\n想过之后突然发现这不就是热修复中的方法替换，andfix不就是通过替换方法指针达到修复的目的吗，这个情况跟我想要实现的一模一样。既然如此，可以使用andfix的方案解决问题。但是这样会导致包体积增大以及兼容性问题，而且就算有源码实现这个过程也是要耗费大量时间的，这里只是提供一种思路。\n\n### 方案四：自行编译\n这个方案是你自己去pull okhttp源码，修改对应位置，然后生成依赖供自己使用。**这样可以完整的规避这种问题**。\n","source":"_posts/okhttp3请求头中含中文报错原因及解决方案.md","raw":"---\ntitle: okhttp3请求头中含中文报错原因及解决方案\ndate: 2018-12-5 15:26:14\ncategories: Android常见问题\ntags: Android, 常见问题\n---\n\n最近在负责做一个图片加载模块，测试过程中反馈一个问题：有两个测试设备上加载不了图片。我就纳闷了，我就一个加载图片模块怎么还跟机型适配扯上关系了。然后查了下日志异常如下：\n<!-- more -->\n```\njava.lang.IllegalArgumentException: Unexpected char 0x8d2d at 13 in content-disposition value: filename=\"3.6购买页.jpg\"\n\tat com.bumptech.glide.request.RequestFutureTarget.doGet(RequestFutureTarget.java:189)\n\tat com.bumptech.glide.request.RequestFutureTarget.get(RequestFutureTarget.java:100)\n\tat com.pptv.tvsports.common.disk.ImageDiskCache.lambda$putCacheImage$0$ImageDiskCache(ImageDiskCache.java:100)\n\tat com.pptv.tvsports.common.disk.ImageDiskCache$$Lambda$0.run(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n\tat java.lang.Thread.run(Thread.java:818)\nCaused by: java.lang.IllegalArgumentException: Unexpected char 0x8d2d at 13 in content-disposition value: filename=\"3.6购买页.jpg\"\n\tat okhttp3.Headers$Builder.checkNameAndValue(Headers.java:283)\n\tat okhttp3.Headers$Builder.add(Headers.java:233)\n\tat okhttp3.internal.http.Http2xStream.readHttp2HeadersList(Http2xStream.java:263)\n\tat okhttp3.internal.http.Http2xStream.readResponseHeaders(Http2xStream.java:149)\n\tat okhttp3.internal.http.HttpEngine.readNetworkResponse(HttpEngine.java:723)\n\tat okhttp3.internal.http.HttpEngine.access$200(HttpEngine.java:81)\n\tat okhttp3.internal.http.HttpEngine$NetworkInterceptorChain.proceed(HttpEngine.java:708)\n\tat okhttp3.internal.http.HttpEngine.readResponse(HttpEngine.java:563)\n\tat okhttp3.RealCall.getResponse(RealCall.java:241)\n\tat okhttp3.RealCall$ApplicationInterceptorChain.proceed(RealCall.java:198)\n\tat okhttp3.SNInterceptor.intercept(SNInterceptor.java:62)\n\tat okhttp3.RealCall$ApplicationInterceptorChain.proceed(RealCall.java:187)\n\tat okhttp3.RealCall.getResponseWithInterceptorChain(RealCall.java:160)\n\tat okhttp3.RealCall.execute(RealCall.java:57)\n\tat com.pptv.tvsports.glide.MOkHttpStreamFetcher.loadData(MOkHttpStreamFetcher.java:51)\n\tat com.pptv.tvsports.glide.MOkHttpStreamFetcher.loadData(MOkHttpStreamFetcher.java:22)\n\tat com.bumptech.glide.load.engine.DecodeJob.decodeSource(DecodeJob.java:170)\n\tat com.bumptech.glide.load.engine.DecodeJob.decodeFromSource(DecodeJob.java:128)\n\tat com.bumptech.glide.load.engine.EngineRunnable.decodeFromSource(EngineRunnable.java:127)\n\tat com.bumptech.glide.load.engine.EngineRunnable.decode(EngineRunnable.java:106)\n\tat com.bumptech.glide.load.engine.EngineRunnable.run(EngineRunnable.java:58)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:423)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:237)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n\tat java.lang.Thread.run(Thread.java:818)\n\tat com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor$DefaultThreadFactory$1.run(FifoPriorityThreadPoolExecutor.java:118)\n```\n其实从日志上，问题原因已经很明显，但是查找问题的时候我犯了个错误。就是没有根据堆栈信息查找问题，这是由于平时发现问题的时候习惯于定位应用的代码入口，而不是查看源码报错处。\n当时看到这个异常的时候，第一反应是保存文件的时候使用中文出错，但是我写的代码中保存图片用的是自己定义的字符串，而这个filename在代码里根本查不到。所以这种情况下这个filename只能是通过图片url获取到的，然后我打开chrome调试，可以看到图片url的响应报头中有这个东西：\n```\n\tContent-Disposition：filename=\"3.6购买页.jpg\n```\nContent-disposition是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。当 Internet Explorer 接收到头时，它会激活文件下载对话框，它的文件名框自动填充了头中指定的文件名。\n知道了filename是哪里来的之后，再去找发生问题的原因。在我的代码里我只调用了：\n```\n\tFile imageFile = Glide.with(mContext).load(url).downloadOnly(Target.SIZE_ORIGINAL, \t\t\t\tTarget.SIZE_ORIGINAL).get();\n```\n所以当时我的理解是，glide在加载图片时内部缓存文件时因为filename报错。看了半天源码后，发现最终调用的是项目中自定义的DataFetcher的loadData方法，然后就是okhttp的正常请求调用了。其实整个调用链跟异常日志的堆栈信息是一样的。okhttp的详细调用略过，最终的问题出现在Http2xStream（这个类是负责处理Http2.0协议的，还有一个Http1xStream类处理Http1.x协议，这个会根据当前设备是否支持去初始化不同的类，这也是为什么会有请求头中文报错只有部分机型存在）的readHttp2HeadersList方法，这里会读取response的header，问题在这个调用\n```\n\theadersBuilder.add(name.utf8(), value);\n```\nokhttp3.Headers.java\n```\n\t/** Add a field with the specified value. */\n\tpublic Builder add(String name, String value) {\n      checkNameAndValue(name, value);\n      return addLenient(name, value);\n    }\n\t\n\tprivate void checkNameAndValue(String name, String value) {\n      if (name == null) throw new IllegalArgumentException(\"name == null\");\n      if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n      for (int i = 0, length = name.length(); i < length; i++) {\n        char c = name.charAt(i);\n        if (c <= '\\u001f' || c >= '\\u007f') {\n          throw new IllegalArgumentException(String.format(\n              \"Unexpected char %#04x at %d in header name: %s\", (int) c, i, name));\n        }\n      }\n      if (value == null) throw new IllegalArgumentException(\"value == null\");\n      for (int i = 0, length = value.length(); i < length; i++) {\n        char c = value.charAt(i);\n        if (c <= '\\u001f' || c >= '\\u007f') {\n          throw new IllegalArgumentException(String.format(\n              \"Unexpected char %#04x at %d in %s value: %s\", (int) c, i, name, value));\n        }\n      }\n    }\n```\n这里就是问题出现的原因，checkNameAndValue这个方法会对请求头的name、value进行校验。\n\n## 解决思路\n既然发现了出现问题的原因，现在就是找解决方案，其实在网上搜索okhttp请求头中文，这个关键字也会搜到一些文章。但是这些给出的解决方案一般都是对请求头进行转码，因为一般这种问题都出现在前端request的时候，而我碰到的服务端返回的请求头中带中文。\n出现这问题之后我首先是想让后端协助解决掉这个问题，但是跟后端沟通过后发现他也不知道这个filename是哪里来的，他没有对这块进行处理。出于各种原因他也不能去专门修改这个问题，同时他也指出你们使用的框架不支持请求头中文，本身就不合理。我听他这么一说也挺有道理，就放弃了这个想法。\n既然靠后端修改走不通，我又查了下资料。既然filename有一个名字，那肯定是哪里传过去的，后台配置图片都配置的是英文，这中文必然是上传图片时存储在本地的文件名。然后跟产品和运营沟通了一下，果然这个命名是他们本地的。然后让他们修改本地文件名重新上传了一下，这问题算是解决了。\n但是，问题肯定不能到这为止。如果其他人碰到这个问题，又没办法让在源头做修改，那这个问题如何解决？\n\n下面说一下我个人的解决方案：\n### 方案一：使用拦截器（适用于发起request时）\n这个方案比较常规，你也可以在出错的请求发起时对对应的request请求头进行转码。也可以在构造OkHttpClient时addInterceptor，然后在intercept中对request统一进行转码。具体代码就不赘述了，到处都能找到。但是需要注意的是，**在intercept中是无法规避response中请求头有中文的**，因为出错的位置在你通过chain.proceed(request)拿到response之前，这点可以在源码中看到后续我也会写文章讲okhttp整个流程。\n\n### 方案二：反射\n这个方案是我自己使用的方案，源于分析代码的时候，问题出在readHttp2HeadersList的\n```\n\tif (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {\n        headersBuilder.add(name.utf8(), value);\n      }\n```\n这里的add方法，而我碰到的问题是某一个请求头会返回中文，并且客户端不需要这个请求头的参数。那既然这样，如果我去修改HTTP_2_SKIPPED_RESPONSE_HEADERS这个List，不就可以实现我需要的功能并且改动最小吗。具体代码如下：\n```\n\tprivate boolean hookOkHttpReadHeader(){\n        try {\n            Class clz = Class.forName(\"okhttp3.internal.http.Http2xStream\");\n            Field field = clz.getField(\"HTTP_2_SKIPPED_RESPONSE_HEADERS\");\n            field.setAccessible(true);\n            field.set(new ArrayList<>(), HTTP_2_SKIPPED_RESPONSE_HEADERS);\n\t\t\treturn true;\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (NoSuchFieldException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n```\n**此方法适用于客户端不需要请求头中的参数的情况**。\n\n### 方案三：方法替换\n虽然我自己的问题解决了，但是我还是在想能不能去完美的解决这个问题而不是取巧，有没有一个方法能够实现替换Headers中的add方法实现，让add方法不去调用checkNameAndValue，或者是修改checkNameAndValue的内部实现。\n想过之后突然发现这不就是热修复中的方法替换，andfix不就是通过替换方法指针达到修复的目的吗，这个情况跟我想要实现的一模一样。既然如此，可以使用andfix的方案解决问题。但是这样会导致包体积增大以及兼容性问题，而且就算有源码实现这个过程也是要耗费大量时间的，这里只是提供一种思路。\n\n### 方案四：自行编译\n这个方案是你自己去pull okhttp源码，修改对应位置，然后生成依赖供自己使用。**这样可以完整的规避这种问题**。\n","slug":"okhttp3请求头中含中文报错原因及解决方案","published":1,"updated":"2018-12-19T03:19:34.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw7fkyt000ygcl9mc5oo8ub","content":"<p>最近在负责做一个图片加载模块，测试过程中反馈一个问题：有两个测试设备上加载不了图片。我就纳闷了，我就一个加载图片模块怎么还跟机型适配扯上关系了。然后查了下日志异常如下：<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalArgumentException: Unexpected char 0x8d2d at 13 in content-disposition value: filename=&quot;3.6购买页.jpg&quot;</span><br><span class=\"line\">\tat com.bumptech.glide.request.RequestFutureTarget.doGet(RequestFutureTarget.java:189)</span><br><span class=\"line\">\tat com.bumptech.glide.request.RequestFutureTarget.get(RequestFutureTarget.java:100)</span><br><span class=\"line\">\tat com.pptv.tvsports.common.disk.ImageDiskCache.lambda$putCacheImage$0$ImageDiskCache(ImageDiskCache.java:100)</span><br><span class=\"line\">\tat com.pptv.tvsports.common.disk.ImageDiskCache$$Lambda$0.run(Unknown Source)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:818)</span><br><span class=\"line\">Caused by: java.lang.IllegalArgumentException: Unexpected char 0x8d2d at 13 in content-disposition value: filename=&quot;3.6购买页.jpg&quot;</span><br><span class=\"line\">\tat okhttp3.Headers$Builder.checkNameAndValue(Headers.java:283)</span><br><span class=\"line\">\tat okhttp3.Headers$Builder.add(Headers.java:233)</span><br><span class=\"line\">\tat okhttp3.internal.http.Http2xStream.readHttp2HeadersList(Http2xStream.java:263)</span><br><span class=\"line\">\tat okhttp3.internal.http.Http2xStream.readResponseHeaders(Http2xStream.java:149)</span><br><span class=\"line\">\tat okhttp3.internal.http.HttpEngine.readNetworkResponse(HttpEngine.java:723)</span><br><span class=\"line\">\tat okhttp3.internal.http.HttpEngine.access$200(HttpEngine.java:81)</span><br><span class=\"line\">\tat okhttp3.internal.http.HttpEngine$NetworkInterceptorChain.proceed(HttpEngine.java:708)</span><br><span class=\"line\">\tat okhttp3.internal.http.HttpEngine.readResponse(HttpEngine.java:563)</span><br><span class=\"line\">\tat okhttp3.RealCall.getResponse(RealCall.java:241)</span><br><span class=\"line\">\tat okhttp3.RealCall$ApplicationInterceptorChain.proceed(RealCall.java:198)</span><br><span class=\"line\">\tat okhttp3.SNInterceptor.intercept(SNInterceptor.java:62)</span><br><span class=\"line\">\tat okhttp3.RealCall$ApplicationInterceptorChain.proceed(RealCall.java:187)</span><br><span class=\"line\">\tat okhttp3.RealCall.getResponseWithInterceptorChain(RealCall.java:160)</span><br><span class=\"line\">\tat okhttp3.RealCall.execute(RealCall.java:57)</span><br><span class=\"line\">\tat com.pptv.tvsports.glide.MOkHttpStreamFetcher.loadData(MOkHttpStreamFetcher.java:51)</span><br><span class=\"line\">\tat com.pptv.tvsports.glide.MOkHttpStreamFetcher.loadData(MOkHttpStreamFetcher.java:22)</span><br><span class=\"line\">\tat com.bumptech.glide.load.engine.DecodeJob.decodeSource(DecodeJob.java:170)</span><br><span class=\"line\">\tat com.bumptech.glide.load.engine.DecodeJob.decodeFromSource(DecodeJob.java:128)</span><br><span class=\"line\">\tat com.bumptech.glide.load.engine.EngineRunnable.decodeFromSource(EngineRunnable.java:127)</span><br><span class=\"line\">\tat com.bumptech.glide.load.engine.EngineRunnable.decode(EngineRunnable.java:106)</span><br><span class=\"line\">\tat com.bumptech.glide.load.engine.EngineRunnable.run(EngineRunnable.java:58)</span><br><span class=\"line\">\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:423)</span><br><span class=\"line\">\tat java.util.concurrent.FutureTask.run(FutureTask.java:237)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:818)</span><br><span class=\"line\">\tat com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor$DefaultThreadFactory$1.run(FifoPriorityThreadPoolExecutor.java:118)</span><br></pre></td></tr></table></figure></p>\n<p>其实从日志上，问题原因已经很明显，但是查找问题的时候我犯了个错误。就是没有根据堆栈信息查找问题，这是由于平时发现问题的时候习惯于定位应用的代码入口，而不是查看源码报错处。<br>当时看到这个异常的时候，第一反应是保存文件的时候使用中文出错，但是我写的代码中保存图片用的是自己定义的字符串，而这个filename在代码里根本查不到。所以这种情况下这个filename只能是通过图片url获取到的，然后我打开chrome调试，可以看到图片url的响应报头中有这个东西：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Disposition：filename=&quot;3.6购买页.jpg</span><br></pre></td></tr></table></figure></p>\n<p>Content-disposition是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。当 Internet Explorer 接收到头时，它会激活文件下载对话框，它的文件名框自动填充了头中指定的文件名。<br>知道了filename是哪里来的之后，再去找发生问题的原因。在我的代码里我只调用了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File imageFile = Glide.with(mContext).load(url).downloadOnly(Target.SIZE_ORIGINAL, \t\t\t\tTarget.SIZE_ORIGINAL).get();</span><br></pre></td></tr></table></figure></p>\n<p>所以当时我的理解是，glide在加载图片时内部缓存文件时因为filename报错。看了半天源码后，发现最终调用的是项目中自定义的DataFetcher的loadData方法，然后就是okhttp的正常请求调用了。其实整个调用链跟异常日志的堆栈信息是一样的。okhttp的详细调用略过，最终的问题出现在Http2xStream（这个类是负责处理Http2.0协议的，还有一个Http1xStream类处理Http1.x协议，这个会根据当前设备是否支持去初始化不同的类，这也是为什么会有请求头中文报错只有部分机型存在）的readHttp2HeadersList方法，这里会读取response的header，问题在这个调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">headersBuilder.add(name.utf8(), value);</span><br></pre></td></tr></table></figure></p>\n<p>okhttp3.Headers.java<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** Add a field with the specified value. */</span><br><span class=\"line\">public Builder add(String name, String value) &#123;</span><br><span class=\"line\">     checkNameAndValue(name, value);</span><br><span class=\"line\">     return addLenient(name, value);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void checkNameAndValue(String name, String value) &#123;</span><br><span class=\"line\">     if (name == null) throw new IllegalArgumentException(&quot;name == null&quot;);</span><br><span class=\"line\">     if (name.isEmpty()) throw new IllegalArgumentException(&quot;name is empty&quot;);</span><br><span class=\"line\">     for (int i = 0, length = name.length(); i &lt; length; i++) &#123;</span><br><span class=\"line\">       char c = name.charAt(i);</span><br><span class=\"line\">       if (c &lt;= &apos;\\u001f&apos; || c &gt;= &apos;\\u007f&apos;) &#123;</span><br><span class=\"line\">         throw new IllegalArgumentException(String.format(</span><br><span class=\"line\">             &quot;Unexpected char %#04x at %d in header name: %s&quot;, (int) c, i, name));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     if (value == null) throw new IllegalArgumentException(&quot;value == null&quot;);</span><br><span class=\"line\">     for (int i = 0, length = value.length(); i &lt; length; i++) &#123;</span><br><span class=\"line\">       char c = value.charAt(i);</span><br><span class=\"line\">       if (c &lt;= &apos;\\u001f&apos; || c &gt;= &apos;\\u007f&apos;) &#123;</span><br><span class=\"line\">         throw new IllegalArgumentException(String.format(</span><br><span class=\"line\">             &quot;Unexpected char %#04x at %d in %s value: %s&quot;, (int) c, i, name, value));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里就是问题出现的原因，checkNameAndValue这个方法会对请求头的name、value进行校验。</p>\n<h2 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h2><p>既然发现了出现问题的原因，现在就是找解决方案，其实在网上搜索okhttp请求头中文，这个关键字也会搜到一些文章。但是这些给出的解决方案一般都是对请求头进行转码，因为一般这种问题都出现在前端request的时候，而我碰到的服务端返回的请求头中带中文。<br>出现这问题之后我首先是想让后端协助解决掉这个问题，但是跟后端沟通过后发现他也不知道这个filename是哪里来的，他没有对这块进行处理。出于各种原因他也不能去专门修改这个问题，同时他也指出你们使用的框架不支持请求头中文，本身就不合理。我听他这么一说也挺有道理，就放弃了这个想法。<br>既然靠后端修改走不通，我又查了下资料。既然filename有一个名字，那肯定是哪里传过去的，后台配置图片都配置的是英文，这中文必然是上传图片时存储在本地的文件名。然后跟产品和运营沟通了一下，果然这个命名是他们本地的。然后让他们修改本地文件名重新上传了一下，这问题算是解决了。<br>但是，问题肯定不能到这为止。如果其他人碰到这个问题，又没办法让在源头做修改，那这个问题如何解决？</p>\n<p>下面说一下我个人的解决方案：</p>\n<h3 id=\"方案一：使用拦截器（适用于发起request时）\"><a href=\"#方案一：使用拦截器（适用于发起request时）\" class=\"headerlink\" title=\"方案一：使用拦截器（适用于发起request时）\"></a>方案一：使用拦截器（适用于发起request时）</h3><p>这个方案比较常规，你也可以在出错的请求发起时对对应的request请求头进行转码。也可以在构造OkHttpClient时addInterceptor，然后在intercept中对request统一进行转码。具体代码就不赘述了，到处都能找到。但是需要注意的是，<strong>在intercept中是无法规避response中请求头有中文的</strong>，因为出错的位置在你通过chain.proceed(request)拿到response之前，这点可以在源码中看到后续我也会写文章讲okhttp整个流程。</p>\n<h3 id=\"方案二：反射\"><a href=\"#方案二：反射\" class=\"headerlink\" title=\"方案二：反射\"></a>方案二：反射</h3><p>这个方案是我自己使用的方案，源于分析代码的时候，问题出在readHttp2HeadersList的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) &#123;</span><br><span class=\"line\">       headersBuilder.add(name.utf8(), value);</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的add方法，而我碰到的问题是某一个请求头会返回中文，并且客户端不需要这个请求头的参数。那既然这样，如果我去修改HTTP_2_SKIPPED_RESPONSE_HEADERS这个List，不就可以实现我需要的功能并且改动最小吗。具体代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private boolean hookOkHttpReadHeader()&#123;</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           Class clz = Class.forName(&quot;okhttp3.internal.http.Http2xStream&quot;);</span><br><span class=\"line\">           Field field = clz.getField(&quot;HTTP_2_SKIPPED_RESPONSE_HEADERS&quot;);</span><br><span class=\"line\">           field.setAccessible(true);</span><br><span class=\"line\">           field.set(new ArrayList&lt;&gt;(), HTTP_2_SKIPPED_RESPONSE_HEADERS);</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">       &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; catch (NoSuchFieldException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; catch (IllegalAccessException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       return false;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>此方法适用于客户端不需要请求头中的参数的情况</strong>。</p>\n<h3 id=\"方案三：方法替换\"><a href=\"#方案三：方法替换\" class=\"headerlink\" title=\"方案三：方法替换\"></a>方案三：方法替换</h3><p>虽然我自己的问题解决了，但是我还是在想能不能去完美的解决这个问题而不是取巧，有没有一个方法能够实现替换Headers中的add方法实现，让add方法不去调用checkNameAndValue，或者是修改checkNameAndValue的内部实现。<br>想过之后突然发现这不就是热修复中的方法替换，andfix不就是通过替换方法指针达到修复的目的吗，这个情况跟我想要实现的一模一样。既然如此，可以使用andfix的方案解决问题。但是这样会导致包体积增大以及兼容性问题，而且就算有源码实现这个过程也是要耗费大量时间的，这里只是提供一种思路。</p>\n<h3 id=\"方案四：自行编译\"><a href=\"#方案四：自行编译\" class=\"headerlink\" title=\"方案四：自行编译\"></a>方案四：自行编译</h3><p>这个方案是你自己去pull okhttp源码，修改对应位置，然后生成依赖供自己使用。<strong>这样可以完整的规避这种问题</strong>。</p>\n","site":{"data":{}},"excerpt":"<p>最近在负责做一个图片加载模块，测试过程中反馈一个问题：有两个测试设备上加载不了图片。我就纳闷了，我就一个加载图片模块怎么还跟机型适配扯上关系了。然后查了下日志异常如下：<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalArgumentException: Unexpected char 0x8d2d at 13 in content-disposition value: filename=&quot;3.6购买页.jpg&quot;</span><br><span class=\"line\">\tat com.bumptech.glide.request.RequestFutureTarget.doGet(RequestFutureTarget.java:189)</span><br><span class=\"line\">\tat com.bumptech.glide.request.RequestFutureTarget.get(RequestFutureTarget.java:100)</span><br><span class=\"line\">\tat com.pptv.tvsports.common.disk.ImageDiskCache.lambda$putCacheImage$0$ImageDiskCache(ImageDiskCache.java:100)</span><br><span class=\"line\">\tat com.pptv.tvsports.common.disk.ImageDiskCache$$Lambda$0.run(Unknown Source)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:818)</span><br><span class=\"line\">Caused by: java.lang.IllegalArgumentException: Unexpected char 0x8d2d at 13 in content-disposition value: filename=&quot;3.6购买页.jpg&quot;</span><br><span class=\"line\">\tat okhttp3.Headers$Builder.checkNameAndValue(Headers.java:283)</span><br><span class=\"line\">\tat okhttp3.Headers$Builder.add(Headers.java:233)</span><br><span class=\"line\">\tat okhttp3.internal.http.Http2xStream.readHttp2HeadersList(Http2xStream.java:263)</span><br><span class=\"line\">\tat okhttp3.internal.http.Http2xStream.readResponseHeaders(Http2xStream.java:149)</span><br><span class=\"line\">\tat okhttp3.internal.http.HttpEngine.readNetworkResponse(HttpEngine.java:723)</span><br><span class=\"line\">\tat okhttp3.internal.http.HttpEngine.access$200(HttpEngine.java:81)</span><br><span class=\"line\">\tat okhttp3.internal.http.HttpEngine$NetworkInterceptorChain.proceed(HttpEngine.java:708)</span><br><span class=\"line\">\tat okhttp3.internal.http.HttpEngine.readResponse(HttpEngine.java:563)</span><br><span class=\"line\">\tat okhttp3.RealCall.getResponse(RealCall.java:241)</span><br><span class=\"line\">\tat okhttp3.RealCall$ApplicationInterceptorChain.proceed(RealCall.java:198)</span><br><span class=\"line\">\tat okhttp3.SNInterceptor.intercept(SNInterceptor.java:62)</span><br><span class=\"line\">\tat okhttp3.RealCall$ApplicationInterceptorChain.proceed(RealCall.java:187)</span><br><span class=\"line\">\tat okhttp3.RealCall.getResponseWithInterceptorChain(RealCall.java:160)</span><br><span class=\"line\">\tat okhttp3.RealCall.execute(RealCall.java:57)</span><br><span class=\"line\">\tat com.pptv.tvsports.glide.MOkHttpStreamFetcher.loadData(MOkHttpStreamFetcher.java:51)</span><br><span class=\"line\">\tat com.pptv.tvsports.glide.MOkHttpStreamFetcher.loadData(MOkHttpStreamFetcher.java:22)</span><br><span class=\"line\">\tat com.bumptech.glide.load.engine.DecodeJob.decodeSource(DecodeJob.java:170)</span><br><span class=\"line\">\tat com.bumptech.glide.load.engine.DecodeJob.decodeFromSource(DecodeJob.java:128)</span><br><span class=\"line\">\tat com.bumptech.glide.load.engine.EngineRunnable.decodeFromSource(EngineRunnable.java:127)</span><br><span class=\"line\">\tat com.bumptech.glide.load.engine.EngineRunnable.decode(EngineRunnable.java:106)</span><br><span class=\"line\">\tat com.bumptech.glide.load.engine.EngineRunnable.run(EngineRunnable.java:58)</span><br><span class=\"line\">\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:423)</span><br><span class=\"line\">\tat java.util.concurrent.FutureTask.run(FutureTask.java:237)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:818)</span><br><span class=\"line\">\tat com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor$DefaultThreadFactory$1.run(FifoPriorityThreadPoolExecutor.java:118)</span><br></pre></td></tr></table></figure></p>\n<p>其实从日志上，问题原因已经很明显，但是查找问题的时候我犯了个错误。就是没有根据堆栈信息查找问题，这是由于平时发现问题的时候习惯于定位应用的代码入口，而不是查看源码报错处。<br>当时看到这个异常的时候，第一反应是保存文件的时候使用中文出错，但是我写的代码中保存图片用的是自己定义的字符串，而这个filename在代码里根本查不到。所以这种情况下这个filename只能是通过图片url获取到的，然后我打开chrome调试，可以看到图片url的响应报头中有这个东西：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Disposition：filename=&quot;3.6购买页.jpg</span><br></pre></td></tr></table></figure></p>\n<p>Content-disposition是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。当 Internet Explorer 接收到头时，它会激活文件下载对话框，它的文件名框自动填充了头中指定的文件名。<br>知道了filename是哪里来的之后，再去找发生问题的原因。在我的代码里我只调用了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File imageFile = Glide.with(mContext).load(url).downloadOnly(Target.SIZE_ORIGINAL, \t\t\t\tTarget.SIZE_ORIGINAL).get();</span><br></pre></td></tr></table></figure></p>\n<p>所以当时我的理解是，glide在加载图片时内部缓存文件时因为filename报错。看了半天源码后，发现最终调用的是项目中自定义的DataFetcher的loadData方法，然后就是okhttp的正常请求调用了。其实整个调用链跟异常日志的堆栈信息是一样的。okhttp的详细调用略过，最终的问题出现在Http2xStream（这个类是负责处理Http2.0协议的，还有一个Http1xStream类处理Http1.x协议，这个会根据当前设备是否支持去初始化不同的类，这也是为什么会有请求头中文报错只有部分机型存在）的readHttp2HeadersList方法，这里会读取response的header，问题在这个调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">headersBuilder.add(name.utf8(), value);</span><br></pre></td></tr></table></figure></p>\n<p>okhttp3.Headers.java<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** Add a field with the specified value. */</span><br><span class=\"line\">public Builder add(String name, String value) &#123;</span><br><span class=\"line\">     checkNameAndValue(name, value);</span><br><span class=\"line\">     return addLenient(name, value);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void checkNameAndValue(String name, String value) &#123;</span><br><span class=\"line\">     if (name == null) throw new IllegalArgumentException(&quot;name == null&quot;);</span><br><span class=\"line\">     if (name.isEmpty()) throw new IllegalArgumentException(&quot;name is empty&quot;);</span><br><span class=\"line\">     for (int i = 0, length = name.length(); i &lt; length; i++) &#123;</span><br><span class=\"line\">       char c = name.charAt(i);</span><br><span class=\"line\">       if (c &lt;= &apos;\\u001f&apos; || c &gt;= &apos;\\u007f&apos;) &#123;</span><br><span class=\"line\">         throw new IllegalArgumentException(String.format(</span><br><span class=\"line\">             &quot;Unexpected char %#04x at %d in header name: %s&quot;, (int) c, i, name));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     if (value == null) throw new IllegalArgumentException(&quot;value == null&quot;);</span><br><span class=\"line\">     for (int i = 0, length = value.length(); i &lt; length; i++) &#123;</span><br><span class=\"line\">       char c = value.charAt(i);</span><br><span class=\"line\">       if (c &lt;= &apos;\\u001f&apos; || c &gt;= &apos;\\u007f&apos;) &#123;</span><br><span class=\"line\">         throw new IllegalArgumentException(String.format(</span><br><span class=\"line\">             &quot;Unexpected char %#04x at %d in %s value: %s&quot;, (int) c, i, name, value));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里就是问题出现的原因，checkNameAndValue这个方法会对请求头的name、value进行校验。</p>\n<h2 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h2><p>既然发现了出现问题的原因，现在就是找解决方案，其实在网上搜索okhttp请求头中文，这个关键字也会搜到一些文章。但是这些给出的解决方案一般都是对请求头进行转码，因为一般这种问题都出现在前端request的时候，而我碰到的服务端返回的请求头中带中文。<br>出现这问题之后我首先是想让后端协助解决掉这个问题，但是跟后端沟通过后发现他也不知道这个filename是哪里来的，他没有对这块进行处理。出于各种原因他也不能去专门修改这个问题，同时他也指出你们使用的框架不支持请求头中文，本身就不合理。我听他这么一说也挺有道理，就放弃了这个想法。<br>既然靠后端修改走不通，我又查了下资料。既然filename有一个名字，那肯定是哪里传过去的，后台配置图片都配置的是英文，这中文必然是上传图片时存储在本地的文件名。然后跟产品和运营沟通了一下，果然这个命名是他们本地的。然后让他们修改本地文件名重新上传了一下，这问题算是解决了。<br>但是，问题肯定不能到这为止。如果其他人碰到这个问题，又没办法让在源头做修改，那这个问题如何解决？</p>\n<p>下面说一下我个人的解决方案：</p>\n<h3 id=\"方案一：使用拦截器（适用于发起request时）\"><a href=\"#方案一：使用拦截器（适用于发起request时）\" class=\"headerlink\" title=\"方案一：使用拦截器（适用于发起request时）\"></a>方案一：使用拦截器（适用于发起request时）</h3><p>这个方案比较常规，你也可以在出错的请求发起时对对应的request请求头进行转码。也可以在构造OkHttpClient时addInterceptor，然后在intercept中对request统一进行转码。具体代码就不赘述了，到处都能找到。但是需要注意的是，<strong>在intercept中是无法规避response中请求头有中文的</strong>，因为出错的位置在你通过chain.proceed(request)拿到response之前，这点可以在源码中看到后续我也会写文章讲okhttp整个流程。</p>\n<h3 id=\"方案二：反射\"><a href=\"#方案二：反射\" class=\"headerlink\" title=\"方案二：反射\"></a>方案二：反射</h3><p>这个方案是我自己使用的方案，源于分析代码的时候，问题出在readHttp2HeadersList的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) &#123;</span><br><span class=\"line\">       headersBuilder.add(name.utf8(), value);</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的add方法，而我碰到的问题是某一个请求头会返回中文，并且客户端不需要这个请求头的参数。那既然这样，如果我去修改HTTP_2_SKIPPED_RESPONSE_HEADERS这个List，不就可以实现我需要的功能并且改动最小吗。具体代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private boolean hookOkHttpReadHeader()&#123;</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           Class clz = Class.forName(&quot;okhttp3.internal.http.Http2xStream&quot;);</span><br><span class=\"line\">           Field field = clz.getField(&quot;HTTP_2_SKIPPED_RESPONSE_HEADERS&quot;);</span><br><span class=\"line\">           field.setAccessible(true);</span><br><span class=\"line\">           field.set(new ArrayList&lt;&gt;(), HTTP_2_SKIPPED_RESPONSE_HEADERS);</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">       &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; catch (NoSuchFieldException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; catch (IllegalAccessException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       return false;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>此方法适用于客户端不需要请求头中的参数的情况</strong>。</p>\n<h3 id=\"方案三：方法替换\"><a href=\"#方案三：方法替换\" class=\"headerlink\" title=\"方案三：方法替换\"></a>方案三：方法替换</h3><p>虽然我自己的问题解决了，但是我还是在想能不能去完美的解决这个问题而不是取巧，有没有一个方法能够实现替换Headers中的add方法实现，让add方法不去调用checkNameAndValue，或者是修改checkNameAndValue的内部实现。<br>想过之后突然发现这不就是热修复中的方法替换，andfix不就是通过替换方法指针达到修复的目的吗，这个情况跟我想要实现的一模一样。既然如此，可以使用andfix的方案解决问题。但是这样会导致包体积增大以及兼容性问题，而且就算有源码实现这个过程也是要耗费大量时间的，这里只是提供一种思路。</p>\n<h3 id=\"方案四：自行编译\"><a href=\"#方案四：自行编译\" class=\"headerlink\" title=\"方案四：自行编译\"></a>方案四：自行编译</h3><p>这个方案是你自己去pull okhttp源码，修改对应位置，然后生成依赖供自己使用。<strong>这样可以完整的规避这种问题</strong>。</p>"},{"title":"Volley源码浅析","date":"2018-12-20T03:19:30.000Z","_content":"\nVolley目前看来是一个很老的框架了，很早之前我也在项目中使用过，但是当时没有去深入了解其原理。后来OkHttp出来之后，便迁移到了Okhttp。Okhttp以他的高效闻名，而大多数文章也仅仅只是一笔带过，许多人也只是跟风效仿并不知道其中为何高效之处。而同为优秀的热门框架，为何Okhttp更被大家所推荐，更多人使用？这是我重新研究Volley的原因，既然性能有优劣，那一定是需要对比。所以我们起码要了解不同框架的原理和实现思路，这样才能知道为什么这个框架更加好更加适合我们的业务，是否需要使用这个框架，这是对技术选型判断的依据，也是我写这个文章和后面分析okhttp的目的。\n<!-- more -->\n\n下面我会由一个基本的发起请求调用开始，一步步分析Volley运行机制。\n\n### 简单的调用\n\n下面的例子是一个最基本的Volley发起get、post请求的一个调用。\n\n```\n\tfun requst(){\n        val url = \"\"\n        val queue = Volley.newRequestQueue(context)\n        val getRequest = StringRequest(Request.Method.GET, url,this, this)\n        val postRequest = object : StringRequest(Request.Method.POST, url, this, this){\n            @Throws(AuthFailureError::class)\n            override fun getParams(): Map<String, String> {\n                return HashMap<String, String>()\n            }\n        }\n        queue.add(getRequest)\n        queue.add(postRequest)\n    }\n\n```\n\n### 请求内部流程\n\n首先分析其构造queue的逻辑，newRequestQueue方法最终会调用到\n\n```\n\tpublic static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) {\n        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);\n\n        String userAgent = \"volley/0\";\n        try {\n            String packageName = context.getPackageName();\n            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);\n            userAgent = packageName + \"/\" + info.versionCode;\n        } catch (NameNotFoundException e) {\n        }\n\t\t\n\t\t//这里会构建一个HurlStack对象，这个对象是最终建立连接发起请求的地方\n        if (stack == null) {\n            if (Build.VERSION.SDK_INT >= 9) {\n                stack = new HurlStack();\n            } else {\n                // Prior to Gingerbread, HttpUrlConnection was unreliable.\n                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html\n                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));\n            }\n        }\n\n\t\t//BasicNetwork对象可以理解为发送请求的辅助类，会做一些网络超时重试读取写入response一些操作\n        Network network = new BasicNetwork(stack);\n        \n        RequestQueue queue;\n\t\t//如果没有指定最大的本地缓存文件大小会调用默认的构造方法，默认是5*1024*1024\n        if (maxDiskCacheBytes <= -1)\n        {\n        \t// No maximum size specified\n        \tqueue = new RequestQueue(new DiskBasedCache(cacheDir), network);\n        }\n        else\n        {\n        \t// Disk cache size specified\n        \tqueue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network);\n        }\n\n\t\t//开启队列循环\n        queue.start();\n\n        return queue;\n    }\n```\n对于这个过程关键的一个地方我写了一些注释，先看一下RequestQueue的构造过程。\n首先从上面我们可以看到他构建了一个DiskBasedCache对象，这个对象的功能是缓存response。缓存的容器是一个初始大小为16的LinkedHashMap，如果不设置缓存，默认的大小是5*1024*1024。每次添加缓存的时候会先判断容器剩余大小是否满足，不足的话会遍历LinkedHashMap删除，直达满足最大容量*0.9，这个里面的写入请求头的操作还大量设计到了位运算。有兴趣的可以单独看一下com.android.volley.toolbox.DiskBasedCache这个类的实现。\n分析完DiskBasedCache对象之后，我们看一下RequestQueue对象构建的过程：\n```\n\tpublic RequestQueue(Cache cache, Network network, int threadPoolSize,\n            ResponseDelivery delivery) {\n        mCache = cache;\n        mNetwork = network;\n        mDispatchers = new NetworkDispatcher[threadPoolSize];\n        mDelivery = delivery;\n    }\n```\n我贴上来的是最终的构造方法，实际上如果不指定线程池的大小，会默认创建一个默认大小为4的ExecutorDelivery线程数组。\n首先看一下ResponseDelivery对象:\n```\n\tpublic RequestQueue(Cache cache, Network network, int threadPoolSize) {\n        this(cache, network, threadPoolSize,\n                new ExecutorDelivery(new Handler(Looper.getMainLooper())));\n    }\n```\n这个类的作用是对请求的结果进行分发，我们也看到了，这里传入的是一个主线程的handler对象，他的作用实际上也就是把对网络请求和IO操作的结果切换到了UI线程。有兴趣的可查看com.android.volley.ExecutorDelivery。\n接下来就是开启队列的循环:\n```\n\tpublic void start() {\n        stop();  // Make sure any currently running dispatchers are stopped.\n        // Create the cache dispatcher and start it.\n\t\t//CacheDispatcher对象继承Thread\n        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n        mCacheDispatcher.start();\n\n        // Create network dispatchers (and corresponding threads) up to the pool size.\n        for (int i = 0; i < mDispatchers.length; i++) {\n            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n                    mCache, mDelivery);\n            mDispatchers[i] = networkDispatcher;\n            networkDispatcher.start();\n        }\n    }\n```\n这里我们可以看到两个对象，CacheDispatcher、NetworkDispatcher。这里一个是负责处理复用本地缓存请求，一个是获取网络数据的，与两个队列mCacheQueue、mNetworkQueue相对应。这里的逻辑就是开启一个请求缓存的线程，开启指定数量的获取网络请求的线程，至于队列中的数据是从何而来，这个我们待会儿分析，先看看NetworkDispatcher这个线程是如何运行的：\n```\n\tpublic void run() {\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n        Request<?> request;\n\t\t//开启循环，不断的从队列中获取需要处理的请求\n        while (true) {\n            long startTimeMs = SystemClock.elapsedRealtime();\n            // release previous request object to avoid leaking request object when mQueue is drained.\n            request = null;\n            try {\n                // Take a request from the queue.\n                request = mQueue.take();\n            } catch (InterruptedException e) {\n\t\t\t\t//这里如果我们在外部调用了quit 会停止循环\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n\n            try {\n                request.addMarker(\"network-queue-take\");\n\t\t\t\t\n\t\t\t\t//如果请求已经手动取消 则移出当前正在请求的队列\n                // If the request was cancelled already, do not perform the\n                // network request.\n                if (request.isCanceled()) {\n                    request.finish(\"network-discard-cancelled\");\n                    continue;\n                }\n\n                addTrafficStatsTag(request);\n\n                // Perform the network request.\n                NetworkResponse networkResponse = mNetwork.performRequest(request);\n                request.addMarker(\"network-http-complete\");\n\n\t\t\t\t//如果服务器返回304并且已经响应过这个请求 移出当前正在请求的队列 并加入请求缓存队列\n                // If the server returned 304 AND we delivered a response already,\n                // we're done -- don't deliver a second identical response.\n                if (networkResponse.notModified && request.hasHadResponseDelivered()) {\n                    request.finish(\"not-modified\");\n                    continue;\n                }\n\n                // Parse the response here on the worker thread.\n                Response<?> response = request.parseNetworkResponse(networkResponse);\n                request.addMarker(\"network-parse-complete\");\n\n\t\t\t\t//如果request需要缓存（默认true）且response正常返回则把reponse写入缓存\n                // Write to cache if applicable.\n                // TODO: Only update cache metadata instead of entire record for 304s.\n                if (request.shouldCache() && response.cacheEntry != null) {\n                    mCache.put(request.getCacheKey(), response.cacheEntry);\n                    request.addMarker(\"network-cache-written\");\n                }\n\n\t\t\t\t//对request进行标记，缓存是可用的\n                // Post the response back.\n                request.markDelivered();\n                mDelivery.postResponse(request, response);\n            } catch (VolleyError volleyError) {\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n                parseAndDeliverNetworkError(request, volleyError);\n            } catch (Exception e) {\n                VolleyLog.e(e, \"Unhandled exception %s\", e.toString());\n                VolleyError volleyError = new VolleyError(e);\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n                mDelivery.postError(request, volleyError);\n            }\n        }\n    }\n```\n上面比较重要的地方我都写了注释，逻辑其实比较简单。比较重要的就是finish方法：\n```\n\t<T> void finish(Request<T> request) {\n        // Remove from the set of requests currently being processed.\n        synchronized (mCurrentRequests) {\n            mCurrentRequests.remove(request);\n        }\n        synchronized (mFinishedListeners) {\n          for (RequestFinishedListener<T> listener : mFinishedListeners) {\n            listener.onRequestFinished(request);\n          }\n        }\n\n\t\t//这里是最关键的逻辑，如果需要缓存对该请求的响应，会拼接请求类型和url作为key\n\t\t//从mWaitingRequests集合中移除对应request的队列，并全部添加到缓存队列中\n        if (request.shouldCache()) {\n            synchronized (mWaitingRequests) {\n                String cacheKey = request.getCacheKey();\n                Queue<Request<?>> waitingRequests = mWaitingRequests.remove(cacheKey);\n                if (waitingRequests != null) {\n                    if (VolleyLog.DEBUG) {\n                        VolleyLog.v(\"Releasing %d waiting requests for cacheKey=%s.\",\n                                waitingRequests.size(), cacheKey);\n                    }\n                    // Process all queued up requests. They won't be considered as in flight, but\n                    // that's not a problem as the cache has been primed by 'request'.\n                    mCacheQueue.addAll(waitingRequests);\n                }\n            }\n        }\n    }\n```\n上面关键逻辑我写了备注，直接看是不好理解的，这个跟前面我们调用时的add方法是相关的，而上面提到的queue的数据就是来自这里：\n```\n\tpublic <T> Request<T> add(Request<T> request) {\n        // Tag the request as belonging to this queue and add it to the set of current requests.\n        request.setRequestQueue(this);\n        synchronized (mCurrentRequests) {\n            mCurrentRequests.add(request);\n        }\n\n        // Process requests in the order they are added.\n        request.setSequence(getSequenceNumber());\n        request.addMarker(\"add-to-queue\");\n\n\t\t//如果不需要缓存，就直接添加到网络队列中并返回\n        // If the request is uncacheable, skip the cache queue and go straight to the network.\n        if (!request.shouldCache()) {\n            mNetworkQueue.add(request);\n            return request;\n        }\n\n\t\t//这部分是重要的逻辑\n\t\t//如果mWaitingRequests集合中有request这个key，则把这次的request继续添加到这个队列中\n\t\t//如果这个集合中没有与request匹配的队列，则直接把request添加到缓存队列中\n        // Insert request into stage if there's already a request with the same cache key in flight.\n        synchronized (mWaitingRequests) {\n            String cacheKey = request.getCacheKey();\n            if (mWaitingRequests.containsKey(cacheKey)) {\n                // There is already a request in flight. Queue up.\n                Queue<Request<?>> stagedRequests = mWaitingRequests.get(cacheKey);\n                if (stagedRequests == null) {\n                    stagedRequests = new LinkedList<Request<?>>();\n                }\n                stagedRequests.add(request);\n                mWaitingRequests.put(cacheKey, stagedRequests);\n                if (VolleyLog.DEBUG) {\n                    VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey);\n                }\n            } else {\n                // Insert 'null' queue for this cacheKey, indicating there is now a request in\n                // flight.\n                mWaitingRequests.put(cacheKey, null);\n                mCacheQueue.add(request);\n            }\n            return request;\n        }\n    }\n```\nadd方法和刚刚的finish方法应该结合一起看，方便理解。大致的流程是：当我们调用add添加请求时，会根据是否需要缓存去做不同的处理。不需要缓存的这里不赘述很好理解，需要缓存的情况下Volley实际上是会把请求缓存在mWaitingRequests这么一个集合当中，mWaitingRequests是一个HashMap对象。\n这样可以保证当频繁的重复请求时会把所有的重复请求都放在一个队列中，而在finish方法中我们可以看到，当请求复用缓存的时候，会把所有相同的请求都一起添加到缓存队列中。\n其实当我看到add方法中，会缓存相同请求到同一个队列中时我就有点疑惑这样做的目的到底是什么？\n这个其实跟我上面一笔带过的DiskBasedCache有关联，这个上面讲过是负责缓存response的，而他缓存的容器是LinkedHashMap：\n```\n    private final Map<String, CacheHeader> mEntries =\n            new LinkedHashMap<String, CacheHeader>(16, .75f, true);\n\n```\n关键的原因就在于这里初始化构造的accessOrder参数，而这个参数会影响你查询的策略，false是基于插入顺序，true是基于访问顺序，具体实现方式可以自行查看LinkedHashMap的get方法。这样的话会对查询重复的元素效率提升巨大。\n关于CacheDispatcher，其实他的实现跟上面的NetworkDispatcher是类似的，也是会循环的从queue中取数据，然后去缓存中查找，会根据缓存是否失效是否存在等判断查找缓存，如果没有命中缓存则会把请求添加到网络队列中。\n看完了Volley如何进行一次完整的请求以及缓存、线程、队列的流程，下面就是最重要的一点网络连接的实现，上面有提到过，真正建立连接是在HurlStack对象中的createConnection()方法进行的：\n```\n    protected HttpURLConnection createConnection(URL url) throws IOException {\n        return (HttpURLConnection) url.openConnection();\n    }\n```\n这个实际上就是Android自带的库java.net.Url完成的请求，这个里面最重要的就是getURLStreamHandler()方法生成的handler：\n```\n\tstatic URLStreamHandler getURLStreamHandler(String protocol) {\n\n        URLStreamHandler handler = handlers.get(protocol);\n        if (handler == null) {\n\n            boolean checkedWithFactory = false;\n\n            // Use the factory (if any)\n            if (factory != null) {\n                handler = factory.createURLStreamHandler(protocol);\n                checkedWithFactory = true;\n            }\n\n            // Try java protocol handler\n            if (handler == null) {\n                final String packagePrefixList = System.getProperty(protocolPathProp,\"\");\n                StringTokenizer packagePrefixIter = new StringTokenizer(packagePrefixList, \"|\");\n\n                while (handler == null &&\n                       packagePrefixIter.hasMoreTokens()) {\n\n                    String packagePrefix = packagePrefixIter.nextToken().trim();\n                    try {\n                        String clsName = packagePrefix + \".\" + protocol +\n                          \".Handler\";\n                        Class<?> cls = null;\n                        try {\n                            ClassLoader cl = ClassLoader.getSystemClassLoader();\n                            cls = Class.forName(clsName, true, cl);\n                        } catch (ClassNotFoundException e) {\n                            ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();\n                            if (contextLoader != null) {\n                                cls = Class.forName(clsName, true, contextLoader);\n                            }\n                        }\n                        if (cls != null) {\n                            handler  =\n                              (URLStreamHandler)cls.newInstance();\n                        }\n                    } catch (ReflectiveOperationException ignored) {\n                    }\n                }\n            }\n\n            // Fallback to built-in stream handler.\n            // Makes okhttp the default http/https handler\n            if (handler == null) {\n                try {\n                    // BEGIN Android-changed\n                    // Use of okhttp for http and https\n                    // Removed unnecessary use of reflection for sun classes\n                    if (protocol.equals(\"file\")) {\n                        handler = new sun.net.www.protocol.file.Handler();\n                    } else if (protocol.equals(\"ftp\")) {\n                        handler = new sun.net.www.protocol.ftp.Handler();\n                    } else if (protocol.equals(\"jar\")) {\n                        handler = new sun.net.www.protocol.jar.Handler();\n                    } else if (protocol.equals(\"http\")) {\n                        handler = (URLStreamHandler)Class.\n                            forName(\"com.android.okhttp.HttpHandler\").newInstance();\n                    } else if (protocol.equals(\"https\")) {\n                        handler = (URLStreamHandler)Class.\n                            forName(\"com.android.okhttp.HttpsHandler\").newInstance();\n                    }\n                    // END Android-changed\n                } catch (Exception e) {\n                    throw new AssertionError(e);\n                }\n            }\n\n            synchronized (streamHandlerLock) {\n\n                URLStreamHandler handler2 = null;\n\n                // Check again with hashtable just in case another\n                // thread created a handler since we last checked\n                handler2 = handlers.get(protocol);\n\n                if (handler2 != null) {\n                    return handler2;\n                }\n\n                // Check with factory if another thread set a\n                // factory since our last check\n                if (!checkedWithFactory && factory != null) {\n                    handler2 = factory.createURLStreamHandler(protocol);\n                }\n \n                if (handler2 != null) {\n                    // The handler from the factory must be given more\n                    // importance. Discard the default handler that\n                    // this thread created.\n                    handler = handler2;\n                }\n\n                // Insert this handler into the hashtable\n                if (handler != null) {\n                    handlers.put(protocol, handler);\n                }\n\n            }\n        }\n\n        return handler;\n\n    }\n```\n这里实际上也是进行了一系列缓存操作，而真正执行请求的handler是根据协议的不同通过反射或者直接初始化进行创建的，会根据不同协议创建多个handler负责请求的执行。而在代码中我们能看到，http的请求实际上是通过okhttp实现的，也印证了android4.4后原生的网络请求已经替换为okhttp了。\n\n### 总结\n至此，我们对Volley的分析已经结束。现在稍微总结一下，Volley实现了一套完整的符合Http语义的缓存机制，并且对性能方面有一些优化（缓存的命中、缓存的写入、重复请求的队列）。在设计中，Volley定义了大量的接口，正是由于这些设计，可以使得Volley拥有高度的扩展性，用户可以针对自己的需求自由的订制其中的实现。针对接口编程，不针对具体细节实现编程，多用组合，少用继承。许多优秀的框架也拥有同样的特性，这也是我们在平时开发过程中能够学习运用的。","source":"_posts/Volley源码浅析.md","raw":"---\ntitle: Volley源码浅析\ndate: 2018-12-20 11:19:30\ncategories: Android实战\ntags: Android, 第三方框架\n---\n\nVolley目前看来是一个很老的框架了，很早之前我也在项目中使用过，但是当时没有去深入了解其原理。后来OkHttp出来之后，便迁移到了Okhttp。Okhttp以他的高效闻名，而大多数文章也仅仅只是一笔带过，许多人也只是跟风效仿并不知道其中为何高效之处。而同为优秀的热门框架，为何Okhttp更被大家所推荐，更多人使用？这是我重新研究Volley的原因，既然性能有优劣，那一定是需要对比。所以我们起码要了解不同框架的原理和实现思路，这样才能知道为什么这个框架更加好更加适合我们的业务，是否需要使用这个框架，这是对技术选型判断的依据，也是我写这个文章和后面分析okhttp的目的。\n<!-- more -->\n\n下面我会由一个基本的发起请求调用开始，一步步分析Volley运行机制。\n\n### 简单的调用\n\n下面的例子是一个最基本的Volley发起get、post请求的一个调用。\n\n```\n\tfun requst(){\n        val url = \"\"\n        val queue = Volley.newRequestQueue(context)\n        val getRequest = StringRequest(Request.Method.GET, url,this, this)\n        val postRequest = object : StringRequest(Request.Method.POST, url, this, this){\n            @Throws(AuthFailureError::class)\n            override fun getParams(): Map<String, String> {\n                return HashMap<String, String>()\n            }\n        }\n        queue.add(getRequest)\n        queue.add(postRequest)\n    }\n\n```\n\n### 请求内部流程\n\n首先分析其构造queue的逻辑，newRequestQueue方法最终会调用到\n\n```\n\tpublic static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) {\n        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);\n\n        String userAgent = \"volley/0\";\n        try {\n            String packageName = context.getPackageName();\n            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);\n            userAgent = packageName + \"/\" + info.versionCode;\n        } catch (NameNotFoundException e) {\n        }\n\t\t\n\t\t//这里会构建一个HurlStack对象，这个对象是最终建立连接发起请求的地方\n        if (stack == null) {\n            if (Build.VERSION.SDK_INT >= 9) {\n                stack = new HurlStack();\n            } else {\n                // Prior to Gingerbread, HttpUrlConnection was unreliable.\n                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html\n                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));\n            }\n        }\n\n\t\t//BasicNetwork对象可以理解为发送请求的辅助类，会做一些网络超时重试读取写入response一些操作\n        Network network = new BasicNetwork(stack);\n        \n        RequestQueue queue;\n\t\t//如果没有指定最大的本地缓存文件大小会调用默认的构造方法，默认是5*1024*1024\n        if (maxDiskCacheBytes <= -1)\n        {\n        \t// No maximum size specified\n        \tqueue = new RequestQueue(new DiskBasedCache(cacheDir), network);\n        }\n        else\n        {\n        \t// Disk cache size specified\n        \tqueue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network);\n        }\n\n\t\t//开启队列循环\n        queue.start();\n\n        return queue;\n    }\n```\n对于这个过程关键的一个地方我写了一些注释，先看一下RequestQueue的构造过程。\n首先从上面我们可以看到他构建了一个DiskBasedCache对象，这个对象的功能是缓存response。缓存的容器是一个初始大小为16的LinkedHashMap，如果不设置缓存，默认的大小是5*1024*1024。每次添加缓存的时候会先判断容器剩余大小是否满足，不足的话会遍历LinkedHashMap删除，直达满足最大容量*0.9，这个里面的写入请求头的操作还大量设计到了位运算。有兴趣的可以单独看一下com.android.volley.toolbox.DiskBasedCache这个类的实现。\n分析完DiskBasedCache对象之后，我们看一下RequestQueue对象构建的过程：\n```\n\tpublic RequestQueue(Cache cache, Network network, int threadPoolSize,\n            ResponseDelivery delivery) {\n        mCache = cache;\n        mNetwork = network;\n        mDispatchers = new NetworkDispatcher[threadPoolSize];\n        mDelivery = delivery;\n    }\n```\n我贴上来的是最终的构造方法，实际上如果不指定线程池的大小，会默认创建一个默认大小为4的ExecutorDelivery线程数组。\n首先看一下ResponseDelivery对象:\n```\n\tpublic RequestQueue(Cache cache, Network network, int threadPoolSize) {\n        this(cache, network, threadPoolSize,\n                new ExecutorDelivery(new Handler(Looper.getMainLooper())));\n    }\n```\n这个类的作用是对请求的结果进行分发，我们也看到了，这里传入的是一个主线程的handler对象，他的作用实际上也就是把对网络请求和IO操作的结果切换到了UI线程。有兴趣的可查看com.android.volley.ExecutorDelivery。\n接下来就是开启队列的循环:\n```\n\tpublic void start() {\n        stop();  // Make sure any currently running dispatchers are stopped.\n        // Create the cache dispatcher and start it.\n\t\t//CacheDispatcher对象继承Thread\n        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n        mCacheDispatcher.start();\n\n        // Create network dispatchers (and corresponding threads) up to the pool size.\n        for (int i = 0; i < mDispatchers.length; i++) {\n            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n                    mCache, mDelivery);\n            mDispatchers[i] = networkDispatcher;\n            networkDispatcher.start();\n        }\n    }\n```\n这里我们可以看到两个对象，CacheDispatcher、NetworkDispatcher。这里一个是负责处理复用本地缓存请求，一个是获取网络数据的，与两个队列mCacheQueue、mNetworkQueue相对应。这里的逻辑就是开启一个请求缓存的线程，开启指定数量的获取网络请求的线程，至于队列中的数据是从何而来，这个我们待会儿分析，先看看NetworkDispatcher这个线程是如何运行的：\n```\n\tpublic void run() {\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n        Request<?> request;\n\t\t//开启循环，不断的从队列中获取需要处理的请求\n        while (true) {\n            long startTimeMs = SystemClock.elapsedRealtime();\n            // release previous request object to avoid leaking request object when mQueue is drained.\n            request = null;\n            try {\n                // Take a request from the queue.\n                request = mQueue.take();\n            } catch (InterruptedException e) {\n\t\t\t\t//这里如果我们在外部调用了quit 会停止循环\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n\n            try {\n                request.addMarker(\"network-queue-take\");\n\t\t\t\t\n\t\t\t\t//如果请求已经手动取消 则移出当前正在请求的队列\n                // If the request was cancelled already, do not perform the\n                // network request.\n                if (request.isCanceled()) {\n                    request.finish(\"network-discard-cancelled\");\n                    continue;\n                }\n\n                addTrafficStatsTag(request);\n\n                // Perform the network request.\n                NetworkResponse networkResponse = mNetwork.performRequest(request);\n                request.addMarker(\"network-http-complete\");\n\n\t\t\t\t//如果服务器返回304并且已经响应过这个请求 移出当前正在请求的队列 并加入请求缓存队列\n                // If the server returned 304 AND we delivered a response already,\n                // we're done -- don't deliver a second identical response.\n                if (networkResponse.notModified && request.hasHadResponseDelivered()) {\n                    request.finish(\"not-modified\");\n                    continue;\n                }\n\n                // Parse the response here on the worker thread.\n                Response<?> response = request.parseNetworkResponse(networkResponse);\n                request.addMarker(\"network-parse-complete\");\n\n\t\t\t\t//如果request需要缓存（默认true）且response正常返回则把reponse写入缓存\n                // Write to cache if applicable.\n                // TODO: Only update cache metadata instead of entire record for 304s.\n                if (request.shouldCache() && response.cacheEntry != null) {\n                    mCache.put(request.getCacheKey(), response.cacheEntry);\n                    request.addMarker(\"network-cache-written\");\n                }\n\n\t\t\t\t//对request进行标记，缓存是可用的\n                // Post the response back.\n                request.markDelivered();\n                mDelivery.postResponse(request, response);\n            } catch (VolleyError volleyError) {\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n                parseAndDeliverNetworkError(request, volleyError);\n            } catch (Exception e) {\n                VolleyLog.e(e, \"Unhandled exception %s\", e.toString());\n                VolleyError volleyError = new VolleyError(e);\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n                mDelivery.postError(request, volleyError);\n            }\n        }\n    }\n```\n上面比较重要的地方我都写了注释，逻辑其实比较简单。比较重要的就是finish方法：\n```\n\t<T> void finish(Request<T> request) {\n        // Remove from the set of requests currently being processed.\n        synchronized (mCurrentRequests) {\n            mCurrentRequests.remove(request);\n        }\n        synchronized (mFinishedListeners) {\n          for (RequestFinishedListener<T> listener : mFinishedListeners) {\n            listener.onRequestFinished(request);\n          }\n        }\n\n\t\t//这里是最关键的逻辑，如果需要缓存对该请求的响应，会拼接请求类型和url作为key\n\t\t//从mWaitingRequests集合中移除对应request的队列，并全部添加到缓存队列中\n        if (request.shouldCache()) {\n            synchronized (mWaitingRequests) {\n                String cacheKey = request.getCacheKey();\n                Queue<Request<?>> waitingRequests = mWaitingRequests.remove(cacheKey);\n                if (waitingRequests != null) {\n                    if (VolleyLog.DEBUG) {\n                        VolleyLog.v(\"Releasing %d waiting requests for cacheKey=%s.\",\n                                waitingRequests.size(), cacheKey);\n                    }\n                    // Process all queued up requests. They won't be considered as in flight, but\n                    // that's not a problem as the cache has been primed by 'request'.\n                    mCacheQueue.addAll(waitingRequests);\n                }\n            }\n        }\n    }\n```\n上面关键逻辑我写了备注，直接看是不好理解的，这个跟前面我们调用时的add方法是相关的，而上面提到的queue的数据就是来自这里：\n```\n\tpublic <T> Request<T> add(Request<T> request) {\n        // Tag the request as belonging to this queue and add it to the set of current requests.\n        request.setRequestQueue(this);\n        synchronized (mCurrentRequests) {\n            mCurrentRequests.add(request);\n        }\n\n        // Process requests in the order they are added.\n        request.setSequence(getSequenceNumber());\n        request.addMarker(\"add-to-queue\");\n\n\t\t//如果不需要缓存，就直接添加到网络队列中并返回\n        // If the request is uncacheable, skip the cache queue and go straight to the network.\n        if (!request.shouldCache()) {\n            mNetworkQueue.add(request);\n            return request;\n        }\n\n\t\t//这部分是重要的逻辑\n\t\t//如果mWaitingRequests集合中有request这个key，则把这次的request继续添加到这个队列中\n\t\t//如果这个集合中没有与request匹配的队列，则直接把request添加到缓存队列中\n        // Insert request into stage if there's already a request with the same cache key in flight.\n        synchronized (mWaitingRequests) {\n            String cacheKey = request.getCacheKey();\n            if (mWaitingRequests.containsKey(cacheKey)) {\n                // There is already a request in flight. Queue up.\n                Queue<Request<?>> stagedRequests = mWaitingRequests.get(cacheKey);\n                if (stagedRequests == null) {\n                    stagedRequests = new LinkedList<Request<?>>();\n                }\n                stagedRequests.add(request);\n                mWaitingRequests.put(cacheKey, stagedRequests);\n                if (VolleyLog.DEBUG) {\n                    VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey);\n                }\n            } else {\n                // Insert 'null' queue for this cacheKey, indicating there is now a request in\n                // flight.\n                mWaitingRequests.put(cacheKey, null);\n                mCacheQueue.add(request);\n            }\n            return request;\n        }\n    }\n```\nadd方法和刚刚的finish方法应该结合一起看，方便理解。大致的流程是：当我们调用add添加请求时，会根据是否需要缓存去做不同的处理。不需要缓存的这里不赘述很好理解，需要缓存的情况下Volley实际上是会把请求缓存在mWaitingRequests这么一个集合当中，mWaitingRequests是一个HashMap对象。\n这样可以保证当频繁的重复请求时会把所有的重复请求都放在一个队列中，而在finish方法中我们可以看到，当请求复用缓存的时候，会把所有相同的请求都一起添加到缓存队列中。\n其实当我看到add方法中，会缓存相同请求到同一个队列中时我就有点疑惑这样做的目的到底是什么？\n这个其实跟我上面一笔带过的DiskBasedCache有关联，这个上面讲过是负责缓存response的，而他缓存的容器是LinkedHashMap：\n```\n    private final Map<String, CacheHeader> mEntries =\n            new LinkedHashMap<String, CacheHeader>(16, .75f, true);\n\n```\n关键的原因就在于这里初始化构造的accessOrder参数，而这个参数会影响你查询的策略，false是基于插入顺序，true是基于访问顺序，具体实现方式可以自行查看LinkedHashMap的get方法。这样的话会对查询重复的元素效率提升巨大。\n关于CacheDispatcher，其实他的实现跟上面的NetworkDispatcher是类似的，也是会循环的从queue中取数据，然后去缓存中查找，会根据缓存是否失效是否存在等判断查找缓存，如果没有命中缓存则会把请求添加到网络队列中。\n看完了Volley如何进行一次完整的请求以及缓存、线程、队列的流程，下面就是最重要的一点网络连接的实现，上面有提到过，真正建立连接是在HurlStack对象中的createConnection()方法进行的：\n```\n    protected HttpURLConnection createConnection(URL url) throws IOException {\n        return (HttpURLConnection) url.openConnection();\n    }\n```\n这个实际上就是Android自带的库java.net.Url完成的请求，这个里面最重要的就是getURLStreamHandler()方法生成的handler：\n```\n\tstatic URLStreamHandler getURLStreamHandler(String protocol) {\n\n        URLStreamHandler handler = handlers.get(protocol);\n        if (handler == null) {\n\n            boolean checkedWithFactory = false;\n\n            // Use the factory (if any)\n            if (factory != null) {\n                handler = factory.createURLStreamHandler(protocol);\n                checkedWithFactory = true;\n            }\n\n            // Try java protocol handler\n            if (handler == null) {\n                final String packagePrefixList = System.getProperty(protocolPathProp,\"\");\n                StringTokenizer packagePrefixIter = new StringTokenizer(packagePrefixList, \"|\");\n\n                while (handler == null &&\n                       packagePrefixIter.hasMoreTokens()) {\n\n                    String packagePrefix = packagePrefixIter.nextToken().trim();\n                    try {\n                        String clsName = packagePrefix + \".\" + protocol +\n                          \".Handler\";\n                        Class<?> cls = null;\n                        try {\n                            ClassLoader cl = ClassLoader.getSystemClassLoader();\n                            cls = Class.forName(clsName, true, cl);\n                        } catch (ClassNotFoundException e) {\n                            ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();\n                            if (contextLoader != null) {\n                                cls = Class.forName(clsName, true, contextLoader);\n                            }\n                        }\n                        if (cls != null) {\n                            handler  =\n                              (URLStreamHandler)cls.newInstance();\n                        }\n                    } catch (ReflectiveOperationException ignored) {\n                    }\n                }\n            }\n\n            // Fallback to built-in stream handler.\n            // Makes okhttp the default http/https handler\n            if (handler == null) {\n                try {\n                    // BEGIN Android-changed\n                    // Use of okhttp for http and https\n                    // Removed unnecessary use of reflection for sun classes\n                    if (protocol.equals(\"file\")) {\n                        handler = new sun.net.www.protocol.file.Handler();\n                    } else if (protocol.equals(\"ftp\")) {\n                        handler = new sun.net.www.protocol.ftp.Handler();\n                    } else if (protocol.equals(\"jar\")) {\n                        handler = new sun.net.www.protocol.jar.Handler();\n                    } else if (protocol.equals(\"http\")) {\n                        handler = (URLStreamHandler)Class.\n                            forName(\"com.android.okhttp.HttpHandler\").newInstance();\n                    } else if (protocol.equals(\"https\")) {\n                        handler = (URLStreamHandler)Class.\n                            forName(\"com.android.okhttp.HttpsHandler\").newInstance();\n                    }\n                    // END Android-changed\n                } catch (Exception e) {\n                    throw new AssertionError(e);\n                }\n            }\n\n            synchronized (streamHandlerLock) {\n\n                URLStreamHandler handler2 = null;\n\n                // Check again with hashtable just in case another\n                // thread created a handler since we last checked\n                handler2 = handlers.get(protocol);\n\n                if (handler2 != null) {\n                    return handler2;\n                }\n\n                // Check with factory if another thread set a\n                // factory since our last check\n                if (!checkedWithFactory && factory != null) {\n                    handler2 = factory.createURLStreamHandler(protocol);\n                }\n \n                if (handler2 != null) {\n                    // The handler from the factory must be given more\n                    // importance. Discard the default handler that\n                    // this thread created.\n                    handler = handler2;\n                }\n\n                // Insert this handler into the hashtable\n                if (handler != null) {\n                    handlers.put(protocol, handler);\n                }\n\n            }\n        }\n\n        return handler;\n\n    }\n```\n这里实际上也是进行了一系列缓存操作，而真正执行请求的handler是根据协议的不同通过反射或者直接初始化进行创建的，会根据不同协议创建多个handler负责请求的执行。而在代码中我们能看到，http的请求实际上是通过okhttp实现的，也印证了android4.4后原生的网络请求已经替换为okhttp了。\n\n### 总结\n至此，我们对Volley的分析已经结束。现在稍微总结一下，Volley实现了一套完整的符合Http语义的缓存机制，并且对性能方面有一些优化（缓存的命中、缓存的写入、重复请求的队列）。在设计中，Volley定义了大量的接口，正是由于这些设计，可以使得Volley拥有高度的扩展性，用户可以针对自己的需求自由的订制其中的实现。针对接口编程，不针对具体细节实现编程，多用组合，少用继承。许多优秀的框架也拥有同样的特性，这也是我们在平时开发过程中能够学习运用的。","slug":"Volley源码浅析","published":1,"updated":"2018-12-20T06:13:17.616Z","_id":"cjpw7fl0y0013gcl97ma7zf5e","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Volley目前看来是一个很老的框架了，很早之前我也在项目中使用过，但是当时没有去深入了解其原理。后来OkHttp出来之后，便迁移到了Okhttp。Okhttp以他的高效闻名，而大多数文章也仅仅只是一笔带过，许多人也只是跟风效仿并不知道其中为何高效之处。而同为优秀的热门框架，为何Okhttp更被大家所推荐，更多人使用？这是我重新研究Volley的原因，既然性能有优劣，那一定是需要对比。所以我们起码要了解不同框架的原理和实现思路，这样才能知道为什么这个框架更加好更加适合我们的业务，是否需要使用这个框架，这是对技术选型判断的依据，也是我写这个文章和后面分析okhttp的目的。<br><a id=\"more\"></a></p>\n<p>下面我会由一个基本的发起请求调用开始，一步步分析Volley运行机制。</p>\n<h3 id=\"简单的调用\"><a href=\"#简单的调用\" class=\"headerlink\" title=\"简单的调用\"></a>简单的调用</h3><p>下面的例子是一个最基本的Volley发起get、post请求的一个调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun requst()&#123;</span><br><span class=\"line\">       val url = &quot;&quot;</span><br><span class=\"line\">       val queue = Volley.newRequestQueue(context)</span><br><span class=\"line\">       val getRequest = StringRequest(Request.Method.GET, url,this, this)</span><br><span class=\"line\">       val postRequest = object : StringRequest(Request.Method.POST, url, this, this)&#123;</span><br><span class=\"line\">           @Throws(AuthFailureError::class)</span><br><span class=\"line\">           override fun getParams(): Map&lt;String, String&gt; &#123;</span><br><span class=\"line\">               return HashMap&lt;String, String&gt;()</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       queue.add(getRequest)</span><br><span class=\"line\">       queue.add(postRequest)</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"请求内部流程\"><a href=\"#请求内部流程\" class=\"headerlink\" title=\"请求内部流程\"></a>请求内部流程</h3><p>首先分析其构造queue的逻辑，newRequestQueue方法最终会调用到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) &#123;</span><br><span class=\"line\">       File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class=\"line\"></span><br><span class=\"line\">       String userAgent = &quot;volley/0&quot;;</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           String packageName = context.getPackageName();</span><br><span class=\"line\">           PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);</span><br><span class=\"line\">           userAgent = packageName + &quot;/&quot; + info.versionCode;</span><br><span class=\"line\">       &#125; catch (NameNotFoundException e) &#123;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//这里会构建一个HurlStack对象，这个对象是最终建立连接发起请求的地方</span><br><span class=\"line\">       if (stack == null) &#123;</span><br><span class=\"line\">           if (Build.VERSION.SDK_INT &gt;= 9) &#123;</span><br><span class=\"line\">               stack = new HurlStack();</span><br><span class=\"line\">           &#125; else &#123;</span><br><span class=\"line\">               // Prior to Gingerbread, HttpUrlConnection was unreliable.</span><br><span class=\"line\">               // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span><br><span class=\"line\">               stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//BasicNetwork对象可以理解为发送请求的辅助类，会做一些网络超时重试读取写入response一些操作</span><br><span class=\"line\">       Network network = new BasicNetwork(stack);</span><br><span class=\"line\">       </span><br><span class=\"line\">       RequestQueue queue;</span><br><span class=\"line\">\t//如果没有指定最大的本地缓存文件大小会调用默认的构造方法，默认是5*1024*1024</span><br><span class=\"line\">       if (maxDiskCacheBytes &lt;= -1)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">       \t// No maximum size specified</span><br><span class=\"line\">       \tqueue = new RequestQueue(new DiskBasedCache(cacheDir), network);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       else</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">       \t// Disk cache size specified</span><br><span class=\"line\">       \tqueue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//开启队列循环</span><br><span class=\"line\">       queue.start();</span><br><span class=\"line\"></span><br><span class=\"line\">       return queue;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>对于这个过程关键的一个地方我写了一些注释，先看一下RequestQueue的构造过程。<br>首先从上面我们可以看到他构建了一个DiskBasedCache对象，这个对象的功能是缓存response。缓存的容器是一个初始大小为16的LinkedHashMap，如果不设置缓存，默认的大小是5<em>1024</em>1024。每次添加缓存的时候会先判断容器剩余大小是否满足，不足的话会遍历LinkedHashMap删除，直达满足最大容量*0.9，这个里面的写入请求头的操作还大量设计到了位运算。有兴趣的可以单独看一下com.android.volley.toolbox.DiskBasedCache这个类的实现。<br>分析完DiskBasedCache对象之后，我们看一下RequestQueue对象构建的过程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public RequestQueue(Cache cache, Network network, int threadPoolSize,</span><br><span class=\"line\">           ResponseDelivery delivery) &#123;</span><br><span class=\"line\">       mCache = cache;</span><br><span class=\"line\">       mNetwork = network;</span><br><span class=\"line\">       mDispatchers = new NetworkDispatcher[threadPoolSize];</span><br><span class=\"line\">       mDelivery = delivery;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我贴上来的是最终的构造方法，实际上如果不指定线程池的大小，会默认创建一个默认大小为4的ExecutorDelivery线程数组。<br>首先看一下ResponseDelivery对象:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123;</span><br><span class=\"line\">       this(cache, network, threadPoolSize,</span><br><span class=\"line\">               new ExecutorDelivery(new Handler(Looper.getMainLooper())));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个类的作用是对请求的结果进行分发，我们也看到了，这里传入的是一个主线程的handler对象，他的作用实际上也就是把对网络请求和IO操作的结果切换到了UI线程。有兴趣的可查看com.android.volley.ExecutorDelivery。<br>接下来就是开启队列的循环:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void start() &#123;</span><br><span class=\"line\">       stop();  // Make sure any currently running dispatchers are stopped.</span><br><span class=\"line\">       // Create the cache dispatcher and start it.</span><br><span class=\"line\">\t//CacheDispatcher对象继承Thread</span><br><span class=\"line\">       mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class=\"line\">       mCacheDispatcher.start();</span><br><span class=\"line\"></span><br><span class=\"line\">       // Create network dispatchers (and corresponding threads) up to the pool size.</span><br><span class=\"line\">       for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</span><br><span class=\"line\">           NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class=\"line\">                   mCache, mDelivery);</span><br><span class=\"line\">           mDispatchers[i] = networkDispatcher;</span><br><span class=\"line\">           networkDispatcher.start();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里我们可以看到两个对象，CacheDispatcher、NetworkDispatcher。这里一个是负责处理复用本地缓存请求，一个是获取网络数据的，与两个队列mCacheQueue、mNetworkQueue相对应。这里的逻辑就是开启一个请求缓存的线程，开启指定数量的获取网络请求的线程，至于队列中的数据是从何而来，这个我们待会儿分析，先看看NetworkDispatcher这个线程是如何运行的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">       Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class=\"line\">       Request&lt;?&gt; request;</span><br><span class=\"line\">\t//开启循环，不断的从队列中获取需要处理的请求</span><br><span class=\"line\">       while (true) &#123;</span><br><span class=\"line\">           long startTimeMs = SystemClock.elapsedRealtime();</span><br><span class=\"line\">           // release previous request object to avoid leaking request object when mQueue is drained.</span><br><span class=\"line\">           request = null;</span><br><span class=\"line\">           try &#123;</span><br><span class=\"line\">               // Take a request from the queue.</span><br><span class=\"line\">               request = mQueue.take();</span><br><span class=\"line\">           &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t//这里如果我们在外部调用了quit 会停止循环</span><br><span class=\"line\">               // We may have been interrupted because it was time to quit.</span><br><span class=\"line\">               if (mQuit) &#123;</span><br><span class=\"line\">                   return;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               continue;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           try &#123;</span><br><span class=\"line\">               request.addMarker(&quot;network-queue-take&quot;);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//如果请求已经手动取消 则移出当前正在请求的队列</span><br><span class=\"line\">               // If the request was cancelled already, do not perform the</span><br><span class=\"line\">               // network request.</span><br><span class=\"line\">               if (request.isCanceled()) &#123;</span><br><span class=\"line\">                   request.finish(&quot;network-discard-cancelled&quot;);</span><br><span class=\"line\">                   continue;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               addTrafficStatsTag(request);</span><br><span class=\"line\"></span><br><span class=\"line\">               // Perform the network request.</span><br><span class=\"line\">               NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class=\"line\">               request.addMarker(&quot;network-http-complete&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t//如果服务器返回304并且已经响应过这个请求 移出当前正在请求的队列 并加入请求缓存队列</span><br><span class=\"line\">               // If the server returned 304 AND we delivered a response already,</span><br><span class=\"line\">               // we&apos;re done -- don&apos;t deliver a second identical response.</span><br><span class=\"line\">               if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class=\"line\">                   request.finish(&quot;not-modified&quot;);</span><br><span class=\"line\">                   continue;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               // Parse the response here on the worker thread.</span><br><span class=\"line\">               Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class=\"line\">               request.addMarker(&quot;network-parse-complete&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t//如果request需要缓存（默认true）且response正常返回则把reponse写入缓存</span><br><span class=\"line\">               // Write to cache if applicable.</span><br><span class=\"line\">               // TODO: Only update cache metadata instead of entire record for 304s.</span><br><span class=\"line\">               if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</span><br><span class=\"line\">                   mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class=\"line\">                   request.addMarker(&quot;network-cache-written&quot;);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t//对request进行标记，缓存是可用的</span><br><span class=\"line\">               // Post the response back.</span><br><span class=\"line\">               request.markDelivered();</span><br><span class=\"line\">               mDelivery.postResponse(request, response);</span><br><span class=\"line\">           &#125; catch (VolleyError volleyError) &#123;</span><br><span class=\"line\">               volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class=\"line\">               parseAndDeliverNetworkError(request, volleyError);</span><br><span class=\"line\">           &#125; catch (Exception e) &#123;</span><br><span class=\"line\">               VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</span><br><span class=\"line\">               VolleyError volleyError = new VolleyError(e);</span><br><span class=\"line\">               volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class=\"line\">               mDelivery.postError(request, volleyError);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面比较重要的地方我都写了注释，逻辑其实比较简单。比较重要的就是finish方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;T&gt; void finish(Request&lt;T&gt; request) &#123;</span><br><span class=\"line\">       // Remove from the set of requests currently being processed.</span><br><span class=\"line\">       synchronized (mCurrentRequests) &#123;</span><br><span class=\"line\">           mCurrentRequests.remove(request);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       synchronized (mFinishedListeners) &#123;</span><br><span class=\"line\">         for (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) &#123;</span><br><span class=\"line\">           listener.onRequestFinished(request);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//这里是最关键的逻辑，如果需要缓存对该请求的响应，会拼接请求类型和url作为key</span><br><span class=\"line\">\t//从mWaitingRequests集合中移除对应request的队列，并全部添加到缓存队列中</span><br><span class=\"line\">       if (request.shouldCache()) &#123;</span><br><span class=\"line\">           synchronized (mWaitingRequests) &#123;</span><br><span class=\"line\">               String cacheKey = request.getCacheKey();</span><br><span class=\"line\">               Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</span><br><span class=\"line\">               if (waitingRequests != null) &#123;</span><br><span class=\"line\">                   if (VolleyLog.DEBUG) &#123;</span><br><span class=\"line\">                       VolleyLog.v(&quot;Releasing %d waiting requests for cacheKey=%s.&quot;,</span><br><span class=\"line\">                               waitingRequests.size(), cacheKey);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">                   // Process all queued up requests. They won&apos;t be considered as in flight, but</span><br><span class=\"line\">                   // that&apos;s not a problem as the cache has been primed by &apos;request&apos;.</span><br><span class=\"line\">                   mCacheQueue.addAll(waitingRequests);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面关键逻辑我写了备注，直接看是不好理解的，这个跟前面我们调用时的add方法是相关的，而上面提到的queue的数据就是来自这里：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123;</span><br><span class=\"line\">       // Tag the request as belonging to this queue and add it to the set of current requests.</span><br><span class=\"line\">       request.setRequestQueue(this);</span><br><span class=\"line\">       synchronized (mCurrentRequests) &#123;</span><br><span class=\"line\">           mCurrentRequests.add(request);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       // Process requests in the order they are added.</span><br><span class=\"line\">       request.setSequence(getSequenceNumber());</span><br><span class=\"line\">       request.addMarker(&quot;add-to-queue&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t//如果不需要缓存，就直接添加到网络队列中并返回</span><br><span class=\"line\">       // If the request is uncacheable, skip the cache queue and go straight to the network.</span><br><span class=\"line\">       if (!request.shouldCache()) &#123;</span><br><span class=\"line\">           mNetworkQueue.add(request);</span><br><span class=\"line\">           return request;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//这部分是重要的逻辑</span><br><span class=\"line\">\t//如果mWaitingRequests集合中有request这个key，则把这次的request继续添加到这个队列中</span><br><span class=\"line\">\t//如果这个集合中没有与request匹配的队列，则直接把request添加到缓存队列中</span><br><span class=\"line\">       // Insert request into stage if there&apos;s already a request with the same cache key in flight.</span><br><span class=\"line\">       synchronized (mWaitingRequests) &#123;</span><br><span class=\"line\">           String cacheKey = request.getCacheKey();</span><br><span class=\"line\">           if (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class=\"line\">               // There is already a request in flight. Queue up.</span><br><span class=\"line\">               Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class=\"line\">               if (stagedRequests == null) &#123;</span><br><span class=\"line\">                   stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               stagedRequests.add(request);</span><br><span class=\"line\">               mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class=\"line\">               if (VolleyLog.DEBUG) &#123;</span><br><span class=\"line\">                   VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125; else &#123;</span><br><span class=\"line\">               // Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in</span><br><span class=\"line\">               // flight.</span><br><span class=\"line\">               mWaitingRequests.put(cacheKey, null);</span><br><span class=\"line\">               mCacheQueue.add(request);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           return request;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>add方法和刚刚的finish方法应该结合一起看，方便理解。大致的流程是：当我们调用add添加请求时，会根据是否需要缓存去做不同的处理。不需要缓存的这里不赘述很好理解，需要缓存的情况下Volley实际上是会把请求缓存在mWaitingRequests这么一个集合当中，mWaitingRequests是一个HashMap对象。<br>这样可以保证当频繁的重复请求时会把所有的重复请求都放在一个队列中，而在finish方法中我们可以看到，当请求复用缓存的时候，会把所有相同的请求都一起添加到缓存队列中。<br>其实当我看到add方法中，会缓存相同请求到同一个队列中时我就有点疑惑这样做的目的到底是什么？<br>这个其实跟我上面一笔带过的DiskBasedCache有关联，这个上面讲过是负责缓存response的，而他缓存的容器是LinkedHashMap：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final Map&lt;String, CacheHeader&gt; mEntries =</span><br><span class=\"line\">        new LinkedHashMap&lt;String, CacheHeader&gt;(16, .75f, true);</span><br></pre></td></tr></table></figure></p>\n<p>关键的原因就在于这里初始化构造的accessOrder参数，而这个参数会影响你查询的策略，false是基于插入顺序，true是基于访问顺序，具体实现方式可以自行查看LinkedHashMap的get方法。这样的话会对查询重复的元素效率提升巨大。<br>关于CacheDispatcher，其实他的实现跟上面的NetworkDispatcher是类似的，也是会循环的从queue中取数据，然后去缓存中查找，会根据缓存是否失效是否存在等判断查找缓存，如果没有命中缓存则会把请求添加到网络队列中。<br>看完了Volley如何进行一次完整的请求以及缓存、线程、队列的流程，下面就是最重要的一点网络连接的实现，上面有提到过，真正建立连接是在HurlStack对象中的createConnection()方法进行的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected HttpURLConnection createConnection(URL url) throws IOException &#123;</span><br><span class=\"line\">    return (HttpURLConnection) url.openConnection();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个实际上就是Android自带的库java.net.Url完成的请求，这个里面最重要的就是getURLStreamHandler()方法生成的handler：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static URLStreamHandler getURLStreamHandler(String protocol) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       URLStreamHandler handler = handlers.get(protocol);</span><br><span class=\"line\">       if (handler == null) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           boolean checkedWithFactory = false;</span><br><span class=\"line\"></span><br><span class=\"line\">           // Use the factory (if any)</span><br><span class=\"line\">           if (factory != null) &#123;</span><br><span class=\"line\">               handler = factory.createURLStreamHandler(protocol);</span><br><span class=\"line\">               checkedWithFactory = true;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           // Try java protocol handler</span><br><span class=\"line\">           if (handler == null) &#123;</span><br><span class=\"line\">               final String packagePrefixList = System.getProperty(protocolPathProp,&quot;&quot;);</span><br><span class=\"line\">               StringTokenizer packagePrefixIter = new StringTokenizer(packagePrefixList, &quot;|&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">               while (handler == null &amp;&amp;</span><br><span class=\"line\">                      packagePrefixIter.hasMoreTokens()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                   String packagePrefix = packagePrefixIter.nextToken().trim();</span><br><span class=\"line\">                   try &#123;</span><br><span class=\"line\">                       String clsName = packagePrefix + &quot;.&quot; + protocol +</span><br><span class=\"line\">                         &quot;.Handler&quot;;</span><br><span class=\"line\">                       Class&lt;?&gt; cls = null;</span><br><span class=\"line\">                       try &#123;</span><br><span class=\"line\">                           ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class=\"line\">                           cls = Class.forName(clsName, true, cl);</span><br><span class=\"line\">                       &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                           ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">                           if (contextLoader != null) &#123;</span><br><span class=\"line\">                               cls = Class.forName(clsName, true, contextLoader);</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                       if (cls != null) &#123;</span><br><span class=\"line\">                           handler  =</span><br><span class=\"line\">                             (URLStreamHandler)cls.newInstance();</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                   &#125; catch (ReflectiveOperationException ignored) &#123;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           // Fallback to built-in stream handler.</span><br><span class=\"line\">           // Makes okhttp the default http/https handler</span><br><span class=\"line\">           if (handler == null) &#123;</span><br><span class=\"line\">               try &#123;</span><br><span class=\"line\">                   // BEGIN Android-changed</span><br><span class=\"line\">                   // Use of okhttp for http and https</span><br><span class=\"line\">                   // Removed unnecessary use of reflection for sun classes</span><br><span class=\"line\">                   if (protocol.equals(&quot;file&quot;)) &#123;</span><br><span class=\"line\">                       handler = new sun.net.www.protocol.file.Handler();</span><br><span class=\"line\">                   &#125; else if (protocol.equals(&quot;ftp&quot;)) &#123;</span><br><span class=\"line\">                       handler = new sun.net.www.protocol.ftp.Handler();</span><br><span class=\"line\">                   &#125; else if (protocol.equals(&quot;jar&quot;)) &#123;</span><br><span class=\"line\">                       handler = new sun.net.www.protocol.jar.Handler();</span><br><span class=\"line\">                   &#125; else if (protocol.equals(&quot;http&quot;)) &#123;</span><br><span class=\"line\">                       handler = (URLStreamHandler)Class.</span><br><span class=\"line\">                           forName(&quot;com.android.okhttp.HttpHandler&quot;).newInstance();</span><br><span class=\"line\">                   &#125; else if (protocol.equals(&quot;https&quot;)) &#123;</span><br><span class=\"line\">                       handler = (URLStreamHandler)Class.</span><br><span class=\"line\">                           forName(&quot;com.android.okhttp.HttpsHandler&quot;).newInstance();</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">                   // END Android-changed</span><br><span class=\"line\">               &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                   throw new AssertionError(e);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           synchronized (streamHandlerLock) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">               URLStreamHandler handler2 = null;</span><br><span class=\"line\"></span><br><span class=\"line\">               // Check again with hashtable just in case another</span><br><span class=\"line\">               // thread created a handler since we last checked</span><br><span class=\"line\">               handler2 = handlers.get(protocol);</span><br><span class=\"line\"></span><br><span class=\"line\">               if (handler2 != null) &#123;</span><br><span class=\"line\">                   return handler2;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               // Check with factory if another thread set a</span><br><span class=\"line\">               // factory since our last check</span><br><span class=\"line\">               if (!checkedWithFactory &amp;&amp; factory != null) &#123;</span><br><span class=\"line\">                   handler2 = factory.createURLStreamHandler(protocol);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               if (handler2 != null) &#123;</span><br><span class=\"line\">                   // The handler from the factory must be given more</span><br><span class=\"line\">                   // importance. Discard the default handler that</span><br><span class=\"line\">                   // this thread created.</span><br><span class=\"line\">                   handler = handler2;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               // Insert this handler into the hashtable</span><br><span class=\"line\">               if (handler != null) &#123;</span><br><span class=\"line\">                   handlers.put(protocol, handler);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       return handler;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里实际上也是进行了一系列缓存操作，而真正执行请求的handler是根据协议的不同通过反射或者直接初始化进行创建的，会根据不同协议创建多个handler负责请求的执行。而在代码中我们能看到，http的请求实际上是通过okhttp实现的，也印证了android4.4后原生的网络请求已经替换为okhttp了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>至此，我们对Volley的分析已经结束。现在稍微总结一下，Volley实现了一套完整的符合Http语义的缓存机制，并且对性能方面有一些优化（缓存的命中、缓存的写入、重复请求的队列）。在设计中，Volley定义了大量的接口，正是由于这些设计，可以使得Volley拥有高度的扩展性，用户可以针对自己的需求自由的订制其中的实现。针对接口编程，不针对具体细节实现编程，多用组合，少用继承。许多优秀的框架也拥有同样的特性，这也是我们在平时开发过程中能够学习运用的。</p>\n","site":{"data":{}},"excerpt":"<p>Volley目前看来是一个很老的框架了，很早之前我也在项目中使用过，但是当时没有去深入了解其原理。后来OkHttp出来之后，便迁移到了Okhttp。Okhttp以他的高效闻名，而大多数文章也仅仅只是一笔带过，许多人也只是跟风效仿并不知道其中为何高效之处。而同为优秀的热门框架，为何Okhttp更被大家所推荐，更多人使用？这是我重新研究Volley的原因，既然性能有优劣，那一定是需要对比。所以我们起码要了解不同框架的原理和实现思路，这样才能知道为什么这个框架更加好更加适合我们的业务，是否需要使用这个框架，这是对技术选型判断的依据，也是我写这个文章和后面分析okhttp的目的。<br>","more":"</p>\n<p>下面我会由一个基本的发起请求调用开始，一步步分析Volley运行机制。</p>\n<h3 id=\"简单的调用\"><a href=\"#简单的调用\" class=\"headerlink\" title=\"简单的调用\"></a>简单的调用</h3><p>下面的例子是一个最基本的Volley发起get、post请求的一个调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun requst()&#123;</span><br><span class=\"line\">       val url = &quot;&quot;</span><br><span class=\"line\">       val queue = Volley.newRequestQueue(context)</span><br><span class=\"line\">       val getRequest = StringRequest(Request.Method.GET, url,this, this)</span><br><span class=\"line\">       val postRequest = object : StringRequest(Request.Method.POST, url, this, this)&#123;</span><br><span class=\"line\">           @Throws(AuthFailureError::class)</span><br><span class=\"line\">           override fun getParams(): Map&lt;String, String&gt; &#123;</span><br><span class=\"line\">               return HashMap&lt;String, String&gt;()</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       queue.add(getRequest)</span><br><span class=\"line\">       queue.add(postRequest)</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"请求内部流程\"><a href=\"#请求内部流程\" class=\"headerlink\" title=\"请求内部流程\"></a>请求内部流程</h3><p>首先分析其构造queue的逻辑，newRequestQueue方法最终会调用到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) &#123;</span><br><span class=\"line\">       File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class=\"line\"></span><br><span class=\"line\">       String userAgent = &quot;volley/0&quot;;</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           String packageName = context.getPackageName();</span><br><span class=\"line\">           PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);</span><br><span class=\"line\">           userAgent = packageName + &quot;/&quot; + info.versionCode;</span><br><span class=\"line\">       &#125; catch (NameNotFoundException e) &#123;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//这里会构建一个HurlStack对象，这个对象是最终建立连接发起请求的地方</span><br><span class=\"line\">       if (stack == null) &#123;</span><br><span class=\"line\">           if (Build.VERSION.SDK_INT &gt;= 9) &#123;</span><br><span class=\"line\">               stack = new HurlStack();</span><br><span class=\"line\">           &#125; else &#123;</span><br><span class=\"line\">               // Prior to Gingerbread, HttpUrlConnection was unreliable.</span><br><span class=\"line\">               // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span><br><span class=\"line\">               stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//BasicNetwork对象可以理解为发送请求的辅助类，会做一些网络超时重试读取写入response一些操作</span><br><span class=\"line\">       Network network = new BasicNetwork(stack);</span><br><span class=\"line\">       </span><br><span class=\"line\">       RequestQueue queue;</span><br><span class=\"line\">\t//如果没有指定最大的本地缓存文件大小会调用默认的构造方法，默认是5*1024*1024</span><br><span class=\"line\">       if (maxDiskCacheBytes &lt;= -1)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">       \t// No maximum size specified</span><br><span class=\"line\">       \tqueue = new RequestQueue(new DiskBasedCache(cacheDir), network);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       else</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">       \t// Disk cache size specified</span><br><span class=\"line\">       \tqueue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//开启队列循环</span><br><span class=\"line\">       queue.start();</span><br><span class=\"line\"></span><br><span class=\"line\">       return queue;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>对于这个过程关键的一个地方我写了一些注释，先看一下RequestQueue的构造过程。<br>首先从上面我们可以看到他构建了一个DiskBasedCache对象，这个对象的功能是缓存response。缓存的容器是一个初始大小为16的LinkedHashMap，如果不设置缓存，默认的大小是5<em>1024</em>1024。每次添加缓存的时候会先判断容器剩余大小是否满足，不足的话会遍历LinkedHashMap删除，直达满足最大容量*0.9，这个里面的写入请求头的操作还大量设计到了位运算。有兴趣的可以单独看一下com.android.volley.toolbox.DiskBasedCache这个类的实现。<br>分析完DiskBasedCache对象之后，我们看一下RequestQueue对象构建的过程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public RequestQueue(Cache cache, Network network, int threadPoolSize,</span><br><span class=\"line\">           ResponseDelivery delivery) &#123;</span><br><span class=\"line\">       mCache = cache;</span><br><span class=\"line\">       mNetwork = network;</span><br><span class=\"line\">       mDispatchers = new NetworkDispatcher[threadPoolSize];</span><br><span class=\"line\">       mDelivery = delivery;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我贴上来的是最终的构造方法，实际上如果不指定线程池的大小，会默认创建一个默认大小为4的ExecutorDelivery线程数组。<br>首先看一下ResponseDelivery对象:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123;</span><br><span class=\"line\">       this(cache, network, threadPoolSize,</span><br><span class=\"line\">               new ExecutorDelivery(new Handler(Looper.getMainLooper())));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个类的作用是对请求的结果进行分发，我们也看到了，这里传入的是一个主线程的handler对象，他的作用实际上也就是把对网络请求和IO操作的结果切换到了UI线程。有兴趣的可查看com.android.volley.ExecutorDelivery。<br>接下来就是开启队列的循环:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void start() &#123;</span><br><span class=\"line\">       stop();  // Make sure any currently running dispatchers are stopped.</span><br><span class=\"line\">       // Create the cache dispatcher and start it.</span><br><span class=\"line\">\t//CacheDispatcher对象继承Thread</span><br><span class=\"line\">       mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class=\"line\">       mCacheDispatcher.start();</span><br><span class=\"line\"></span><br><span class=\"line\">       // Create network dispatchers (and corresponding threads) up to the pool size.</span><br><span class=\"line\">       for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</span><br><span class=\"line\">           NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class=\"line\">                   mCache, mDelivery);</span><br><span class=\"line\">           mDispatchers[i] = networkDispatcher;</span><br><span class=\"line\">           networkDispatcher.start();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里我们可以看到两个对象，CacheDispatcher、NetworkDispatcher。这里一个是负责处理复用本地缓存请求，一个是获取网络数据的，与两个队列mCacheQueue、mNetworkQueue相对应。这里的逻辑就是开启一个请求缓存的线程，开启指定数量的获取网络请求的线程，至于队列中的数据是从何而来，这个我们待会儿分析，先看看NetworkDispatcher这个线程是如何运行的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">       Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class=\"line\">       Request&lt;?&gt; request;</span><br><span class=\"line\">\t//开启循环，不断的从队列中获取需要处理的请求</span><br><span class=\"line\">       while (true) &#123;</span><br><span class=\"line\">           long startTimeMs = SystemClock.elapsedRealtime();</span><br><span class=\"line\">           // release previous request object to avoid leaking request object when mQueue is drained.</span><br><span class=\"line\">           request = null;</span><br><span class=\"line\">           try &#123;</span><br><span class=\"line\">               // Take a request from the queue.</span><br><span class=\"line\">               request = mQueue.take();</span><br><span class=\"line\">           &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t//这里如果我们在外部调用了quit 会停止循环</span><br><span class=\"line\">               // We may have been interrupted because it was time to quit.</span><br><span class=\"line\">               if (mQuit) &#123;</span><br><span class=\"line\">                   return;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               continue;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           try &#123;</span><br><span class=\"line\">               request.addMarker(&quot;network-queue-take&quot;);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t//如果请求已经手动取消 则移出当前正在请求的队列</span><br><span class=\"line\">               // If the request was cancelled already, do not perform the</span><br><span class=\"line\">               // network request.</span><br><span class=\"line\">               if (request.isCanceled()) &#123;</span><br><span class=\"line\">                   request.finish(&quot;network-discard-cancelled&quot;);</span><br><span class=\"line\">                   continue;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               addTrafficStatsTag(request);</span><br><span class=\"line\"></span><br><span class=\"line\">               // Perform the network request.</span><br><span class=\"line\">               NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class=\"line\">               request.addMarker(&quot;network-http-complete&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t//如果服务器返回304并且已经响应过这个请求 移出当前正在请求的队列 并加入请求缓存队列</span><br><span class=\"line\">               // If the server returned 304 AND we delivered a response already,</span><br><span class=\"line\">               // we&apos;re done -- don&apos;t deliver a second identical response.</span><br><span class=\"line\">               if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class=\"line\">                   request.finish(&quot;not-modified&quot;);</span><br><span class=\"line\">                   continue;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               // Parse the response here on the worker thread.</span><br><span class=\"line\">               Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class=\"line\">               request.addMarker(&quot;network-parse-complete&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t//如果request需要缓存（默认true）且response正常返回则把reponse写入缓存</span><br><span class=\"line\">               // Write to cache if applicable.</span><br><span class=\"line\">               // TODO: Only update cache metadata instead of entire record for 304s.</span><br><span class=\"line\">               if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</span><br><span class=\"line\">                   mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class=\"line\">                   request.addMarker(&quot;network-cache-written&quot;);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t//对request进行标记，缓存是可用的</span><br><span class=\"line\">               // Post the response back.</span><br><span class=\"line\">               request.markDelivered();</span><br><span class=\"line\">               mDelivery.postResponse(request, response);</span><br><span class=\"line\">           &#125; catch (VolleyError volleyError) &#123;</span><br><span class=\"line\">               volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class=\"line\">               parseAndDeliverNetworkError(request, volleyError);</span><br><span class=\"line\">           &#125; catch (Exception e) &#123;</span><br><span class=\"line\">               VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</span><br><span class=\"line\">               VolleyError volleyError = new VolleyError(e);</span><br><span class=\"line\">               volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class=\"line\">               mDelivery.postError(request, volleyError);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面比较重要的地方我都写了注释，逻辑其实比较简单。比较重要的就是finish方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;T&gt; void finish(Request&lt;T&gt; request) &#123;</span><br><span class=\"line\">       // Remove from the set of requests currently being processed.</span><br><span class=\"line\">       synchronized (mCurrentRequests) &#123;</span><br><span class=\"line\">           mCurrentRequests.remove(request);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       synchronized (mFinishedListeners) &#123;</span><br><span class=\"line\">         for (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) &#123;</span><br><span class=\"line\">           listener.onRequestFinished(request);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//这里是最关键的逻辑，如果需要缓存对该请求的响应，会拼接请求类型和url作为key</span><br><span class=\"line\">\t//从mWaitingRequests集合中移除对应request的队列，并全部添加到缓存队列中</span><br><span class=\"line\">       if (request.shouldCache()) &#123;</span><br><span class=\"line\">           synchronized (mWaitingRequests) &#123;</span><br><span class=\"line\">               String cacheKey = request.getCacheKey();</span><br><span class=\"line\">               Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</span><br><span class=\"line\">               if (waitingRequests != null) &#123;</span><br><span class=\"line\">                   if (VolleyLog.DEBUG) &#123;</span><br><span class=\"line\">                       VolleyLog.v(&quot;Releasing %d waiting requests for cacheKey=%s.&quot;,</span><br><span class=\"line\">                               waitingRequests.size(), cacheKey);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">                   // Process all queued up requests. They won&apos;t be considered as in flight, but</span><br><span class=\"line\">                   // that&apos;s not a problem as the cache has been primed by &apos;request&apos;.</span><br><span class=\"line\">                   mCacheQueue.addAll(waitingRequests);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面关键逻辑我写了备注，直接看是不好理解的，这个跟前面我们调用时的add方法是相关的，而上面提到的queue的数据就是来自这里：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123;</span><br><span class=\"line\">       // Tag the request as belonging to this queue and add it to the set of current requests.</span><br><span class=\"line\">       request.setRequestQueue(this);</span><br><span class=\"line\">       synchronized (mCurrentRequests) &#123;</span><br><span class=\"line\">           mCurrentRequests.add(request);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       // Process requests in the order they are added.</span><br><span class=\"line\">       request.setSequence(getSequenceNumber());</span><br><span class=\"line\">       request.addMarker(&quot;add-to-queue&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t//如果不需要缓存，就直接添加到网络队列中并返回</span><br><span class=\"line\">       // If the request is uncacheable, skip the cache queue and go straight to the network.</span><br><span class=\"line\">       if (!request.shouldCache()) &#123;</span><br><span class=\"line\">           mNetworkQueue.add(request);</span><br><span class=\"line\">           return request;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//这部分是重要的逻辑</span><br><span class=\"line\">\t//如果mWaitingRequests集合中有request这个key，则把这次的request继续添加到这个队列中</span><br><span class=\"line\">\t//如果这个集合中没有与request匹配的队列，则直接把request添加到缓存队列中</span><br><span class=\"line\">       // Insert request into stage if there&apos;s already a request with the same cache key in flight.</span><br><span class=\"line\">       synchronized (mWaitingRequests) &#123;</span><br><span class=\"line\">           String cacheKey = request.getCacheKey();</span><br><span class=\"line\">           if (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class=\"line\">               // There is already a request in flight. Queue up.</span><br><span class=\"line\">               Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class=\"line\">               if (stagedRequests == null) &#123;</span><br><span class=\"line\">                   stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               stagedRequests.add(request);</span><br><span class=\"line\">               mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class=\"line\">               if (VolleyLog.DEBUG) &#123;</span><br><span class=\"line\">                   VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125; else &#123;</span><br><span class=\"line\">               // Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in</span><br><span class=\"line\">               // flight.</span><br><span class=\"line\">               mWaitingRequests.put(cacheKey, null);</span><br><span class=\"line\">               mCacheQueue.add(request);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           return request;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>add方法和刚刚的finish方法应该结合一起看，方便理解。大致的流程是：当我们调用add添加请求时，会根据是否需要缓存去做不同的处理。不需要缓存的这里不赘述很好理解，需要缓存的情况下Volley实际上是会把请求缓存在mWaitingRequests这么一个集合当中，mWaitingRequests是一个HashMap对象。<br>这样可以保证当频繁的重复请求时会把所有的重复请求都放在一个队列中，而在finish方法中我们可以看到，当请求复用缓存的时候，会把所有相同的请求都一起添加到缓存队列中。<br>其实当我看到add方法中，会缓存相同请求到同一个队列中时我就有点疑惑这样做的目的到底是什么？<br>这个其实跟我上面一笔带过的DiskBasedCache有关联，这个上面讲过是负责缓存response的，而他缓存的容器是LinkedHashMap：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final Map&lt;String, CacheHeader&gt; mEntries =</span><br><span class=\"line\">        new LinkedHashMap&lt;String, CacheHeader&gt;(16, .75f, true);</span><br></pre></td></tr></table></figure></p>\n<p>关键的原因就在于这里初始化构造的accessOrder参数，而这个参数会影响你查询的策略，false是基于插入顺序，true是基于访问顺序，具体实现方式可以自行查看LinkedHashMap的get方法。这样的话会对查询重复的元素效率提升巨大。<br>关于CacheDispatcher，其实他的实现跟上面的NetworkDispatcher是类似的，也是会循环的从queue中取数据，然后去缓存中查找，会根据缓存是否失效是否存在等判断查找缓存，如果没有命中缓存则会把请求添加到网络队列中。<br>看完了Volley如何进行一次完整的请求以及缓存、线程、队列的流程，下面就是最重要的一点网络连接的实现，上面有提到过，真正建立连接是在HurlStack对象中的createConnection()方法进行的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected HttpURLConnection createConnection(URL url) throws IOException &#123;</span><br><span class=\"line\">    return (HttpURLConnection) url.openConnection();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个实际上就是Android自带的库java.net.Url完成的请求，这个里面最重要的就是getURLStreamHandler()方法生成的handler：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static URLStreamHandler getURLStreamHandler(String protocol) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       URLStreamHandler handler = handlers.get(protocol);</span><br><span class=\"line\">       if (handler == null) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           boolean checkedWithFactory = false;</span><br><span class=\"line\"></span><br><span class=\"line\">           // Use the factory (if any)</span><br><span class=\"line\">           if (factory != null) &#123;</span><br><span class=\"line\">               handler = factory.createURLStreamHandler(protocol);</span><br><span class=\"line\">               checkedWithFactory = true;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           // Try java protocol handler</span><br><span class=\"line\">           if (handler == null) &#123;</span><br><span class=\"line\">               final String packagePrefixList = System.getProperty(protocolPathProp,&quot;&quot;);</span><br><span class=\"line\">               StringTokenizer packagePrefixIter = new StringTokenizer(packagePrefixList, &quot;|&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">               while (handler == null &amp;&amp;</span><br><span class=\"line\">                      packagePrefixIter.hasMoreTokens()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                   String packagePrefix = packagePrefixIter.nextToken().trim();</span><br><span class=\"line\">                   try &#123;</span><br><span class=\"line\">                       String clsName = packagePrefix + &quot;.&quot; + protocol +</span><br><span class=\"line\">                         &quot;.Handler&quot;;</span><br><span class=\"line\">                       Class&lt;?&gt; cls = null;</span><br><span class=\"line\">                       try &#123;</span><br><span class=\"line\">                           ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class=\"line\">                           cls = Class.forName(clsName, true, cl);</span><br><span class=\"line\">                       &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                           ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">                           if (contextLoader != null) &#123;</span><br><span class=\"line\">                               cls = Class.forName(clsName, true, contextLoader);</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                       if (cls != null) &#123;</span><br><span class=\"line\">                           handler  =</span><br><span class=\"line\">                             (URLStreamHandler)cls.newInstance();</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                   &#125; catch (ReflectiveOperationException ignored) &#123;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           // Fallback to built-in stream handler.</span><br><span class=\"line\">           // Makes okhttp the default http/https handler</span><br><span class=\"line\">           if (handler == null) &#123;</span><br><span class=\"line\">               try &#123;</span><br><span class=\"line\">                   // BEGIN Android-changed</span><br><span class=\"line\">                   // Use of okhttp for http and https</span><br><span class=\"line\">                   // Removed unnecessary use of reflection for sun classes</span><br><span class=\"line\">                   if (protocol.equals(&quot;file&quot;)) &#123;</span><br><span class=\"line\">                       handler = new sun.net.www.protocol.file.Handler();</span><br><span class=\"line\">                   &#125; else if (protocol.equals(&quot;ftp&quot;)) &#123;</span><br><span class=\"line\">                       handler = new sun.net.www.protocol.ftp.Handler();</span><br><span class=\"line\">                   &#125; else if (protocol.equals(&quot;jar&quot;)) &#123;</span><br><span class=\"line\">                       handler = new sun.net.www.protocol.jar.Handler();</span><br><span class=\"line\">                   &#125; else if (protocol.equals(&quot;http&quot;)) &#123;</span><br><span class=\"line\">                       handler = (URLStreamHandler)Class.</span><br><span class=\"line\">                           forName(&quot;com.android.okhttp.HttpHandler&quot;).newInstance();</span><br><span class=\"line\">                   &#125; else if (protocol.equals(&quot;https&quot;)) &#123;</span><br><span class=\"line\">                       handler = (URLStreamHandler)Class.</span><br><span class=\"line\">                           forName(&quot;com.android.okhttp.HttpsHandler&quot;).newInstance();</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">                   // END Android-changed</span><br><span class=\"line\">               &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                   throw new AssertionError(e);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           synchronized (streamHandlerLock) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">               URLStreamHandler handler2 = null;</span><br><span class=\"line\"></span><br><span class=\"line\">               // Check again with hashtable just in case another</span><br><span class=\"line\">               // thread created a handler since we last checked</span><br><span class=\"line\">               handler2 = handlers.get(protocol);</span><br><span class=\"line\"></span><br><span class=\"line\">               if (handler2 != null) &#123;</span><br><span class=\"line\">                   return handler2;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               // Check with factory if another thread set a</span><br><span class=\"line\">               // factory since our last check</span><br><span class=\"line\">               if (!checkedWithFactory &amp;&amp; factory != null) &#123;</span><br><span class=\"line\">                   handler2 = factory.createURLStreamHandler(protocol);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               if (handler2 != null) &#123;</span><br><span class=\"line\">                   // The handler from the factory must be given more</span><br><span class=\"line\">                   // importance. Discard the default handler that</span><br><span class=\"line\">                   // this thread created.</span><br><span class=\"line\">                   handler = handler2;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               // Insert this handler into the hashtable</span><br><span class=\"line\">               if (handler != null) &#123;</span><br><span class=\"line\">                   handlers.put(protocol, handler);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       return handler;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里实际上也是进行了一系列缓存操作，而真正执行请求的handler是根据协议的不同通过反射或者直接初始化进行创建的，会根据不同协议创建多个handler负责请求的执行。而在代码中我们能看到，http的请求实际上是通过okhttp实现的，也印证了android4.4后原生的网络请求已经替换为okhttp了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>至此，我们对Volley的分析已经结束。现在稍微总结一下，Volley实现了一套完整的符合Http语义的缓存机制，并且对性能方面有一些优化（缓存的命中、缓存的写入、重复请求的队列）。在设计中，Volley定义了大量的接口，正是由于这些设计，可以使得Volley拥有高度的扩展性，用户可以针对自己的需求自由的订制其中的实现。针对接口编程，不针对具体细节实现编程，多用组合，少用继承。许多优秀的框架也拥有同样的特性，这也是我们在平时开发过程中能够学习运用的。</p>"},{"title":"Android注解实践——打造编译时注解框架","date":"2017-04-08T07:33:40.000Z","_content":"最近一直在做项目的重构工作，因为是做组件化，正好看到阿里云开源一个路由框架[ARouter](https://github.com/alibaba/ARouter)。看了一下源码，发现是项目主要也是运用到了编译时注解的技术。联想到之前最早用过的[ButterKnife](https://github.com/JakeWharton/butterknife)，到现在的[Retrofit](https://github.com/square/retrofit)等等各种主流的开源框架，其实都有使用到这项强大技术，之前也只是简单了解了一下原理，这次就想自己也写一个这种框架，搞清楚实现原理。\n首先，注解处理器(Anonotation Processor)分为编译时(Compile time)注解和运行时(Runtime)通过反射机制运行的注解，因为编译期注解实际上是生成.java文件辅助我们实现功能，所以不会有效率上的损耗，上面提到的开源框架也都是基于这种基础实现的。\n这篇文章只涉及编译时注解(类似于[ButterKnife](https://github.com/JakeWharton/butterknife))，教大家如何打造一个简单的编译时注解框架，如何调试，和一些在实践中碰到的问题。\n<!-- more -->\n#### 基本概念\n注解处理器是Javac的一个工具，它用来在编译时扫描和处理注解，更多信息可以查看[官方文档](http://docs.oracle.com/javase/tutorial/java/annotations/index.html)。\n一个注解的注解处理器，以Java代码作为输出，生成文件（通常是.java文件）作为输出。这意味着你可以生成java代码，当然生成的.java代码是在新的文件中，你不能修改原有的Java类。但是我们可以生成辅助类，来帮助我们完成工作，就像[ButterKnife](https://github.com/JakeWharton/butterknife)这样，我们省去了findviewById的重复工作，仅需一行注解，他就能帮我们完成操作。我们掌握这项技术，也可以在之后的工作中减少重复无意义的工作，更重要的是注解能够帮我们更好的解耦我们的各个模块。\n##### 注解类型\n首先举一个我们最常见的注解：\n```java\n@Override\n```\n大家都知道这是重写的意思，我们具体看看它的代码。\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n```\n出现了两个东西，@Target、 @Retention，前者代表该注解可以作用于什么地方，后者代表要在什么级别保存该注解信息。我们看看枚举里支持的类型。\n```java\npublic enum ElementType {\n    /** Class, interface (including annotation type), or enum declaration */\n    TYPE,\n\n    /** Field declaration (includes enum constants) */\n    FIELD,\n\n    /** Method declaration */\n    METHOD,\n\n    /** Formal parameter declaration */\n    PARAMETER,\n\n    /** Constructor declaration */\n    CONSTRUCTOR,\n\n    /** Local variable declaration */\n    LOCAL_VARIABLE,\n\n    /** Annotation type declaration */\n    ANNOTATION_TYPE,\n\n    /** Package declaration */\n    PACKAGE,\n\n    /**\n     * Type parameter declaration\n     *\n     * @since 1.8\n     */\n    TYPE_PARAMETER,\n\n    /**\n     * Use of a type\n     *\n     * @since 1.8\n     */\n    TYPE_USE\n}\n```\n\n```java\npublic enum RetentionPolicy {\n    /**\n     * Annotations are to be discarded by the compiler.\n     */\n    SOURCE,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler\n     * but need not be retained by the VM at run time.  This is the default\n     * behavior.\n     */\n    CLASS,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler and\n     * retained by the VM at run time, so they may be read reflectively.\n     *\n     * @see java.lang.reflect.AnnotatedElement\n     */\n    RUNTIME\n}\n```\n上面贴出了枚举值，里面的注释也写的很清楚，我简单说一下RetentionPolicy，SOURCE是会被编译器丢弃的注解，CLASS是在编译器保存，RUNTIME是在运行期保留，可以通过反射获取到的。所以我们编译期注解框架的Retention是CLASS类型。\n##### AbstractProcessor\n接下来我们要了解一个注解的核心，[AbstractProcessor类](https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html)，它是一个抽象的注释处理器，设计来为大多数注解实践类提供方便的超类。我们所有的Processor API都是继承自AbstractProcessor类。\n我们继承AbstractProcessor类之后，需要实现四个方法：\n```java\npublic class MyProcessor extends AbstractProcessor {\n\n    @Override\n    public synchronized void init(ProcessingEnvironment env){ }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> annoations, RoundEnvironment env) { }\n\n    @Override\n    public Set<String> getSupportedAnnotationTypes() { }\n\n    @Override\n    public SourceVersion getSupportedSourceVersion() { }\n\n}\n```\n* **init(ProcessingEnvironment env)**：javac 会在 Processor 创建时调用并执行的初始化操作，该方法会传入 一个参数 ProcessingEnvironment env ，通过 env 可以访问 Elements、Types、Filer等工具类。\n* **getSupportedAnnotationTypes()**：返回需要注册的注解集合。\n* **getSupportedSourceVersion()**：返回支持的java版本，通常返回SourceVersion.latestSupported()。\n* **process(Set<? extends TypeElement> annoations, RoundEnvironment env)**：这个方法相当于Processor类的main方法，所有扫描和处理注解、生成.java文件的操作，都是在这里完成。\n\n#### 实践步骤\n了解了上面的基础知识，这里讲讲具体如何实现。我们的目的是通过注解实现替代我们findViewById的繁琐操作，类似于ButterKnife的@Bind操作。\n```java\n   @BindView(R.id.test_text)\n   TextView textView;\n```\n整个项目分为四个模块，app，annotation（注解），api，compiler（注解处理器）。\n首先讲一下整体的思路，在我们的Activity中，使用注解定义控件，在onCreate方法中，调用Api模块的bind(this)。bind方法内其实就是通过反射获取到注解处理器生成的辅助类，通过辅助类完成控件的初始化工作。\n\n##### annotation\n在项目中，New Module，选择Java Library，新建类，定义注解\n```java\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.FIELD)\npublic @interface BindView {\n\tint value();\n}\n```\n@BindView对成员变量进行注解，接收一个int类型的参数。\n\n##### api\nNew Module，选择Android Library，\n首先我们需要定一个一个接口，生成的注解类需要实现这个接口，然后我们通过这个接口去完成注入的操作从而达到目的。\n```java\npublic interface ViewBind<T> {\n\tvoid inject(T t, Object obj);\n}\n```\n还需要一个类，提供给需要使用注解的activity，完成绑定操作，通过bind(this)方法，获取到注解类，调用inject方法注入。\n```java\npublic class ViewBinder {\n\n    private final static String SUFFIX = \"$$ViewBinder\";\n\n    public static void bind(Activity activity){\n        ViewBind proxyActivity = findProxyActivity(activity);\n        proxyActivity.inject(activity, activity);\n    }\n\n    public static void injectView(Object object, View view)\n    {\n        ViewBind proxyActivity = findProxyActivity(object);\n        proxyActivity.inject(object, view);\n    }\n\n    private static ViewBind findProxyActivity(Object activity){\n        try {\n            Class clazz = activity.getClass();\n            Class viewBindClazz = Class.forName(clazz.getName() + SUFFIX);\n            return (ViewBind) viewBindClazz.newInstance();\n        } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {\n            e.printStackTrace();\n        }\n        throw new RuntimeException(String.format(\"can not find %s, something error when compiler.\", activity.getClass().getSimpleName() + SUFFIX));\n    }\n\n}\n```\n##### compiler\n注解处理器，这是核心的模块。New Module，选择Java Library。\n在gradle中添加：\n```gradle\n    compile 'com.google.auto.service:auto-service:1.0-rc2'\n    compile 'com.squareup:javapoet:1.7.0'\n```\n前者是自动生成 META-INF/services/javax.annotation.processing.Processor文件的库，后者[JavaPoet](https://github.com/square/javapoet)是一个生成java代码的库，免去了我们拼字符串的繁琐。\n* **Processor类**\n```java\n/**\n * 使用 Google 的 auto-service 库可以自动生成 META-INF/services/javax.annotation.processing.Processor 文件\n */\n@AutoService(Processor.class)\npublic class BindProcessor extends AbstractProcessor{\n\n    //元素处理辅助类\n    private Elements elementUtils;\n\n    //日志辅助类\n    private Messager messager;\n\n    private Map<String, BindProxy> mProxyMap = new HashMap<String, BindProxy>();;\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n        elementUtils = processingEnv.getElementUtils();\n        messager = processingEnv.getMessager();\n    }\n\n    /**\n     * @return 指定哪些注解应该被注解处理器注册\n     */\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        HashSet<String> supportType = new HashSet<String>();\n        supportType.add(BindView.class.getCanonicalName());\n        return supportType;\n    }\n\n    /**\n     * @return 指定使用的 Java 版本。通常返回 SourceVersion.latestSupported()。\n     */\n    @Override\n    public SourceVersion getSupportedSourceVersion()\n    {\n        return SourceVersion.latestSupported();\n    }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        messager.printMessage(Diagnostic.Kind.NOTE, \"process...\");\n        //获取BindView注释的元素集合\n        Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(BindView.class);\n        if (elements == null || elements.size() < 1){\n            return true;\n        }\n        //遍历集合\n        for (Element element : elements){\n            //检查是否是作用于FIELD\n            if (checkElement(element)){\n                VariableElement variable = (VariableElement) element;\n                TypeElement typeElement = (TypeElement) element.getEnclosingElement();\n                String className = typeElement.getQualifiedName().toString();\n                //从缓存中取得BindProxy类,不存在则new\n                BindProxy proxy = mProxyMap.get(className);\n                if (proxy == null){\n                    proxy = new BindProxy(elementUtils, typeElement);\n                    mProxyMap.put(className, proxy);\n                }\n                BindView bindView = variable.getAnnotation(BindView.class);\n                proxy.injectInfo.put(bindView.value(), variable);\n            } else {\n                messager.printMessage(Diagnostic.Kind.ERROR, \"error...\");\n            }\n        }\n        //遍历mProxyMap 取出所有的BindProxy类 去生成代码\n        for (String key : mProxyMap.keySet()){\n            BindProxy proxy = mProxyMap.get(key);\n            try {\n                proxy.generateCode().writeTo(processingEnv.getFiler());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return true;\n    }\n\n    private boolean checkElement(Element element){\n        if (element.getKind() != ElementKind.FIELD)\n        {\n            messager.printMessage(Diagnostic.Kind.ERROR, \"%s must be declared on field.\", element);\n            return false;\n        }\n        return true;\n    }\n\n}\n```\n* **生成代码类**\n```java\n\npublic class BindProxy {\n\n\tpublic Map<Integer, VariableElement> injectInfo = new HashMap<>();\n\n\tprivate TypeElement element;\n\n\tprivate String packageName, className;\n\n\tprivate static final String PROXY = \"$$ViewBinder\";\n\n\tpublic BindProxy(Elements elements, TypeElement typeElement) {\n\t\telement = typeElement;\n\t\tPackageElement packageElement = elements.getPackageOf(typeElement);\n\t\tpackageName = packageElement.getQualifiedName().toString();\n\t\tclassName = typeElement.getSimpleName() + PROXY;\n\t}\n\n\tpublic JavaFile generateCode() {\n\n\t\t//生成方法代码\n\t\tMethodSpec.Builder injectMethodBuilder = MethodSpec.methodBuilder(\"inject\")\n\t\t\t\t.addModifiers(Modifier.PUBLIC)\n\t\t\t\t.addAnnotation(Override.class)\n\t\t\t\t.addParameter(TypeName.get(element.asType()), \"host\", Modifier.FINAL)\n\t\t\t\t.addParameter(TypeName.OBJECT, \"obj\");\n\n\t\t//在方法中插入一行findViewById代码,遍历所有的元素\n\t\tfor (int id : injectInfo.keySet()) {\n\t\t\tVariableElement element = injectInfo.get(id);\n\t\t\tString name = element.getSimpleName().toString();\n\t\t\tTypeMirror type = element.asType();\n\t\t\tinjectMethodBuilder.addStatement(\"host.$N = ($T)((($T) obj).findViewById($L))\"\n\t\t\t\t\t, name, type, TypeUtil.ANDROID_ACTIVITY, id);\n\t\t}\n\n\t\t//生成class代码\n\t\tTypeSpec clazz = TypeSpec.classBuilder(className)\n\t\t\t\t//这里添加的接口类,并添加了泛型\n\t\t\t\t.addSuperinterface(ParameterizedTypeName.get(TypeUtil.VIEWBIND, TypeName.get(element.asType())))\n\t\t\t\t.addModifiers(Modifier.PUBLIC)\n\t\t\t\t.addMethod(injectMethodBuilder.build())\n\t\t\t\t.build();\n\n\t\treturn JavaFile.builder(packageName, clazz).build();\n\t}\n\n}\n```\n##### 配置\n主要的代码就在上面，注释写的应该比较清楚了，剩下的就是对项目进行配置。\n我们需要在根项目的build.gradle中添加dependencies\n```gradle\n\tclasspath 'com.neenbedankt.gradle.plugins:android-\tapt:1.8'\n```\n在app的build.gradle中添加\n```gradle\n\tapply plugin: 'com.neenbedankt.android-apt'\n```\n然后添加dependencies\n```gradle\n\tcompile project(':api')\n    compile project(':annotation')\n    apt project(':compiler')\n```\n##### 效果\n然后运行或者build项目就可以看到注解生成的类，目录是build/generated/source/apt/debug/包名\n```java\npublic class MainActivity$$ViewBinder implements ViewBind<MainActivity> {\n  @Override\n  public void inject(final MainActivity host, Object obj) {\n    host.textView = (TextView)(((Activity) obj).findViewById(2131492942));\n  }\n}\n```\n\n#### 常见问题\n##### 编译报错\n在我开始尝试这个项目的时候，参考了很多别人的文章，都是正常的编码思路和源码，没有讲容易碰到的问题。我在参照别人写完demo，build的时候一直报错。\n```\nError:Execution failed for task ':app:compileDebugJavaWithJavac'.\n> java.lang.NullPointerException\n```\n这个错之前也碰到过，但是具体原因忘了，起初以为是gradle配置的问题，改来改去还是解决不了，搜索也解决不了。\n后来注释掉了processor中的部分代码，发现build成功。原来是Processor中异常了。\n所以报这种错的时候，检查一下自己的代码，肯定是有异常。\n\n##### 调试Processor\n当Processor出现问题的时候，最直观寻找问题的方法就是debug。\nDebug Processor步骤\n* 在Android studio中添加Remote Debugger，并确定port的设置是跟下面的参数一致\n* 在 gradle.properties文件中添加如下\n```\norg.gradle.parallel=true\norg.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005\n```\n然后添加断点，在你需要调试的地方，项目build的时候就可以调试了。\n\n##### 为什么要分开注解和处理器\n一方面是更好的解耦，我们的注解处理器可以用于其他项目。还有一个就是能避免65K方法数问题。\n\n#### 总结\n这个项目就是一个简单的APT demo，主要运用的就是注解的基础知道以及AbstractProcessor类和JavaPoet库生成Java代码，通过这个我们可以学习如何编写APT项目，实现起来并不复杂，但是注解处理器是一个非常强大的工具。整个的重心在于，通过这个我们能够知道有这么一种方式可以再编译期生成代码，简化我们的工作。更重要的是要有这么一个思路，可以去设计我们的架构，对架构实现更好的解耦，ARouter就是通过APT实现依赖反转，我也是抱着这些目的来学习注解。之后我会写运行时的注解处理器。\n\n#### 项目地址\n\nhttps://github.com/PengsongAndroid/MyAnnotation\n\n**参考：**\n[Java注解处理器](http://www.race604.com/annotation-processing/)\n[How to debug the apt AbstractProcessor code generation?](http://stackoverflow.com/questions/30959145/how-to-debug-the-apt-abstractprocessor-code-generation)\n[Android 如何编写基于编译时注解的项目](http://blog.csdn.net/lmj623565791/article/details/51931859)\n","source":"_posts/Android注解实践——打造编译时注解框架.md","raw":"---\ntitle: Android注解实践——打造编译时注解框架\ndate: 2017-04-8 15:33:40\ncategories: Android文章\ntags: Android, Annotation, 注解\n---\n最近一直在做项目的重构工作，因为是做组件化，正好看到阿里云开源一个路由框架[ARouter](https://github.com/alibaba/ARouter)。看了一下源码，发现是项目主要也是运用到了编译时注解的技术。联想到之前最早用过的[ButterKnife](https://github.com/JakeWharton/butterknife)，到现在的[Retrofit](https://github.com/square/retrofit)等等各种主流的开源框架，其实都有使用到这项强大技术，之前也只是简单了解了一下原理，这次就想自己也写一个这种框架，搞清楚实现原理。\n首先，注解处理器(Anonotation Processor)分为编译时(Compile time)注解和运行时(Runtime)通过反射机制运行的注解，因为编译期注解实际上是生成.java文件辅助我们实现功能，所以不会有效率上的损耗，上面提到的开源框架也都是基于这种基础实现的。\n这篇文章只涉及编译时注解(类似于[ButterKnife](https://github.com/JakeWharton/butterknife))，教大家如何打造一个简单的编译时注解框架，如何调试，和一些在实践中碰到的问题。\n<!-- more -->\n#### 基本概念\n注解处理器是Javac的一个工具，它用来在编译时扫描和处理注解，更多信息可以查看[官方文档](http://docs.oracle.com/javase/tutorial/java/annotations/index.html)。\n一个注解的注解处理器，以Java代码作为输出，生成文件（通常是.java文件）作为输出。这意味着你可以生成java代码，当然生成的.java代码是在新的文件中，你不能修改原有的Java类。但是我们可以生成辅助类，来帮助我们完成工作，就像[ButterKnife](https://github.com/JakeWharton/butterknife)这样，我们省去了findviewById的重复工作，仅需一行注解，他就能帮我们完成操作。我们掌握这项技术，也可以在之后的工作中减少重复无意义的工作，更重要的是注解能够帮我们更好的解耦我们的各个模块。\n##### 注解类型\n首先举一个我们最常见的注解：\n```java\n@Override\n```\n大家都知道这是重写的意思，我们具体看看它的代码。\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n```\n出现了两个东西，@Target、 @Retention，前者代表该注解可以作用于什么地方，后者代表要在什么级别保存该注解信息。我们看看枚举里支持的类型。\n```java\npublic enum ElementType {\n    /** Class, interface (including annotation type), or enum declaration */\n    TYPE,\n\n    /** Field declaration (includes enum constants) */\n    FIELD,\n\n    /** Method declaration */\n    METHOD,\n\n    /** Formal parameter declaration */\n    PARAMETER,\n\n    /** Constructor declaration */\n    CONSTRUCTOR,\n\n    /** Local variable declaration */\n    LOCAL_VARIABLE,\n\n    /** Annotation type declaration */\n    ANNOTATION_TYPE,\n\n    /** Package declaration */\n    PACKAGE,\n\n    /**\n     * Type parameter declaration\n     *\n     * @since 1.8\n     */\n    TYPE_PARAMETER,\n\n    /**\n     * Use of a type\n     *\n     * @since 1.8\n     */\n    TYPE_USE\n}\n```\n\n```java\npublic enum RetentionPolicy {\n    /**\n     * Annotations are to be discarded by the compiler.\n     */\n    SOURCE,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler\n     * but need not be retained by the VM at run time.  This is the default\n     * behavior.\n     */\n    CLASS,\n\n    /**\n     * Annotations are to be recorded in the class file by the compiler and\n     * retained by the VM at run time, so they may be read reflectively.\n     *\n     * @see java.lang.reflect.AnnotatedElement\n     */\n    RUNTIME\n}\n```\n上面贴出了枚举值，里面的注释也写的很清楚，我简单说一下RetentionPolicy，SOURCE是会被编译器丢弃的注解，CLASS是在编译器保存，RUNTIME是在运行期保留，可以通过反射获取到的。所以我们编译期注解框架的Retention是CLASS类型。\n##### AbstractProcessor\n接下来我们要了解一个注解的核心，[AbstractProcessor类](https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html)，它是一个抽象的注释处理器，设计来为大多数注解实践类提供方便的超类。我们所有的Processor API都是继承自AbstractProcessor类。\n我们继承AbstractProcessor类之后，需要实现四个方法：\n```java\npublic class MyProcessor extends AbstractProcessor {\n\n    @Override\n    public synchronized void init(ProcessingEnvironment env){ }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> annoations, RoundEnvironment env) { }\n\n    @Override\n    public Set<String> getSupportedAnnotationTypes() { }\n\n    @Override\n    public SourceVersion getSupportedSourceVersion() { }\n\n}\n```\n* **init(ProcessingEnvironment env)**：javac 会在 Processor 创建时调用并执行的初始化操作，该方法会传入 一个参数 ProcessingEnvironment env ，通过 env 可以访问 Elements、Types、Filer等工具类。\n* **getSupportedAnnotationTypes()**：返回需要注册的注解集合。\n* **getSupportedSourceVersion()**：返回支持的java版本，通常返回SourceVersion.latestSupported()。\n* **process(Set<? extends TypeElement> annoations, RoundEnvironment env)**：这个方法相当于Processor类的main方法，所有扫描和处理注解、生成.java文件的操作，都是在这里完成。\n\n#### 实践步骤\n了解了上面的基础知识，这里讲讲具体如何实现。我们的目的是通过注解实现替代我们findViewById的繁琐操作，类似于ButterKnife的@Bind操作。\n```java\n   @BindView(R.id.test_text)\n   TextView textView;\n```\n整个项目分为四个模块，app，annotation（注解），api，compiler（注解处理器）。\n首先讲一下整体的思路，在我们的Activity中，使用注解定义控件，在onCreate方法中，调用Api模块的bind(this)。bind方法内其实就是通过反射获取到注解处理器生成的辅助类，通过辅助类完成控件的初始化工作。\n\n##### annotation\n在项目中，New Module，选择Java Library，新建类，定义注解\n```java\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.FIELD)\npublic @interface BindView {\n\tint value();\n}\n```\n@BindView对成员变量进行注解，接收一个int类型的参数。\n\n##### api\nNew Module，选择Android Library，\n首先我们需要定一个一个接口，生成的注解类需要实现这个接口，然后我们通过这个接口去完成注入的操作从而达到目的。\n```java\npublic interface ViewBind<T> {\n\tvoid inject(T t, Object obj);\n}\n```\n还需要一个类，提供给需要使用注解的activity，完成绑定操作，通过bind(this)方法，获取到注解类，调用inject方法注入。\n```java\npublic class ViewBinder {\n\n    private final static String SUFFIX = \"$$ViewBinder\";\n\n    public static void bind(Activity activity){\n        ViewBind proxyActivity = findProxyActivity(activity);\n        proxyActivity.inject(activity, activity);\n    }\n\n    public static void injectView(Object object, View view)\n    {\n        ViewBind proxyActivity = findProxyActivity(object);\n        proxyActivity.inject(object, view);\n    }\n\n    private static ViewBind findProxyActivity(Object activity){\n        try {\n            Class clazz = activity.getClass();\n            Class viewBindClazz = Class.forName(clazz.getName() + SUFFIX);\n            return (ViewBind) viewBindClazz.newInstance();\n        } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {\n            e.printStackTrace();\n        }\n        throw new RuntimeException(String.format(\"can not find %s, something error when compiler.\", activity.getClass().getSimpleName() + SUFFIX));\n    }\n\n}\n```\n##### compiler\n注解处理器，这是核心的模块。New Module，选择Java Library。\n在gradle中添加：\n```gradle\n    compile 'com.google.auto.service:auto-service:1.0-rc2'\n    compile 'com.squareup:javapoet:1.7.0'\n```\n前者是自动生成 META-INF/services/javax.annotation.processing.Processor文件的库，后者[JavaPoet](https://github.com/square/javapoet)是一个生成java代码的库，免去了我们拼字符串的繁琐。\n* **Processor类**\n```java\n/**\n * 使用 Google 的 auto-service 库可以自动生成 META-INF/services/javax.annotation.processing.Processor 文件\n */\n@AutoService(Processor.class)\npublic class BindProcessor extends AbstractProcessor{\n\n    //元素处理辅助类\n    private Elements elementUtils;\n\n    //日志辅助类\n    private Messager messager;\n\n    private Map<String, BindProxy> mProxyMap = new HashMap<String, BindProxy>();;\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n        elementUtils = processingEnv.getElementUtils();\n        messager = processingEnv.getMessager();\n    }\n\n    /**\n     * @return 指定哪些注解应该被注解处理器注册\n     */\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        HashSet<String> supportType = new HashSet<String>();\n        supportType.add(BindView.class.getCanonicalName());\n        return supportType;\n    }\n\n    /**\n     * @return 指定使用的 Java 版本。通常返回 SourceVersion.latestSupported()。\n     */\n    @Override\n    public SourceVersion getSupportedSourceVersion()\n    {\n        return SourceVersion.latestSupported();\n    }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        messager.printMessage(Diagnostic.Kind.NOTE, \"process...\");\n        //获取BindView注释的元素集合\n        Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(BindView.class);\n        if (elements == null || elements.size() < 1){\n            return true;\n        }\n        //遍历集合\n        for (Element element : elements){\n            //检查是否是作用于FIELD\n            if (checkElement(element)){\n                VariableElement variable = (VariableElement) element;\n                TypeElement typeElement = (TypeElement) element.getEnclosingElement();\n                String className = typeElement.getQualifiedName().toString();\n                //从缓存中取得BindProxy类,不存在则new\n                BindProxy proxy = mProxyMap.get(className);\n                if (proxy == null){\n                    proxy = new BindProxy(elementUtils, typeElement);\n                    mProxyMap.put(className, proxy);\n                }\n                BindView bindView = variable.getAnnotation(BindView.class);\n                proxy.injectInfo.put(bindView.value(), variable);\n            } else {\n                messager.printMessage(Diagnostic.Kind.ERROR, \"error...\");\n            }\n        }\n        //遍历mProxyMap 取出所有的BindProxy类 去生成代码\n        for (String key : mProxyMap.keySet()){\n            BindProxy proxy = mProxyMap.get(key);\n            try {\n                proxy.generateCode().writeTo(processingEnv.getFiler());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return true;\n    }\n\n    private boolean checkElement(Element element){\n        if (element.getKind() != ElementKind.FIELD)\n        {\n            messager.printMessage(Diagnostic.Kind.ERROR, \"%s must be declared on field.\", element);\n            return false;\n        }\n        return true;\n    }\n\n}\n```\n* **生成代码类**\n```java\n\npublic class BindProxy {\n\n\tpublic Map<Integer, VariableElement> injectInfo = new HashMap<>();\n\n\tprivate TypeElement element;\n\n\tprivate String packageName, className;\n\n\tprivate static final String PROXY = \"$$ViewBinder\";\n\n\tpublic BindProxy(Elements elements, TypeElement typeElement) {\n\t\telement = typeElement;\n\t\tPackageElement packageElement = elements.getPackageOf(typeElement);\n\t\tpackageName = packageElement.getQualifiedName().toString();\n\t\tclassName = typeElement.getSimpleName() + PROXY;\n\t}\n\n\tpublic JavaFile generateCode() {\n\n\t\t//生成方法代码\n\t\tMethodSpec.Builder injectMethodBuilder = MethodSpec.methodBuilder(\"inject\")\n\t\t\t\t.addModifiers(Modifier.PUBLIC)\n\t\t\t\t.addAnnotation(Override.class)\n\t\t\t\t.addParameter(TypeName.get(element.asType()), \"host\", Modifier.FINAL)\n\t\t\t\t.addParameter(TypeName.OBJECT, \"obj\");\n\n\t\t//在方法中插入一行findViewById代码,遍历所有的元素\n\t\tfor (int id : injectInfo.keySet()) {\n\t\t\tVariableElement element = injectInfo.get(id);\n\t\t\tString name = element.getSimpleName().toString();\n\t\t\tTypeMirror type = element.asType();\n\t\t\tinjectMethodBuilder.addStatement(\"host.$N = ($T)((($T) obj).findViewById($L))\"\n\t\t\t\t\t, name, type, TypeUtil.ANDROID_ACTIVITY, id);\n\t\t}\n\n\t\t//生成class代码\n\t\tTypeSpec clazz = TypeSpec.classBuilder(className)\n\t\t\t\t//这里添加的接口类,并添加了泛型\n\t\t\t\t.addSuperinterface(ParameterizedTypeName.get(TypeUtil.VIEWBIND, TypeName.get(element.asType())))\n\t\t\t\t.addModifiers(Modifier.PUBLIC)\n\t\t\t\t.addMethod(injectMethodBuilder.build())\n\t\t\t\t.build();\n\n\t\treturn JavaFile.builder(packageName, clazz).build();\n\t}\n\n}\n```\n##### 配置\n主要的代码就在上面，注释写的应该比较清楚了，剩下的就是对项目进行配置。\n我们需要在根项目的build.gradle中添加dependencies\n```gradle\n\tclasspath 'com.neenbedankt.gradle.plugins:android-\tapt:1.8'\n```\n在app的build.gradle中添加\n```gradle\n\tapply plugin: 'com.neenbedankt.android-apt'\n```\n然后添加dependencies\n```gradle\n\tcompile project(':api')\n    compile project(':annotation')\n    apt project(':compiler')\n```\n##### 效果\n然后运行或者build项目就可以看到注解生成的类，目录是build/generated/source/apt/debug/包名\n```java\npublic class MainActivity$$ViewBinder implements ViewBind<MainActivity> {\n  @Override\n  public void inject(final MainActivity host, Object obj) {\n    host.textView = (TextView)(((Activity) obj).findViewById(2131492942));\n  }\n}\n```\n\n#### 常见问题\n##### 编译报错\n在我开始尝试这个项目的时候，参考了很多别人的文章，都是正常的编码思路和源码，没有讲容易碰到的问题。我在参照别人写完demo，build的时候一直报错。\n```\nError:Execution failed for task ':app:compileDebugJavaWithJavac'.\n> java.lang.NullPointerException\n```\n这个错之前也碰到过，但是具体原因忘了，起初以为是gradle配置的问题，改来改去还是解决不了，搜索也解决不了。\n后来注释掉了processor中的部分代码，发现build成功。原来是Processor中异常了。\n所以报这种错的时候，检查一下自己的代码，肯定是有异常。\n\n##### 调试Processor\n当Processor出现问题的时候，最直观寻找问题的方法就是debug。\nDebug Processor步骤\n* 在Android studio中添加Remote Debugger，并确定port的设置是跟下面的参数一致\n* 在 gradle.properties文件中添加如下\n```\norg.gradle.parallel=true\norg.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005\n```\n然后添加断点，在你需要调试的地方，项目build的时候就可以调试了。\n\n##### 为什么要分开注解和处理器\n一方面是更好的解耦，我们的注解处理器可以用于其他项目。还有一个就是能避免65K方法数问题。\n\n#### 总结\n这个项目就是一个简单的APT demo，主要运用的就是注解的基础知道以及AbstractProcessor类和JavaPoet库生成Java代码，通过这个我们可以学习如何编写APT项目，实现起来并不复杂，但是注解处理器是一个非常强大的工具。整个的重心在于，通过这个我们能够知道有这么一种方式可以再编译期生成代码，简化我们的工作。更重要的是要有这么一个思路，可以去设计我们的架构，对架构实现更好的解耦，ARouter就是通过APT实现依赖反转，我也是抱着这些目的来学习注解。之后我会写运行时的注解处理器。\n\n#### 项目地址\n\nhttps://github.com/PengsongAndroid/MyAnnotation\n\n**参考：**\n[Java注解处理器](http://www.race604.com/annotation-processing/)\n[How to debug the apt AbstractProcessor code generation?](http://stackoverflow.com/questions/30959145/how-to-debug-the-apt-abstractprocessor-code-generation)\n[Android 如何编写基于编译时注解的项目](http://blog.csdn.net/lmj623565791/article/details/51931859)\n","slug":"Android注解实践——打造编译时注解框架","published":1,"updated":"2017-05-24T09:04:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpw7fl240018gcl9aiorh6z4","content":"<p>最近一直在做项目的重构工作，因为是做组件化，正好看到阿里云开源一个路由框架<a href=\"https://github.com/alibaba/ARouter\">ARouter</a>。看了一下源码，发现是项目主要也是运用到了编译时注解的技术。联想到之前最早用过的<a href=\"https://github.com/JakeWharton/butterknife\">ButterKnife</a>，到现在的<a href=\"https://github.com/square/retrofit\">Retrofit</a>等等各种主流的开源框架，其实都有使用到这项强大技术，之前也只是简单了解了一下原理，这次就想自己也写一个这种框架，搞清楚实现原理。<br>首先，注解处理器(Anonotation Processor)分为编译时(Compile time)注解和运行时(Runtime)通过反射机制运行的注解，因为编译期注解实际上是生成.java文件辅助我们实现功能，所以不会有效率上的损耗，上面提到的开源框架也都是基于这种基础实现的。<br>这篇文章只涉及编译时注解(类似于<a href=\"https://github.com/JakeWharton/butterknife\">ButterKnife</a>)，教大家如何打造一个简单的编译时注解框架，如何调试，和一些在实践中碰到的问题。<br><a id=\"more\"></a></p>\n<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><p>注解处理器是Javac的一个工具，它用来在编译时扫描和处理注解，更多信息可以查看<a href=\"http://docs.oracle.com/javase/tutorial/java/annotations/index.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>。<br>一个注解的注解处理器，以Java代码作为输出，生成文件（通常是.java文件）作为输出。这意味着你可以生成java代码，当然生成的.java代码是在新的文件中，你不能修改原有的Java类。但是我们可以生成辅助类，来帮助我们完成工作，就像<a href=\"https://github.com/JakeWharton/butterknife\">ButterKnife</a>这样，我们省去了findviewById的重复工作，仅需一行注解，他就能帮我们完成操作。我们掌握这项技术，也可以在之后的工作中减少重复无意义的工作，更重要的是注解能够帮我们更好的解耦我们的各个模块。</p>\n<h5 id=\"注解类型\"><a href=\"#注解类型\" class=\"headerlink\" title=\"注解类型\"></a>注解类型</h5><p>首先举一个我们最常见的注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br></pre></td></tr></table></figure></p>\n<p>大家都知道这是重写的意思，我们具体看看它的代码。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Override &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>出现了两个东西，@Target、 @Retention，前者代表该注解可以作用于什么地方，后者代表要在什么级别保存该注解信息。我们看看枚举里支持的类型。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> ElementType &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class=\"line\">    TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Field declaration (includes enum constants) */</span></span><br><span class=\"line\">    FIELD,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Method declaration */</span></span><br><span class=\"line\">    METHOD,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Formal parameter declaration */</span></span><br><span class=\"line\">    PARAMETER,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Constructor declaration */</span></span><br><span class=\"line\">    CONSTRUCTOR,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Local variable declaration */</span></span><br><span class=\"line\">    LOCAL_VARIABLE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Annotation type declaration */</span></span><br><span class=\"line\">    ANNOTATION_TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Package declaration */</span></span><br><span class=\"line\">    PACKAGE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Type parameter declaration</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 1.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    TYPE_PARAMETER,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Use of a type</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 1.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    TYPE_USE</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> RetentionPolicy &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Annotations are to be discarded by the compiler.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    SOURCE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class=\"line\"><span class=\"comment\">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class=\"line\"><span class=\"comment\">     * behavior.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    CLASS,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class=\"line\"><span class=\"comment\">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    RUNTIME</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面贴出了枚举值，里面的注释也写的很清楚，我简单说一下RetentionPolicy，SOURCE是会被编译器丢弃的注解，CLASS是在编译器保存，RUNTIME是在运行期保留，可以通过反射获取到的。所以我们编译期注解框架的Retention是CLASS类型。</p>\n<h5 id=\"AbstractProcessor\"><a href=\"#AbstractProcessor\" class=\"headerlink\" title=\"AbstractProcessor\"></a>AbstractProcessor</h5><p>接下来我们要了解一个注解的核心，<a href=\"https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html\" target=\"_blank\" rel=\"noopener\">AbstractProcessor类</a>，它是一个抽象的注释处理器，设计来为大多数注解实践类提供方便的超类。我们所有的Processor API都是继承自AbstractProcessor类。<br>我们继承AbstractProcessor类之后，需要实现四个方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment env)</span></span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SourceVersion <span class=\"title\">getSupportedSourceVersion</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>init(ProcessingEnvironment env)</strong>：javac 会在 Processor 创建时调用并执行的初始化操作，该方法会传入 一个参数 ProcessingEnvironment env ，通过 env 可以访问 Elements、Types、Filer等工具类。</li>\n<li><strong>getSupportedAnnotationTypes()</strong>：返回需要注册的注解集合。</li>\n<li><strong>getSupportedSourceVersion()</strong>：返回支持的java版本，通常返回SourceVersion.latestSupported()。</li>\n<li><strong>process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env)</strong>：这个方法相当于Processor类的main方法，所有扫描和处理注解、生成.java文件的操作，都是在这里完成。</li>\n</ul>\n<h4 id=\"实践步骤\"><a href=\"#实践步骤\" class=\"headerlink\" title=\"实践步骤\"></a>实践步骤</h4><p>了解了上面的基础知识，这里讲讲具体如何实现。我们的目的是通过注解实现替代我们findViewById的繁琐操作，类似于ButterKnife的@Bind操作。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@BindView</span>(R.id.test_text)</span><br><span class=\"line\">TextView textView;</span><br></pre></td></tr></table></figure></p>\n<p>整个项目分为四个模块，app，annotation（注解），api，compiler（注解处理器）。<br>首先讲一下整体的思路，在我们的Activity中，使用注解定义控件，在onCreate方法中，调用Api模块的bind(this)。bind方法内其实就是通过反射获取到注解处理器生成的辅助类，通过辅助类完成控件的初始化工作。</p>\n<h5 id=\"annotation\"><a href=\"#annotation\" class=\"headerlink\" title=\"annotation\"></a>annotation</h5><p>在项目中，New Module，选择Java Library，新建类，定义注解<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.FIELD)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> BindView &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>@BindView对成员变量进行注解，接收一个int类型的参数。</p>\n<h5 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h5><p>New Module，选择Android Library，<br>首先我们需要定一个一个接口，生成的注解类需要实现这个接口，然后我们通过这个接口去完成注入的操作从而达到目的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ViewBind</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(T t, Object obj)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还需要一个类，提供给需要使用注解的activity，完成绑定操作，通过bind(this)方法，获取到注解类，调用inject方法注入。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewBinder</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String SUFFIX = <span class=\"string\">\"$$ViewBinder\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bind</span><span class=\"params\">(Activity activity)</span></span>&#123;</span><br><span class=\"line\">        ViewBind proxyActivity = findProxyActivity(activity);</span><br><span class=\"line\">        proxyActivity.inject(activity, activity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">injectView</span><span class=\"params\">(Object object, View view)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        ViewBind proxyActivity = findProxyActivity(object);</span><br><span class=\"line\">        proxyActivity.inject(object, view);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ViewBind <span class=\"title\">findProxyActivity</span><span class=\"params\">(Object activity)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class clazz = activity.getClass();</span><br><span class=\"line\">            Class viewBindClazz = Class.forName(clazz.getName() + SUFFIX);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (ViewBind) viewBindClazz.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(String.format(<span class=\"string\">\"can not find %s, something error when compiler.\"</span>, activity.getClass().getSimpleName() + SUFFIX));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"compiler\"><a href=\"#compiler\" class=\"headerlink\" title=\"compiler\"></a>compiler</h5><p>注解处理器，这是核心的模块。New Module，选择Java Library。<br>在gradle中添加：<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">compile</span> <span class=\"string\">'com.google.auto.service:auto-service:1.0-rc2'</span></span><br><span class=\"line\"><span class=\"keyword\">compile</span> <span class=\"string\">'com.squareup:javapoet:1.7.0'</span></span><br></pre></td></tr></table></figure></p>\n<p>前者是自动生成 META-INF/services/javax.annotation.processing.Processor文件的库，后者<a href=\"https://github.com/square/javapoet\">JavaPoet</a>是一个生成java代码的库，免去了我们拼字符串的繁琐。</p>\n<ul>\n<li><p><strong>Processor类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用 Google 的 auto-service 库可以自动生成 META-INF/services/javax.annotation.processing.Processor 文件</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@AutoService</span>(Processor.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BindProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//元素处理辅助类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Elements elementUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//日志辅助类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messager messager;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, BindProxy&gt; mProxyMap = <span class=\"keyword\">new</span> HashMap&lt;String, BindProxy&gt;();;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnv);</span><br><span class=\"line\">        elementUtils = processingEnv.getElementUtils();</span><br><span class=\"line\">        messager = processingEnv.getMessager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 指定哪些注解应该被注解处理器注册</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        HashSet&lt;String&gt; supportType = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">        supportType.add(BindView.class.getCanonicalName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> supportType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 指定使用的 Java 版本。通常返回 SourceVersion.latestSupported()。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SourceVersion <span class=\"title\">getSupportedSourceVersion</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SourceVersion.latestSupported();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class=\"line\">        messager.printMessage(Diagnostic.Kind.NOTE, <span class=\"string\">\"process...\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//获取BindView注释的元素集合</span></span><br><span class=\"line\">        Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(BindView.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elements == <span class=\"keyword\">null</span> || elements.size() &lt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历集合</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Element element : elements)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//检查是否是作用于FIELD</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (checkElement(element))&#123;</span><br><span class=\"line\">                VariableElement variable = (VariableElement) element;</span><br><span class=\"line\">                TypeElement typeElement = (TypeElement) element.getEnclosingElement();</span><br><span class=\"line\">                String className = typeElement.getQualifiedName().toString();</span><br><span class=\"line\">                <span class=\"comment\">//从缓存中取得BindProxy类,不存在则new</span></span><br><span class=\"line\">                BindProxy proxy = mProxyMap.get(className);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (proxy == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    proxy = <span class=\"keyword\">new</span> BindProxy(elementUtils, typeElement);</span><br><span class=\"line\">                    mProxyMap.put(className, proxy);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                BindView bindView = variable.getAnnotation(BindView.class);</span><br><span class=\"line\">                proxy.injectInfo.put(bindView.value(), variable);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                messager.printMessage(Diagnostic.Kind.ERROR, <span class=\"string\">\"error...\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历mProxyMap 取出所有的BindProxy类 去生成代码</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : mProxyMap.keySet())&#123;</span><br><span class=\"line\">            BindProxy proxy = mProxyMap.get(key);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                proxy.generateCode().writeTo(processingEnv.getFiler());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">checkElement</span><span class=\"params\">(Element element)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (element.getKind() != ElementKind.FIELD)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            messager.printMessage(Diagnostic.Kind.ERROR, <span class=\"string\">\"%s must be declared on field.\"</span>, element);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>生成代码类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BindProxy</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Map&lt;Integer, VariableElement&gt; injectInfo = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> TypeElement element;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String packageName, className;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String PROXY = <span class=\"string\">\"$$ViewBinder\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BindProxy</span><span class=\"params\">(Elements elements, TypeElement typeElement)</span> </span>&#123;</span><br><span class=\"line\">\t\telement = typeElement;</span><br><span class=\"line\">\t\tPackageElement packageElement = elements.getPackageOf(typeElement);</span><br><span class=\"line\">\t\tpackageName = packageElement.getQualifiedName().toString();</span><br><span class=\"line\">\t\tclassName = typeElement.getSimpleName() + PROXY;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> JavaFile <span class=\"title\">generateCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//生成方法代码</span></span><br><span class=\"line\">\t\tMethodSpec.Builder injectMethodBuilder = MethodSpec.methodBuilder(<span class=\"string\">\"inject\"</span>)</span><br><span class=\"line\">\t\t\t\t.addModifiers(Modifier.PUBLIC)</span><br><span class=\"line\">\t\t\t\t.addAnnotation(Override.class)</span><br><span class=\"line\">\t\t\t\t.addParameter(TypeName.get(element.asType()), <span class=\"string\">\"host\"</span>, Modifier.FINAL)</span><br><span class=\"line\">\t\t\t\t.addParameter(TypeName.OBJECT, <span class=\"string\">\"obj\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//在方法中插入一行findViewById代码,遍历所有的元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> id : injectInfo.keySet()) &#123;</span><br><span class=\"line\">\t\t\tVariableElement element = injectInfo.get(id);</span><br><span class=\"line\">\t\t\tString name = element.getSimpleName().toString();</span><br><span class=\"line\">\t\t\tTypeMirror type = element.asType();</span><br><span class=\"line\">\t\t\tinjectMethodBuilder.addStatement(<span class=\"string\">\"host.$N = ($T)((($T) obj).findViewById($L))\"</span></span><br><span class=\"line\">\t\t\t\t\t, name, type, TypeUtil.ANDROID_ACTIVITY, id);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//生成class代码</span></span><br><span class=\"line\">\t\tTypeSpec clazz = TypeSpec.classBuilder(className)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//这里添加的接口类,并添加了泛型</span></span><br><span class=\"line\">\t\t\t\t.addSuperinterface(ParameterizedTypeName.get(TypeUtil.VIEWBIND, TypeName.get(element.asType())))</span><br><span class=\"line\">\t\t\t\t.addModifiers(Modifier.PUBLIC)</span><br><span class=\"line\">\t\t\t\t.addMethod(injectMethodBuilder.build())</span><br><span class=\"line\">\t\t\t\t.build();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> JavaFile.builder(packageName, clazz).build();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h5><p>主要的代码就在上面，注释写的应该比较清楚了，剩下的就是对项目进行配置。<br>我们需要在根项目的build.gradle中添加dependencies<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">classpath</span> <span class=\"string\">'com.neenbedankt.gradle.plugins:android-\tapt:1.8'</span></span><br></pre></td></tr></table></figure></p>\n<p>在app的build.gradle中添加<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: <span class=\"string\">'com.neenbedankt.android-apt'</span></span><br></pre></td></tr></table></figure></p>\n<p>然后添加dependencies<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':api'</span>)</span><br><span class=\"line\">   <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':annotation'</span>)</span><br><span class=\"line\">   apt <span class=\"keyword\">project</span>(<span class=\"string\">':compiler'</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h5><p>然后运行或者build项目就可以看到注解生成的类，目录是build/generated/source/apt/debug/包名<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>$$<span class=\"title\">ViewBinder</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewBind</span>&lt;<span class=\"title\">MainActivity</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(<span class=\"keyword\">final</span> MainActivity host, Object obj)</span> </span>&#123;</span><br><span class=\"line\">    host.textView = (TextView)(((Activity) obj).findViewById(<span class=\"number\">2131492942</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h4><h5 id=\"编译报错\"><a href=\"#编译报错\" class=\"headerlink\" title=\"编译报错\"></a>编译报错</h5><p>在我开始尝试这个项目的时候，参考了很多别人的文章，都是正常的编码思路和源码，没有讲容易碰到的问题。我在参照别人写完demo，build的时候一直报错。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error:Execution failed for task &apos;:app:compileDebugJavaWithJavac&apos;.</span><br><span class=\"line\">&gt; java.lang.NullPointerException</span><br></pre></td></tr></table></figure></p>\n<p>这个错之前也碰到过，但是具体原因忘了，起初以为是gradle配置的问题，改来改去还是解决不了，搜索也解决不了。<br>后来注释掉了processor中的部分代码，发现build成功。原来是Processor中异常了。<br>所以报这种错的时候，检查一下自己的代码，肯定是有异常。</p>\n<h5 id=\"调试Processor\"><a href=\"#调试Processor\" class=\"headerlink\" title=\"调试Processor\"></a>调试Processor</h5><p>当Processor出现问题的时候，最直观寻找问题的方法就是debug。<br>Debug Processor步骤</p>\n<ul>\n<li>在Android studio中添加Remote Debugger，并确定port的设置是跟下面的参数一致</li>\n<li>在 gradle.properties文件中添加如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.gradle.parallel=true</span><br><span class=\"line\">org.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后添加断点，在你需要调试的地方，项目build的时候就可以调试了。</p>\n<h5 id=\"为什么要分开注解和处理器\"><a href=\"#为什么要分开注解和处理器\" class=\"headerlink\" title=\"为什么要分开注解和处理器\"></a>为什么要分开注解和处理器</h5><p>一方面是更好的解耦，我们的注解处理器可以用于其他项目。还有一个就是能避免65K方法数问题。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这个项目就是一个简单的APT demo，主要运用的就是注解的基础知道以及AbstractProcessor类和JavaPoet库生成Java代码，通过这个我们可以学习如何编写APT项目，实现起来并不复杂，但是注解处理器是一个非常强大的工具。整个的重心在于，通过这个我们能够知道有这么一种方式可以再编译期生成代码，简化我们的工作。更重要的是要有这么一个思路，可以去设计我们的架构，对架构实现更好的解耦，ARouter就是通过APT实现依赖反转，我也是抱着这些目的来学习注解。之后我会写运行时的注解处理器。</p>\n<h4 id=\"项目地址\"><a href=\"#项目地址\" class=\"headerlink\" title=\"项目地址\"></a>项目地址</h4><p><a href=\"https://github.com/PengsongAndroid/MyAnnotation\">https://github.com/PengsongAndroid/MyAnnotation</a></p>\n<p><strong>参考：</strong><br><a href=\"http://www.race604.com/annotation-processing/\" target=\"_blank\" rel=\"noopener\">Java注解处理器</a><br><a href=\"http://stackoverflow.com/questions/30959145/how-to-debug-the-apt-abstractprocessor-code-generation\" target=\"_blank\" rel=\"noopener\">How to debug the apt AbstractProcessor code generation?</a><br><a href=\"http://blog.csdn.net/lmj623565791/article/details/51931859\" target=\"_blank\" rel=\"noopener\">Android 如何编写基于编译时注解的项目</a></p>\n","site":{"data":{}},"excerpt":"<p>最近一直在做项目的重构工作，因为是做组件化，正好看到阿里云开源一个路由框架<a href=\"https://github.com/alibaba/ARouter\">ARouter</a>。看了一下源码，发现是项目主要也是运用到了编译时注解的技术。联想到之前最早用过的<a href=\"https://github.com/JakeWharton/butterknife\">ButterKnife</a>，到现在的<a href=\"https://github.com/square/retrofit\">Retrofit</a>等等各种主流的开源框架，其实都有使用到这项强大技术，之前也只是简单了解了一下原理，这次就想自己也写一个这种框架，搞清楚实现原理。<br>首先，注解处理器(Anonotation Processor)分为编译时(Compile time)注解和运行时(Runtime)通过反射机制运行的注解，因为编译期注解实际上是生成.java文件辅助我们实现功能，所以不会有效率上的损耗，上面提到的开源框架也都是基于这种基础实现的。<br>这篇文章只涉及编译时注解(类似于<a href=\"https://github.com/JakeWharton/butterknife\">ButterKnife</a>)，教大家如何打造一个简单的编译时注解框架，如何调试，和一些在实践中碰到的问题。<br>","more":"</p>\n<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><p>注解处理器是Javac的一个工具，它用来在编译时扫描和处理注解，更多信息可以查看<a href=\"http://docs.oracle.com/javase/tutorial/java/annotations/index.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>。<br>一个注解的注解处理器，以Java代码作为输出，生成文件（通常是.java文件）作为输出。这意味着你可以生成java代码，当然生成的.java代码是在新的文件中，你不能修改原有的Java类。但是我们可以生成辅助类，来帮助我们完成工作，就像<a href=\"https://github.com/JakeWharton/butterknife\">ButterKnife</a>这样，我们省去了findviewById的重复工作，仅需一行注解，他就能帮我们完成操作。我们掌握这项技术，也可以在之后的工作中减少重复无意义的工作，更重要的是注解能够帮我们更好的解耦我们的各个模块。</p>\n<h5 id=\"注解类型\"><a href=\"#注解类型\" class=\"headerlink\" title=\"注解类型\"></a>注解类型</h5><p>首先举一个我们最常见的注解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br></pre></td></tr></table></figure></p>\n<p>大家都知道这是重写的意思，我们具体看看它的代码。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Override &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>出现了两个东西，@Target、 @Retention，前者代表该注解可以作用于什么地方，后者代表要在什么级别保存该注解信息。我们看看枚举里支持的类型。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> ElementType &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class=\"line\">    TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Field declaration (includes enum constants) */</span></span><br><span class=\"line\">    FIELD,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Method declaration */</span></span><br><span class=\"line\">    METHOD,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Formal parameter declaration */</span></span><br><span class=\"line\">    PARAMETER,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Constructor declaration */</span></span><br><span class=\"line\">    CONSTRUCTOR,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Local variable declaration */</span></span><br><span class=\"line\">    LOCAL_VARIABLE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Annotation type declaration */</span></span><br><span class=\"line\">    ANNOTATION_TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Package declaration */</span></span><br><span class=\"line\">    PACKAGE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Type parameter declaration</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 1.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    TYPE_PARAMETER,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Use of a type</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 1.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    TYPE_USE</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> RetentionPolicy &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Annotations are to be discarded by the compiler.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    SOURCE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class=\"line\"><span class=\"comment\">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class=\"line\"><span class=\"comment\">     * behavior.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    CLASS,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class=\"line\"><span class=\"comment\">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    RUNTIME</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面贴出了枚举值，里面的注释也写的很清楚，我简单说一下RetentionPolicy，SOURCE是会被编译器丢弃的注解，CLASS是在编译器保存，RUNTIME是在运行期保留，可以通过反射获取到的。所以我们编译期注解框架的Retention是CLASS类型。</p>\n<h5 id=\"AbstractProcessor\"><a href=\"#AbstractProcessor\" class=\"headerlink\" title=\"AbstractProcessor\"></a>AbstractProcessor</h5><p>接下来我们要了解一个注解的核心，<a href=\"https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html\" target=\"_blank\" rel=\"noopener\">AbstractProcessor类</a>，它是一个抽象的注释处理器，设计来为大多数注解实践类提供方便的超类。我们所有的Processor API都是继承自AbstractProcessor类。<br>我们继承AbstractProcessor类之后，需要实现四个方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment env)</span></span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env)</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SourceVersion <span class=\"title\">getSupportedSourceVersion</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>init(ProcessingEnvironment env)</strong>：javac 会在 Processor 创建时调用并执行的初始化操作，该方法会传入 一个参数 ProcessingEnvironment env ，通过 env 可以访问 Elements、Types、Filer等工具类。</li>\n<li><strong>getSupportedAnnotationTypes()</strong>：返回需要注册的注解集合。</li>\n<li><strong>getSupportedSourceVersion()</strong>：返回支持的java版本，通常返回SourceVersion.latestSupported()。</li>\n<li><strong>process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env)</strong>：这个方法相当于Processor类的main方法，所有扫描和处理注解、生成.java文件的操作，都是在这里完成。</li>\n</ul>\n<h4 id=\"实践步骤\"><a href=\"#实践步骤\" class=\"headerlink\" title=\"实践步骤\"></a>实践步骤</h4><p>了解了上面的基础知识，这里讲讲具体如何实现。我们的目的是通过注解实现替代我们findViewById的繁琐操作，类似于ButterKnife的@Bind操作。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@BindView</span>(R.id.test_text)</span><br><span class=\"line\">TextView textView;</span><br></pre></td></tr></table></figure></p>\n<p>整个项目分为四个模块，app，annotation（注解），api，compiler（注解处理器）。<br>首先讲一下整体的思路，在我们的Activity中，使用注解定义控件，在onCreate方法中，调用Api模块的bind(this)。bind方法内其实就是通过反射获取到注解处理器生成的辅助类，通过辅助类完成控件的初始化工作。</p>\n<h5 id=\"annotation\"><a href=\"#annotation\" class=\"headerlink\" title=\"annotation\"></a>annotation</h5><p>在项目中，New Module，选择Java Library，新建类，定义注解<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.FIELD)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> BindView &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>@BindView对成员变量进行注解，接收一个int类型的参数。</p>\n<h5 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h5><p>New Module，选择Android Library，<br>首先我们需要定一个一个接口，生成的注解类需要实现这个接口，然后我们通过这个接口去完成注入的操作从而达到目的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ViewBind</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(T t, Object obj)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还需要一个类，提供给需要使用注解的activity，完成绑定操作，通过bind(this)方法，获取到注解类，调用inject方法注入。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewBinder</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String SUFFIX = <span class=\"string\">\"$$ViewBinder\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bind</span><span class=\"params\">(Activity activity)</span></span>&#123;</span><br><span class=\"line\">        ViewBind proxyActivity = findProxyActivity(activity);</span><br><span class=\"line\">        proxyActivity.inject(activity, activity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">injectView</span><span class=\"params\">(Object object, View view)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        ViewBind proxyActivity = findProxyActivity(object);</span><br><span class=\"line\">        proxyActivity.inject(object, view);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ViewBind <span class=\"title\">findProxyActivity</span><span class=\"params\">(Object activity)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class clazz = activity.getClass();</span><br><span class=\"line\">            Class viewBindClazz = Class.forName(clazz.getName() + SUFFIX);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (ViewBind) viewBindClazz.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(String.format(<span class=\"string\">\"can not find %s, something error when compiler.\"</span>, activity.getClass().getSimpleName() + SUFFIX));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"compiler\"><a href=\"#compiler\" class=\"headerlink\" title=\"compiler\"></a>compiler</h5><p>注解处理器，这是核心的模块。New Module，选择Java Library。<br>在gradle中添加：<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">compile</span> <span class=\"string\">'com.google.auto.service:auto-service:1.0-rc2'</span></span><br><span class=\"line\"><span class=\"keyword\">compile</span> <span class=\"string\">'com.squareup:javapoet:1.7.0'</span></span><br></pre></td></tr></table></figure></p>\n<p>前者是自动生成 META-INF/services/javax.annotation.processing.Processor文件的库，后者<a href=\"https://github.com/square/javapoet\">JavaPoet</a>是一个生成java代码的库，免去了我们拼字符串的繁琐。</p>\n<ul>\n<li><p><strong>Processor类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用 Google 的 auto-service 库可以自动生成 META-INF/services/javax.annotation.processing.Processor 文件</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@AutoService</span>(Processor.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BindProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//元素处理辅助类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Elements elementUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//日志辅助类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messager messager;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, BindProxy&gt; mProxyMap = <span class=\"keyword\">new</span> HashMap&lt;String, BindProxy&gt;();;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnv);</span><br><span class=\"line\">        elementUtils = processingEnv.getElementUtils();</span><br><span class=\"line\">        messager = processingEnv.getMessager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 指定哪些注解应该被注解处理器注册</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        HashSet&lt;String&gt; supportType = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">        supportType.add(BindView.class.getCanonicalName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> supportType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 指定使用的 Java 版本。通常返回 SourceVersion.latestSupported()。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SourceVersion <span class=\"title\">getSupportedSourceVersion</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SourceVersion.latestSupported();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class=\"line\">        messager.printMessage(Diagnostic.Kind.NOTE, <span class=\"string\">\"process...\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//获取BindView注释的元素集合</span></span><br><span class=\"line\">        Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(BindView.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elements == <span class=\"keyword\">null</span> || elements.size() &lt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历集合</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Element element : elements)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//检查是否是作用于FIELD</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (checkElement(element))&#123;</span><br><span class=\"line\">                VariableElement variable = (VariableElement) element;</span><br><span class=\"line\">                TypeElement typeElement = (TypeElement) element.getEnclosingElement();</span><br><span class=\"line\">                String className = typeElement.getQualifiedName().toString();</span><br><span class=\"line\">                <span class=\"comment\">//从缓存中取得BindProxy类,不存在则new</span></span><br><span class=\"line\">                BindProxy proxy = mProxyMap.get(className);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (proxy == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    proxy = <span class=\"keyword\">new</span> BindProxy(elementUtils, typeElement);</span><br><span class=\"line\">                    mProxyMap.put(className, proxy);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                BindView bindView = variable.getAnnotation(BindView.class);</span><br><span class=\"line\">                proxy.injectInfo.put(bindView.value(), variable);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                messager.printMessage(Diagnostic.Kind.ERROR, <span class=\"string\">\"error...\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历mProxyMap 取出所有的BindProxy类 去生成代码</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : mProxyMap.keySet())&#123;</span><br><span class=\"line\">            BindProxy proxy = mProxyMap.get(key);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                proxy.generateCode().writeTo(processingEnv.getFiler());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">checkElement</span><span class=\"params\">(Element element)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (element.getKind() != ElementKind.FIELD)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            messager.printMessage(Diagnostic.Kind.ERROR, <span class=\"string\">\"%s must be declared on field.\"</span>, element);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>生成代码类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BindProxy</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Map&lt;Integer, VariableElement&gt; injectInfo = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> TypeElement element;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String packageName, className;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String PROXY = <span class=\"string\">\"$$ViewBinder\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BindProxy</span><span class=\"params\">(Elements elements, TypeElement typeElement)</span> </span>&#123;</span><br><span class=\"line\">\t\telement = typeElement;</span><br><span class=\"line\">\t\tPackageElement packageElement = elements.getPackageOf(typeElement);</span><br><span class=\"line\">\t\tpackageName = packageElement.getQualifiedName().toString();</span><br><span class=\"line\">\t\tclassName = typeElement.getSimpleName() + PROXY;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> JavaFile <span class=\"title\">generateCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//生成方法代码</span></span><br><span class=\"line\">\t\tMethodSpec.Builder injectMethodBuilder = MethodSpec.methodBuilder(<span class=\"string\">\"inject\"</span>)</span><br><span class=\"line\">\t\t\t\t.addModifiers(Modifier.PUBLIC)</span><br><span class=\"line\">\t\t\t\t.addAnnotation(Override.class)</span><br><span class=\"line\">\t\t\t\t.addParameter(TypeName.get(element.asType()), <span class=\"string\">\"host\"</span>, Modifier.FINAL)</span><br><span class=\"line\">\t\t\t\t.addParameter(TypeName.OBJECT, <span class=\"string\">\"obj\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//在方法中插入一行findViewById代码,遍历所有的元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> id : injectInfo.keySet()) &#123;</span><br><span class=\"line\">\t\t\tVariableElement element = injectInfo.get(id);</span><br><span class=\"line\">\t\t\tString name = element.getSimpleName().toString();</span><br><span class=\"line\">\t\t\tTypeMirror type = element.asType();</span><br><span class=\"line\">\t\t\tinjectMethodBuilder.addStatement(<span class=\"string\">\"host.$N = ($T)((($T) obj).findViewById($L))\"</span></span><br><span class=\"line\">\t\t\t\t\t, name, type, TypeUtil.ANDROID_ACTIVITY, id);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//生成class代码</span></span><br><span class=\"line\">\t\tTypeSpec clazz = TypeSpec.classBuilder(className)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//这里添加的接口类,并添加了泛型</span></span><br><span class=\"line\">\t\t\t\t.addSuperinterface(ParameterizedTypeName.get(TypeUtil.VIEWBIND, TypeName.get(element.asType())))</span><br><span class=\"line\">\t\t\t\t.addModifiers(Modifier.PUBLIC)</span><br><span class=\"line\">\t\t\t\t.addMethod(injectMethodBuilder.build())</span><br><span class=\"line\">\t\t\t\t.build();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> JavaFile.builder(packageName, clazz).build();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h5><p>主要的代码就在上面，注释写的应该比较清楚了，剩下的就是对项目进行配置。<br>我们需要在根项目的build.gradle中添加dependencies<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">classpath</span> <span class=\"string\">'com.neenbedankt.gradle.plugins:android-\tapt:1.8'</span></span><br></pre></td></tr></table></figure></p>\n<p>在app的build.gradle中添加<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: <span class=\"string\">'com.neenbedankt.android-apt'</span></span><br></pre></td></tr></table></figure></p>\n<p>然后添加dependencies<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':api'</span>)</span><br><span class=\"line\">   <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':annotation'</span>)</span><br><span class=\"line\">   apt <span class=\"keyword\">project</span>(<span class=\"string\">':compiler'</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h5><p>然后运行或者build项目就可以看到注解生成的类，目录是build/generated/source/apt/debug/包名<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>$$<span class=\"title\">ViewBinder</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewBind</span>&lt;<span class=\"title\">MainActivity</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inject</span><span class=\"params\">(<span class=\"keyword\">final</span> MainActivity host, Object obj)</span> </span>&#123;</span><br><span class=\"line\">    host.textView = (TextView)(((Activity) obj).findViewById(<span class=\"number\">2131492942</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h4><h5 id=\"编译报错\"><a href=\"#编译报错\" class=\"headerlink\" title=\"编译报错\"></a>编译报错</h5><p>在我开始尝试这个项目的时候，参考了很多别人的文章，都是正常的编码思路和源码，没有讲容易碰到的问题。我在参照别人写完demo，build的时候一直报错。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error:Execution failed for task &apos;:app:compileDebugJavaWithJavac&apos;.</span><br><span class=\"line\">&gt; java.lang.NullPointerException</span><br></pre></td></tr></table></figure></p>\n<p>这个错之前也碰到过，但是具体原因忘了，起初以为是gradle配置的问题，改来改去还是解决不了，搜索也解决不了。<br>后来注释掉了processor中的部分代码，发现build成功。原来是Processor中异常了。<br>所以报这种错的时候，检查一下自己的代码，肯定是有异常。</p>\n<h5 id=\"调试Processor\"><a href=\"#调试Processor\" class=\"headerlink\" title=\"调试Processor\"></a>调试Processor</h5><p>当Processor出现问题的时候，最直观寻找问题的方法就是debug。<br>Debug Processor步骤</p>\n<ul>\n<li>在Android studio中添加Remote Debugger，并确定port的设置是跟下面的参数一致</li>\n<li>在 gradle.properties文件中添加如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.gradle.parallel=true</span><br><span class=\"line\">org.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后添加断点，在你需要调试的地方，项目build的时候就可以调试了。</p>\n<h5 id=\"为什么要分开注解和处理器\"><a href=\"#为什么要分开注解和处理器\" class=\"headerlink\" title=\"为什么要分开注解和处理器\"></a>为什么要分开注解和处理器</h5><p>一方面是更好的解耦，我们的注解处理器可以用于其他项目。还有一个就是能避免65K方法数问题。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这个项目就是一个简单的APT demo，主要运用的就是注解的基础知道以及AbstractProcessor类和JavaPoet库生成Java代码，通过这个我们可以学习如何编写APT项目，实现起来并不复杂，但是注解处理器是一个非常强大的工具。整个的重心在于，通过这个我们能够知道有这么一种方式可以再编译期生成代码，简化我们的工作。更重要的是要有这么一个思路，可以去设计我们的架构，对架构实现更好的解耦，ARouter就是通过APT实现依赖反转，我也是抱着这些目的来学习注解。之后我会写运行时的注解处理器。</p>\n<h4 id=\"项目地址\"><a href=\"#项目地址\" class=\"headerlink\" title=\"项目地址\"></a>项目地址</h4><p><a href=\"https://github.com/PengsongAndroid/MyAnnotation\">https://github.com/PengsongAndroid/MyAnnotation</a></p>\n<p><strong>参考：</strong><br><a href=\"http://www.race604.com/annotation-processing/\" target=\"_blank\" rel=\"noopener\">Java注解处理器</a><br><a href=\"http://stackoverflow.com/questions/30959145/how-to-debug-the-apt-abstractprocessor-code-generation\" target=\"_blank\" rel=\"noopener\">How to debug the apt AbstractProcessor code generation?</a><br><a href=\"http://blog.csdn.net/lmj623565791/article/details/51931859\" target=\"_blank\" rel=\"noopener\">Android 如何编写基于编译时注解的项目</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjpw7fkrh0001gcl9yrenf4uf","category_id":"cjpw7fkrp0003gcl93ldtwqqz","_id":"cjpw7fkrv0008gcl9sj7biz9z"},{"post_id":"cjpw7fkrm0002gcl9tkytj30b","category_id":"cjpw7fkrp0003gcl93ldtwqqz","_id":"cjpw7fkrv000agcl9a2q13v1d"},{"post_id":"cjpw7fkxb000hgcl98tepc2ra","category_id":"cjpw7fkrp0003gcl93ldtwqqz","_id":"cjpw7fkxk000pgcl9xi47wzyw"},{"post_id":"cjpw7fkxf000jgcl9k33a5u5u","category_id":"cjpw7fkrp0003gcl93ldtwqqz","_id":"cjpw7fkxl000qgcl9qqrrpxli"},{"post_id":"cjpw7fkx2000bgcl93ht42qdo","category_id":"cjpw7fkxa000fgcl9bcl32x2s","_id":"cjpw7fkxm000sgcl9om3llrse"},{"post_id":"cjpw7fkx6000dgcl913pccavx","category_id":"cjpw7fkxa000fgcl9bcl32x2s","_id":"cjpw7fkxn000ugcl9ppm7fscg"},{"post_id":"cjpw7fkyt000ygcl9mc5oo8ub","category_id":"cjpw7fkyu000zgcl9expq06gv","_id":"cjpw7fkyw0012gcl9ink12r66"},{"post_id":"cjpw7fl0y0013gcl97ma7zf5e","category_id":"cjpw7fl0z0014gcl9syticzj5","_id":"cjpw7fl110017gcl9ldg4jcto"},{"post_id":"cjpw7fl240018gcl9aiorh6z4","category_id":"cjpw7fkxa000fgcl9bcl32x2s","_id":"cjpw7fl26001agcl9k2ptes1i"}],"PostTag":[{"post_id":"cjpw7fkrh0001gcl9yrenf4uf","tag_id":"cjpw7fkrr0004gcl9dy3zavdt","_id":"cjpw7fkru0007gcl9atv54o8h"},{"post_id":"cjpw7fkrm0002gcl9tkytj30b","tag_id":"cjpw7fkrs0006gcl9hpo55bf2","_id":"cjpw7fkrv0009gcl9ch4sl13n"},{"post_id":"cjpw7fkx2000bgcl93ht42qdo","tag_id":"cjpw7fkxb000ggcl9v31pkep3","_id":"cjpw7fkxk000ogcl925vgag7y"},{"post_id":"cjpw7fkx6000dgcl913pccavx","tag_id":"cjpw7fkxj000mgcl97ajzzk56","_id":"cjpw7fkxm000tgcl9kodc5qfh"},{"post_id":"cjpw7fkxb000hgcl98tepc2ra","tag_id":"cjpw7fkxl000rgcl96uqcdbky","_id":"cjpw7fkxn000wgcl93ozyy6zy"},{"post_id":"cjpw7fkxf000jgcl9k33a5u5u","tag_id":"cjpw7fkxn000vgcl9ldkor9zz","_id":"cjpw7fkxo000xgcl9af9p3b4j"},{"post_id":"cjpw7fkyt000ygcl9mc5oo8ub","tag_id":"cjpw7fkyv0010gcl9xyvdin2k","_id":"cjpw7fkyw0011gcl9l7r7x3mg"},{"post_id":"cjpw7fl0y0013gcl97ma7zf5e","tag_id":"cjpw7fl100015gcl9hya48j6w","_id":"cjpw7fl100016gcl9yiy9sx4u"},{"post_id":"cjpw7fl240018gcl9aiorh6z4","tag_id":"cjpw7fl260019gcl9rdkakox6","_id":"cjpw7fl27001bgcl99k4rxc0h"}],"Tag":[{"name":"Android studio, 环境问题","_id":"cjpw7fkrr0004gcl9dy3zavdt"},{"name":"Android, .so, Android studio","_id":"cjpw7fkrs0006gcl9hpo55bf2"},{"name":"Android, Annotation, 注解, 运行时注解, EventBus","_id":"cjpw7fkxb000ggcl9v31pkep3"},{"name":"Android, 应用退出","_id":"cjpw7fkxj000mgcl97ajzzk56"},{"name":"Android, 开源库, Dagger","_id":"cjpw7fkxl000rgcl96uqcdbky"},{"name":"Android, Android权限机制","_id":"cjpw7fkxn000vgcl9ldkor9zz"},{"name":"Android, 常见问题","_id":"cjpw7fkyv0010gcl9xyvdin2k"},{"name":"Android, 第三方框架","_id":"cjpw7fl100015gcl9hya48j6w"},{"name":"Android, Annotation, 注解","_id":"cjpw7fl260019gcl9rdkakox6"}]}}